/* Copyright (c) Microsoft Corporation.

Use of this source code is governed by an MIT-style
license that can be found in the LICENSE file or at
https://opensource.org/licenses/MIT.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// clang-format off

// This file is generated. Do not edit it directly. See generate_op_defs_core.py.
#pragma once

namespace tfdml::ops
{
struct RiscBinaryArithmetic
{
    static constexpr const char* name = "RiscBinaryArithmetic";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        op_type,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"op_type", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RpcServer
{
    static constexpr const char* name = "RpcServer";
    
    enum class Argument
    {
        server_address,
        server
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"server_address", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"server", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Mod
{
    static constexpr const char* name = "Mod";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RemoteCall
{
    static constexpr const char* name = "RemoteCall";
    
    enum class Argument
    {
        target,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"target", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        f
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func}
    };
};

struct RefOutput
{
    static constexpr const char* name = "RefOutput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorMapInsert
{
    static constexpr const char* name = "TensorMapInsert";
    
    enum class Argument
    {
        input_handle,
        key,
        value,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct RpcClient
{
    static constexpr const char* name = "RpcClient";
    
    enum class Argument
    {
        server_address,
        timeout_in_ms,
        client,
        method_specs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"server_address", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"timeout_in_ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"client", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"method_specs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shared_name,
        list_registered_methods
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"list_registered_methods", AttributeType::Bool}
    };
};

struct ResourceApplyKerasMomentum
{
    static constexpr const char* name = "ResourceApplyKerasMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        momentum
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct RpcServerStart
{
    static constexpr const char* name = "RpcServerStart";
    
    enum class Argument
    {
        server
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"server", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct IntAttr
{
    static constexpr const char* name = "IntAttr";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        foo
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"foo", AttributeType::Int}
    };
};

struct DeleteRpcFutureResource
{
    static constexpr const char* name = "DeleteRpcFutureResource";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct XlaSplitND
{
    static constexpr const char* name = "XlaSplitND";
    
    enum class Argument
    {
        input,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N,
        num_splits,
        paddings
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_splits", AttributeType::ListInt},
        AttributeDesc{"paddings", AttributeType::ListInt}
    };
};

struct RefExit
{
    static constexpr const char* name = "RefExit";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RpcServerRegister
{
    static constexpr const char* name = "RpcServerRegister";
    
    enum class Argument
    {
        server,
        method_name,
        captured_inputs
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"server", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"method_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"captured_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"}
    };

    enum class Attribute
    {
        Tin,
        f,
        input_specs,
        output_specs
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"input_specs", AttributeType::String},
        AttributeDesc{"output_specs", AttributeType::String}
    };
};

struct OpWithDefaultAttr
{
    static constexpr const char* name = "OpWithDefaultAttr";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        default_float
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"default_float", AttributeType::Float}
    };
};

struct DestroyTemporaryVariable
{
    static constexpr const char* name = "DestroyTemporaryVariable";
    
    enum class Argument
    {
        ref,
        value
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        var_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"var_name", AttributeType::String}
    };
};

struct RpcCall
{
    static constexpr const char* name = "RpcCall";
    
    enum class Argument
    {
        client,
        method_name,
        args,
        future,
        deleter
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"client", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"method_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"future", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType}
    };
};

struct IntInputIntOutput
{
    static constexpr const char* name = "IntInputIntOutput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklBatchMatMul
{
    static constexpr const char* name = "_MklBatchMatMul";
    
    enum class Argument
    {
        x,
        y,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        adj_x,
        adj_y
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"adj_x", AttributeType::Bool},
        AttributeDesc{"adj_y", AttributeType::Bool}
    };
};

struct _MklFusedBatchNormGradV3
{
    static constexpr const char* name = "_MklFusedBatchNormGradV3";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        mkl_y_backprop,
        mkl_x,
        mkl_scale,
        mkl_reserve_space_1,
        mkl_reserve_space_2,
        mkl_reserve_space_3,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_4,
        reserve_space_5,
        mkl_x_backprop,
        mkl_scale_backprop,
        mkl_offset_backprop,
        mkl_reserve_space_4,
        mkl_reserve_space_5
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 10;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_5", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_5", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct SparseReduceSumSparse
{
    static constexpr const char* name = "SparseReduceSumSparse";
    
    enum class Argument
    {
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_axes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ControlTrigger
{
    static constexpr const char* name = "ControlTrigger";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RpcCheckStatus
{
    static constexpr const char* name = "RpcCheckStatus";
    
    enum class Argument
    {
        status_or,
        error_code,
        error
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"status_or", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"error_code", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"error", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _ConfigureDistributedTPU
{
    static constexpr const char* name = "_ConfigureDistributedTPU";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        enable_whole_mesh_compilations
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"enable_whole_mesh_compilations", AttributeType::Bool}
    };
};

struct GenerateVocabRemapping
{
    static constexpr const char* name = "GenerateVocabRemapping";
    
    enum class Argument
    {
        new_vocab_file,
        old_vocab_file,
        remapping,
        num_present
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"new_vocab_file", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"old_vocab_file", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"remapping", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_present", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        new_vocab_offset,
        num_new_vocab,
        old_vocab_size
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"new_vocab_offset", AttributeType::Int},
        AttributeDesc{"num_new_vocab", AttributeType::Int},
        AttributeDesc{"old_vocab_size", AttributeType::Int}
    };
};

struct KernelLabel
{
    static constexpr const char* name = "KernelLabel";
    
    enum class Argument
    {
        result
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"result", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QuantizedConcatV2
{
    static constexpr const char* name = "QuantizedConcatV2";
    
    enum class Argument
    {
        values,
        axis,
        input_mins,
        input_maxes,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_mins", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"input_maxes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct ParallelBatchDataset
{
    static constexpr const char* name = "ParallelBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        parallel_copy,
        output_types,
        output_shapes,
        deterministic
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"parallel_copy", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"deterministic", AttributeType::String}
    };
};

struct ResourceApplyAdaMax
{
    static constexpr const char* name = "ResourceApplyAdaMax";
    
    enum class Argument
    {
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct RpcGetValue
{
    static constexpr const char* name = "RpcGetValue";
    
    enum class Argument
    {
        status_or,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"status_or", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tout
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct MergeSummary
{
    static constexpr const char* name = "MergeSummary";
    
    enum class Argument
    {
        inputs,
        summary
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct Unary
{
    static constexpr const char* name = "Unary";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BlockLSTM
{
    static constexpr const char* name = "BlockLSTM";
    
    enum class Argument
    {
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seq_len_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        forget_bias,
        cell_clip,
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"forget_bias", AttributeType::Float},
        AttributeDesc{"cell_clip", AttributeType::Float},
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Log1p
{
    static constexpr const char* name = "Log1p";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TfLiteSubgraphExecute
{
    static constexpr const char* name = "TfLiteSubgraphExecute";
    
    enum class Argument
    {
        subgraph_key,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"subgraph_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct ConstructionFails
{
    static constexpr const char* name = "ConstructionFails";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct KernelLabelRequired
{
    static constexpr const char* name = "KernelLabelRequired";
    
    enum class Argument
    {
        input,
        result
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BoostedTreesCreateQuantileStreamResource
{
    static constexpr const char* name = "BoostedTreesCreateQuantileStreamResource";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        epsilon,
        num_streams
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_streams", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_elements
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"max_elements", AttributeType::Int}
    };
};

struct GraphDefVersion
{
    static constexpr const char* name = "GraphDefVersion";
    
    enum class Argument
    {
        version
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"version", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RequiresOlderGraphVersion
{
    static constexpr const char* name = "RequiresOlderGraphVersion";
    
    enum class Argument
    {
        version
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"version", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Old
{
    static constexpr const char* name = "Old";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Imag
{
    static constexpr const char* name = "Imag";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct StackV2
{
    static constexpr const char* name = "StackV2";
    
    enum class Argument
    {
        max_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"max_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        elem_type,
        stack_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"elem_type", AttributeType::Type},
        AttributeDesc{"stack_name", AttributeType::String}
    };
};

struct FakeQueue
{
    static constexpr const char* name = "FakeQueue";
    
    enum class Argument
    {
        resource,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Round
{
    static constexpr const char* name = "Round";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ScatterMin
{
    static constexpr const char* name = "ScatterMin";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct GetDeadline
{
    static constexpr const char* name = "GetDeadline";
    
    enum class Argument
    {
        deadline_from_epoch_micros
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"deadline_from_epoch_micros", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BesselK1
{
    static constexpr const char* name = "BesselK1";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SleepOp
{
    static constexpr const char* name = "SleepOp";
    
    enum class Argument
    {
        sleep_seconds
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sleep_seconds", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Assign
{
    static constexpr const char* name = "Assign";
    
    enum class Argument
    {
        ref,
        value,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        validate_shape,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"validate_shape", AttributeType::Bool},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct StubResourceHandleOp
{
    static constexpr const char* name = "StubResourceHandleOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorListReserve
{
    static constexpr const char* name = "TensorListReserve";
    
    enum class Argument
    {
        element_shape,
        num_elements,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct _MklReshape
{
    static constexpr const char* name = "_MklReshape";
    
    enum class Argument
    {
        tensor,
        shape,
        mkl_tensor,
        mkl_shape,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct ResourceCreateOp
{
    static constexpr const char* name = "ResourceCreateOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CollectiveGather
{
    static constexpr const char* name = "CollectiveGather";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        group_size,
        group_key,
        instance_key,
        shape,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"group_size", AttributeType::Int},
        AttributeDesc{"group_key", AttributeType::Int},
        AttributeDesc{"instance_key", AttributeType::Int},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct _XlaHostComputeMlir
{
    static constexpr const char* name = "_XlaHostComputeMlir";
    
    enum class Argument
    {
        inputs,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "Toutputs"}
    };

    enum class Attribute
    {
        Tinputs,
        Toutputs,
        send_key,
        recv_key,
        tpu_core,
        host_mlir_module
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"Toutputs", AttributeType::ListType},
        AttributeDesc{"send_key", AttributeType::String},
        AttributeDesc{"recv_key", AttributeType::String},
        AttributeDesc{"tpu_core", AttributeType::Int},
        AttributeDesc{"host_mlir_module", AttributeType::String}
    };
};

struct WriteAudioSummary
{
    static constexpr const char* name = "WriteAudioSummary";
    
    enum class Argument
    {
        writer,
        step,
        tag,
        tensor,
        sample_rate
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample_rate", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_outputs
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"max_outputs", AttributeType::Int}
    };
};

struct SetSize
{
    static constexpr const char* name = "SetSize";
    
    enum class Argument
    {
        set_indices,
        set_values,
        set_shape,
        size
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"set_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        validate_indices,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _Recv
{
    static constexpr const char* name = "_Recv";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        tensor_type,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"tensor_type", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct RandomShuffleQueueV2
{
    static constexpr const char* name = "RandomShuffleQueueV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        min_after_dequeue,
        seed,
        seed2,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"min_after_dequeue", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct NInTwice
{
    static constexpr const char* name = "NInTwice";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct ResourceInitializedOp
{
    static constexpr const char* name = "ResourceInitializedOp";
    
    enum class Argument
    {
        resource,
        initialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ExperimentalLatencyStatsDataset
{
    static constexpr const char* name = "ExperimentalLatencyStatsDataset";
    
    enum class Argument
    {
        input_dataset,
        tag,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _MklQuantizedDepthwiseConv2D
{
    static constexpr const char* name = "_MklQuantizedDepthwiseConv2D";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct ListOutput
{
    static constexpr const char* name = "ListOutput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct ExperimentalMaxIntraOpParallelismDataset
{
    static constexpr const char* name = "ExperimentalMaxIntraOpParallelismDataset";
    
    enum class Argument
    {
        input_dataset,
        max_intra_op_parallelism,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_intra_op_parallelism", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RiscSlice
{
    static constexpr const char* name = "RiscSlice";
    
    enum class Argument
    {
        input,
        begin,
        size,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type}
    };
};

struct _SwitchN
{
    static constexpr const char* name = "_SwitchN";
    
    enum class Argument
    {
        data,
        output_index,
        outputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_outs"}
    };

    enum class Attribute
    {
        num_outs,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_outs", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct WriteScalarSummary
{
    static constexpr const char* name = "WriteScalarSummary";
    
    enum class Argument
    {
        writer,
        step,
        tag,
        value
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseDenseCwiseAdd
{
    static constexpr const char* name = "SparseDenseCwiseAdd";
    
    enum class Argument
    {
        sp_indices,
        sp_values,
        sp_shape,
        dense,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sp_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TwoIntOutputs
{
    static constexpr const char* name = "TwoIntOutputs";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Div
{
    static constexpr const char* name = "Div";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Conv3D
{
    static constexpr const char* name = "Conv3D";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct Fill
{
    static constexpr const char* name = "Fill";
    
    enum class Argument
    {
        dims,
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dims", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        index_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"index_type", AttributeType::Type}
    };
};

struct ResourceUsingOp
{
    static constexpr const char* name = "ResourceUsingOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TestStringOutput
{
    static constexpr const char* name = "TestStringOutput";
    
    enum class Argument
    {
        input,
        output1,
        output2
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Reciprocal
{
    static constexpr const char* name = "Reciprocal";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct EditDistance
{
    static constexpr const char* name = "EditDistance";
    
    enum class Argument
    {
        hypothesis_indices,
        hypothesis_values,
        hypothesis_shape,
        truth_indices,
        truth_values,
        truth_shape,
        output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"hypothesis_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"hypothesis_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"hypothesis_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"truth_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"truth_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"truth_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        normalize,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"normalize", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Namespace_TestStringOutput
{
    static constexpr const char* name = "Namespace>TestStringOutput";
    
    enum class Argument
    {
        input,
        output1,
        output2
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Foo1
{
    static constexpr const char* name = "Foo1";
    
    enum class Argument
    {
        a,
        b,
        c,
        d,
        e
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TestAttr
{
    static constexpr const char* name = "TestAttr";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct EncodePng
{
    static constexpr const char* name = "EncodePng";
    
    enum class Argument
    {
        image,
        contents
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compression,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"compression", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Foo3
{
    static constexpr const char* name = "Foo3";
    
    enum class Argument
    {
        a,
        b,
        c,
        d,
        e
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct LookupTableSizeV2
{
    static constexpr const char* name = "LookupTableSizeV2";
    
    enum class Argument
    {
        table_handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SampleDistortedBoundingBoxV2
{
    static constexpr const char* name = "SampleDistortedBoundingBoxV2";
    
    enum class Argument
    {
        image_size,
        bounding_boxes,
        min_object_covered,
        begin,
        size,
        bboxes
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bounding_boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_object_covered", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bboxes", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        seed,
        seed2,
        aspect_ratio_range,
        area_range,
        max_attempts,
        use_image_if_no_bounding_boxes
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"aspect_ratio_range", AttributeType::ListFloat},
        AttributeDesc{"area_range", AttributeType::ListFloat},
        AttributeDesc{"max_attempts", AttributeType::Int},
        AttributeDesc{"use_image_if_no_bounding_boxes", AttributeType::Bool}
    };
};

struct A
{
    static constexpr const char* name = "A";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ThreadPoolDataset
{
    static constexpr const char* name = "ThreadPoolDataset";
    
    enum class Argument
    {
        input_dataset,
        thread_pool,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thread_pool", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Softplus
{
    static constexpr const char* name = "Softplus";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StopGradient
{
    static constexpr const char* name = "StopGradient";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FiveFloatOutputs
{
    static constexpr const char* name = "FiveFloatOutputs";
    
    enum class Argument
    {
        a,
        b,
        c,
        d,
        e
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct B
{
    static constexpr const char* name = "B";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ApplyProximalGradientDescent
{
    static constexpr const char* name = "ApplyProximalGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        l1,
        l2,
        delta,
        out
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ParseTensor
{
    static constexpr const char* name = "ParseTensor";
    
    enum class Argument
    {
        serialized,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        out_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct PreventGradient
{
    static constexpr const char* name = "PreventGradient";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        message
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"message", AttributeType::String}
    };
};

struct Bucketize
{
    static constexpr const char* name = "Bucketize";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        boundaries
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"boundaries", AttributeType::ListFloat}
    };
};

struct DynamicStitch
{
    static constexpr const char* name = "DynamicStitch";
    
    enum class Argument
    {
        indices,
        data,
        merged
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"merged", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Foo2
{
    static constexpr const char* name = "Foo2";
    
    enum class Argument
    {
        a,
        b,
        c,
        d,
        e
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CopyOp
{
    static constexpr const char* name = "CopyOp";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FloatInput
{
    static constexpr const char* name = "FloatInput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ConditionalAccumulator
{
    static constexpr const char* name = "ConditionalAccumulator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        container,
        shared_name,
        reduction_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"reduction_type", AttributeType::String}
    };
};

struct XlaVariadicReduceV2
{
    static constexpr const char* name = "XlaVariadicReduceV2";
    
    enum class Argument
    {
        inputs,
        init_values,
        outputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"init_values", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        dimensions_to_reduce,
        reducer
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"dimensions_to_reduce", AttributeType::ListInt},
        AttributeDesc{"reducer", AttributeType::Func}
    };
};

struct Erfinv
{
    static constexpr const char* name = "Erfinv";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedConv2DWithBias
{
    static constexpr const char* name = "QuantizedConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct None
{
    static constexpr const char* name = "None";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ApplyFtrl
{
    static constexpr const char* name = "ApplyFtrl";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        lr_power,
        out
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct PaddingFIFOQueue
{
    static constexpr const char* name = "PaddingFIFOQueue";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ListInput
{
    static constexpr const char* name = "ListInput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TwoFloatInputsFloatOutput
{
    static constexpr const char* name = "TwoFloatInputsFloatOutput";
    
    enum class Argument
    {
        a,
        b,
        c
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CompositeTensorVariantToComponents
{
    static constexpr const char* name = "CompositeTensorVariantToComponents";
    
    enum class Argument
    {
        encoded,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"encoded", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"}
    };

    enum class Attribute
    {
        metadata,
        Tcomponents
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"metadata", AttributeType::String},
        AttributeDesc{"Tcomponents", AttributeType::ListType}
    };
};

struct RiscCeil
{
    static constexpr const char* name = "RiscCeil";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixDiagV2
{
    static constexpr const char* name = "MatrixDiagV2";
    
    enum class Argument
    {
        diagonal,
        k,
        num_rows,
        num_cols,
        padding_value,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_rows", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscCondition
{
    static constexpr const char* name = "RiscCondition";
    
    enum class Argument
    {
        pred,
        input_true,
        input_false,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"pred", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_true", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_false", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        func_true,
        func_false,
        SrcT,
        DstT
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"func_true", AttributeType::Func},
        AttributeDesc{"func_false", AttributeType::Func},
        AttributeDesc{"SrcT", AttributeType::Type},
        AttributeDesc{"DstT", AttributeType::Type}
    };
};

struct IntOutput
{
    static constexpr const char* name = "IntOutput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Int64Output
{
    static constexpr const char* name = "Int64Output";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CudnnRNNV3
{
    static constexpr const char* name = "CudnnRNNV3";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        sequence_lengths,
        output,
        output_h,
        output_c,
        reserve_space,
        host_reserved
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"host_reserved", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        num_proj,
        is_training,
        time_major
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"num_proj", AttributeType::Int},
        AttributeDesc{"is_training", AttributeType::Bool},
        AttributeDesc{"time_major", AttributeType::Bool}
    };
};

struct PolymorphicDefaultOut
{
    static constexpr const char* name = "PolymorphicDefaultOut";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct All
{
    static constexpr const char* name = "All";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct QuantizedBatchNormWithGlobalNormalization
{
    static constexpr const char* name = "QuantizedBatchNormWithGlobalNormalization";
    
    enum class Argument
    {
        t,
        t_min,
        t_max,
        m,
        m_min,
        m_max,
        v,
        v_min,
        v_max,
        beta,
        beta_min,
        beta_max,
        gamma,
        gamma_min,
        gamma_max,
        result,
        result_min,
        result_max
    };

    static constexpr uint32_t input_arg_count = 15;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"t_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"t_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gamma", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gamma_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gamma_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type,
        variance_epsilon,
        scale_after_normalization
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"variance_epsilon", AttributeType::Float},
        AttributeDesc{"scale_after_normalization", AttributeType::Bool}
    };
};

struct CudnnRNNCanonicalToParamsV2
{
    static constexpr const char* name = "CudnnRNNCanonicalToParamsV2";
    
    enum class Argument
    {
        num_layers,
        num_units,
        input_size,
        weights,
        biases,
        params
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"num_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_units", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params_weights"},
        ArgumentDesc{"biases", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params_biases"},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_params_weights,
        num_params_biases,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        num_proj
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_params_weights", AttributeType::Int},
        AttributeDesc{"num_params_biases", AttributeType::Int},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"num_proj", AttributeType::Int}
    };
};

struct IntInputFloatInput
{
    static constexpr const char* name = "IntInputFloatInput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FakeQuantWithMinMaxArgs
{
    static constexpr const char* name = "FakeQuantWithMinMaxArgs";
    
    enum class Argument
    {
        inputs,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        min,
        max,
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"min", AttributeType::Float},
        AttributeDesc{"max", AttributeType::Float},
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct SampleDistortedBoundingBox
{
    static constexpr const char* name = "SampleDistortedBoundingBox";
    
    enum class Argument
    {
        image_size,
        bounding_boxes,
        begin,
        size,
        bboxes
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bounding_boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bboxes", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        seed,
        seed2,
        min_object_covered,
        aspect_ratio_range,
        area_range,
        max_attempts,
        use_image_if_no_bounding_boxes
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"min_object_covered", AttributeType::Float},
        AttributeDesc{"aspect_ratio_range", AttributeType::ListFloat},
        AttributeDesc{"area_range", AttributeType::ListFloat},
        AttributeDesc{"max_attempts", AttributeType::Int},
        AttributeDesc{"use_image_if_no_bounding_boxes", AttributeType::Bool}
    };
};

struct FlatMapDataset
{
    static constexpr const char* name = "FlatMapDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct FloatOutput
{
    static constexpr const char* name = "FloatOutput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OutT
{
    static constexpr const char* name = "OutT";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TwoFloatOutputs
{
    static constexpr const char* name = "TwoFloatOutputs";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RefOutputFloatOutput
{
    static constexpr const char* name = "RefOutputFloatOutput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Pad
{
    static constexpr const char* name = "Pad";
    
    enum class Argument
    {
        input,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct XlaRecvFromHost
{
    static constexpr const char* name = "XlaRecvFromHost";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Toutput,
        shape,
        key
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"key", AttributeType::String}
    };
};

struct DefaultAttrs
{
    static constexpr const char* name = "DefaultAttrs";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        string_val,
        string_list_val,
        int_val,
        int_list_val,
        float_val,
        float_list_val,
        bool_val,
        bool_list_val,
        type_val,
        type_list_val,
        shape_val,
        shape_list_val,
        tensor_val,
        tensor_list_val
    };

    static constexpr std::array<AttributeDesc, 14> attribute_descs
    {
        AttributeDesc{"string_val", AttributeType::String},
        AttributeDesc{"string_list_val", AttributeType::ListString},
        AttributeDesc{"int_val", AttributeType::Int},
        AttributeDesc{"int_list_val", AttributeType::ListInt},
        AttributeDesc{"float_val", AttributeType::Float},
        AttributeDesc{"float_list_val", AttributeType::ListFloat},
        AttributeDesc{"bool_val", AttributeType::Bool},
        AttributeDesc{"bool_list_val", AttributeType::ListBool},
        AttributeDesc{"type_val", AttributeType::Type},
        AttributeDesc{"type_list_val", AttributeType::ListType},
        AttributeDesc{"shape_val", AttributeType::Shape},
        AttributeDesc{"shape_list_val", AttributeType::ListShape},
        AttributeDesc{"tensor_val", AttributeType::Tensor},
        AttributeDesc{"tensor_list_val", AttributeType::ListTensor}
    };
};

struct DummyIterationCounter
{
    static constexpr const char* name = "DummyIterationCounter";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RefInputFloatInput
{
    static constexpr const char* name = "RefInputFloatInput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FloorDiv
{
    static constexpr const char* name = "FloorDiv";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Igammac
{
    static constexpr const char* name = "Igammac";
    
    enum class Argument
    {
        a,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CreateSummaryDbWriter
{
    static constexpr const char* name = "CreateSummaryDbWriter";
    
    enum class Argument
    {
        writer,
        db_uri,
        experiment_name,
        run_name,
        user_name
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"db_uri", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"experiment_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"run_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"user_name", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SkipDataset
{
    static constexpr const char* name = "SkipDataset";
    
    enum class Argument
    {
        input_dataset,
        count,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RiscReal
{
    static constexpr const char* name = "RiscReal";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct IntInput
{
    static constexpr const char* name = "IntInput";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CudnnRNNBackpropV3
{
    static constexpr const char* name = "CudnnRNNBackpropV3";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        sequence_lengths,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        input_backprop,
        input_h_backprop,
        input_c_backprop,
        params_backprop
    };

    static constexpr uint32_t input_arg_count = 13;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"host_reserved", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        num_proj,
        time_major
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"num_proj", AttributeType::Int},
        AttributeDesc{"time_major", AttributeType::Bool}
    };
};

struct OrderedMapStage
{
    static constexpr const char* name = "OrderedMapStage";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "fake_dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        fake_dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"fake_dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct MatrixDiagPart
{
    static constexpr const char* name = "MatrixDiagPart";
    
    enum class Argument
    {
        input,
        diagonal
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct IntOutputFloatOutput
{
    static constexpr const char* name = "IntOutputFloatOutput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ChooseFastestDataset
{
    static constexpr const char* name = "ChooseFastestDataset";
    
    enum class Argument
    {
        input_datasets,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_datasets", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        num_experiments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_experiments", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TwoFloatInputsIntOutput
{
    static constexpr const char* name = "TwoFloatInputsIntOutput";
    
    enum class Argument
    {
        a,
        b,
        c
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorDataset
{
    static constexpr const char* name = "TensorDataset";
    
    enum class Argument
    {
        components,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Toutput_types"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Toutput_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Toutput_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct FloatOutputStringOutput
{
    static constexpr const char* name = "FloatOutputStringOutput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TwoIntInputs
{
    static constexpr const char* name = "TwoIntInputs";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct IteratorGetDevice
{
    static constexpr const char* name = "IteratorGetDevice";
    
    enum class Argument
    {
        resource,
        device
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"device", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CrossReplicaSum
{
    static constexpr const char* name = "CrossReplicaSum";
    
    enum class Argument
    {
        input,
        group_assignment,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_assignment", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Size
{
    static constexpr const char* name = "Size";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct TwoFloatInputs
{
    static constexpr const char* name = "TwoFloatInputs";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OpWithFutureDefaultAttr
{
    static constexpr const char* name = "OpWithFutureDefaultAttr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StatelessRandomGammaV2
{
    static constexpr const char* name = "StatelessRandomGammaV2";
    
    enum class Argument
    {
        shape,
        seed,
        alpha,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct RefInputIntInput
{
    static constexpr const char* name = "RefInputIntInput";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct EncodeJpeg
{
    static constexpr const char* name = "EncodeJpeg";
    
    enum class Argument
    {
        image,
        contents
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        format,
        quality,
        progressive,
        optimize_size,
        chroma_downsampling,
        density_unit,
        x_density,
        y_density,
        xmp_metadata
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"format", AttributeType::String},
        AttributeDesc{"quality", AttributeType::Int},
        AttributeDesc{"progressive", AttributeType::Bool},
        AttributeDesc{"optimize_size", AttributeType::Bool},
        AttributeDesc{"chroma_downsampling", AttributeType::Bool},
        AttributeDesc{"density_unit", AttributeType::String},
        AttributeDesc{"x_density", AttributeType::Int},
        AttributeDesc{"y_density", AttributeType::Int},
        AttributeDesc{"xmp_metadata", AttributeType::String}
    };
};

struct _MklAvgPoolGrad
{
    static constexpr const char* name = "_MklAvgPoolGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        mkl_orig_input,
        mkl_grad,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Where
{
    static constexpr const char* name = "Where";
    
    enum class Argument
    {
        input,
        index
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RefInputFloatInputIntOutput
{
    static constexpr const char* name = "RefInputFloatInputIntOutput";
    
    enum class Argument
    {
        a,
        b,
        c
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Split
{
    static constexpr const char* name = "Split";
    
    enum class Argument
    {
        split_dim,
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"split_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "num_split"}
    };

    enum class Attribute
    {
        num_split,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_split", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StringListAttr
{
    static constexpr const char* name = "StringListAttr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a,
        b
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListString},
        AttributeDesc{"b", AttributeType::String}
    };
};

struct StatelessWhile
{
    static constexpr const char* name = "StatelessWhile";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        cond,
        body,
        output_shapes,
        parallel_iterations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"cond", AttributeType::Func},
        AttributeDesc{"body", AttributeType::Func},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"parallel_iterations", AttributeType::Int}
    };
};

struct FuncAttr
{
    static constexpr const char* name = "FuncAttr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        f
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func}
    };
};

struct XlaSetBound
{
    static constexpr const char* name = "XlaSetBound";
    
    enum class Argument
    {
        input,
        bound,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bound", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FuncListAttr
{
    static constexpr const char* name = "FuncListAttr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        f
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"f", AttributeType::ListFunc}
    };
};

struct LMDBDataset
{
    static constexpr const char* name = "LMDBDataset";
    
    enum class Argument
    {
        filenames,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct NPolymorphicRestrictIn
{
    static constexpr const char* name = "NPolymorphicRestrictIn";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct Simple
{
    static constexpr const char* name = "Simple";
    
    enum class Argument
    {
        a,
        out
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct MulNoNan
{
    static constexpr const char* name = "MulNoNan";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DecodeProtoV2
{
    static constexpr const char* name = "DecodeProtoV2";
    
    enum class Argument
    {
        bytes,
        sizes,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        message_type,
        field_names,
        output_types,
        descriptor_source,
        message_format,
        sanitize
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"message_type", AttributeType::String},
        AttributeDesc{"field_names", AttributeType::ListString},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"descriptor_source", AttributeType::String},
        AttributeDesc{"message_format", AttributeType::String},
        AttributeDesc{"sanitize", AttributeType::Bool}
    };
};

struct FilterByLastComponentDataset
{
    static constexpr const char* name = "FilterByLastComponentDataset";
    
    enum class Argument
    {
        input_dataset,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct XlaDotV2
{
    static constexpr const char* name = "XlaDotV2";
    
    enum class Argument
    {
        lhs,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"lhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        LhsT,
        RhsT,
        dimension_numbers,
        precision_config,
        preferred_element_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"LhsT", AttributeType::Type},
        AttributeDesc{"RhsT", AttributeType::Type},
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"precision_config", AttributeType::String},
        AttributeDesc{"preferred_element_type", AttributeType::Type}
    };
};

struct OutfeedDequeueV2
{
    static constexpr const char* name = "OutfeedDequeueV2";
    
    enum class Argument
    {
        device_ordinal,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"device_ordinal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct ReservedInput
{
    static constexpr const char* name = "ReservedInput";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Polymorphic
{
    static constexpr const char* name = "Polymorphic";
    
    enum class Argument
    {
        a,
        out
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _XlaSendFromHost
{
    static constexpr const char* name = "_XlaSendFromHost";
    
    enum class Argument
    {
        inputs,
        dynamic_key
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"dynamic_key", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinputs,
        key,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"key", AttributeType::String},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct Tile
{
    static constexpr const char* name = "Tile";
    
    enum class Argument
    {
        input,
        multiples,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"multiples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tmultiples
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tmultiples", AttributeType::Type}
    };
};

struct AssignVariableXlaConcatND
{
    static constexpr const char* name = "AssignVariableXlaConcatND";
    
    enum class Argument
    {
        resource,
        inputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N,
        num_concats,
        paddings
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_concats", AttributeType::ListInt},
        AttributeDesc{"paddings", AttributeType::ListInt}
    };
};

struct PolymorphicOut
{
    static constexpr const char* name = "PolymorphicOut";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CollectiveBcastSend
{
    static constexpr const char* name = "CollectiveBcastSend";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        group_size,
        group_key,
        instance_key,
        shape,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"group_size", AttributeType::Int},
        AttributeDesc{"group_key", AttributeType::Int},
        AttributeDesc{"instance_key", AttributeType::Int},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct _MklSlice
{
    static constexpr const char* name = "_MklSlice";
    
    enum class Argument
    {
        input,
        begin,
        size,
        mkl_input,
        mkl_begin,
        mkl_size,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type}
    };
};

struct TPUReshardVariables
{
    static constexpr const char* name = "TPUReshardVariables";
    
    enum class Argument
    {
        vars,
        new_format_key,
        format_state_var
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"vars", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"new_format_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"format_state_var", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct Binary
{
    static constexpr const char* name = "Binary";
    
    enum class Argument
    {
        a,
        b,
        out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaWhile
{
    static constexpr const char* name = "XlaWhile";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        cond,
        body
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"cond", AttributeType::Func},
        AttributeDesc{"body", AttributeType::Func}
    };
};

struct DatasetCardinality
{
    static constexpr const char* name = "DatasetCardinality";
    
    enum class Argument
    {
        input_dataset,
        cardinality
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cardinality", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BatchDatasetV2
{
    static constexpr const char* name = "BatchDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        parallel_copy,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"parallel_copy", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Restrict
{
    static constexpr const char* name = "Restrict";
    
    enum class Argument
    {
        a,
        out
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CholeskyGrad
{
    static constexpr const char* name = "CholeskyGrad";
    
    enum class Argument
    {
        l,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"l", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TypeList
{
    static constexpr const char* name = "TypeList";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct TypeListTwice
{
    static constexpr const char* name = "TypeListTwice";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct AudioSummary
{
    static constexpr const char* name = "AudioSummary";
    
    enum class Argument
    {
        tag,
        tensor,
        summary
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sample_rate,
        max_outputs
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"sample_rate", AttributeType::Float},
        AttributeDesc{"max_outputs", AttributeType::Int}
    };
};

struct OutTypeList
{
    static constexpr const char* name = "OutTypeList";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct NonMaxSuppressionV2
{
    static constexpr const char* name = "NonMaxSuppressionV2";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        selected_indices
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iou_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        T_threshold
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"T_threshold", AttributeType::Type}
    };
};

struct Slice
{
    static constexpr const char* name = "Slice";
    
    enum class Argument
    {
        input,
        begin,
        size,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type}
    };
};

struct TypeListRestrict
{
    static constexpr const char* name = "TypeListRestrict";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct OutTypeListRestrict
{
    static constexpr const char* name = "OutTypeListRestrict";
    
    enum class Argument
    {
        out
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out", ArgumentDesc::TensorCount::SequenceAttrList, "t"}
    };

    enum class Attribute
    {
        t
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"t", AttributeType::ListType}
    };
};

struct TensorArrayClose
{
    static constexpr const char* name = "TensorArrayClose";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StridedSliceAssign
{
    static constexpr const char* name = "StridedSliceAssign";
    
    enum class Argument
    {
        ref,
        begin,
        end,
        strides,
        value,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"end", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index,
        begin_mask,
        end_mask,
        ellipsis_mask,
        new_axis_mask,
        shrink_axis_mask
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"begin_mask", AttributeType::Int},
        AttributeDesc{"end_mask", AttributeType::Int},
        AttributeDesc{"ellipsis_mask", AttributeType::Int},
        AttributeDesc{"new_axis_mask", AttributeType::Int},
        AttributeDesc{"shrink_axis_mask", AttributeType::Int}
    };
};

struct Min
{
    static constexpr const char* name = "Min";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct UnwrapDatasetVariant
{
    static constexpr const char* name = "UnwrapDatasetVariant";
    
    enum class Argument
    {
        input_handle,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct InfeedDequeueTuple
{
    static constexpr const char* name = "InfeedDequeueTuple";
    
    enum class Argument
    {
        outputs
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes,
        shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape}
    };
};

struct StackPop
{
    static constexpr const char* name = "StackPop";
    
    enum class Argument
    {
        handle,
        elem
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"elem", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        elem_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"elem_type", AttributeType::Type}
    };
};

struct CudnnRNNParamsToCanonicalV2
{
    static constexpr const char* name = "CudnnRNNParamsToCanonicalV2";
    
    enum class Argument
    {
        num_layers,
        num_units,
        input_size,
        params,
        weights,
        biases
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"num_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_units", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params_weights"},
        ArgumentDesc{"biases", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params_biases"}
    };

    enum class Attribute
    {
        T,
        num_params_weights,
        num_params_biases,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        num_proj
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_params_weights", AttributeType::Int},
        AttributeDesc{"num_params_biases", AttributeType::Int},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"num_proj", AttributeType::Int}
    };
};

struct ParallelConcat
{
    static constexpr const char* name = "ParallelConcat";
    
    enum class Argument
    {
        values,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        shape
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct Attr
{
    static constexpr const char* name = "Attr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Int}
    };
};

struct FusedBatchNormV2
{
    static constexpr const char* name = "FusedBatchNormV2";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        exponential_avg_factor,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct GatherV2
{
    static constexpr const char* name = "GatherV2";
    
    enum class Argument
    {
        params,
        indices,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        batch_dims,
        Tparams,
        Tindices,
        Taxis
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"batch_dims", AttributeType::Int},
        AttributeDesc{"Tparams", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Taxis", AttributeType::Type}
    };
};

struct AttrFloat
{
    static constexpr const char* name = "AttrFloat";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Float}
    };
};

struct _ArrayToList
{
    static constexpr const char* name = "_ArrayToList";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "out_types"}
    };

    enum class Attribute
    {
        T,
        N,
        out_types
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"out_types", AttributeType::ListType}
    };
};

struct UniqueDataset
{
    static constexpr const char* name = "UniqueDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ApplyRMSProp
{
    static constexpr const char* name = "ApplyRMSProp";
    
    enum class Argument
    {
        var,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct BesselY0
{
    static constexpr const char* name = "BesselY0";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AttrBool
{
    static constexpr const char* name = "AttrBool";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Bool}
    };
};

struct CreateSummaryFileWriter
{
    static constexpr const char* name = "CreateSummaryFileWriter";
    
    enum class Argument
    {
        writer,
        logdir,
        max_queue,
        flush_millis,
        filename_suffix
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"logdir", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_queue", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flush_millis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename_suffix", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StageClear
{
    static constexpr const char* name = "StageClear";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Asinh
{
    static constexpr const char* name = "Asinh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ParseExampleV2
{
    static constexpr const char* name = "ParseExampleV2";
    
    enum class Argument
    {
        serialized,
        names,
        sparse_keys,
        dense_keys,
        ragged_keys,
        dense_defaults,
        sparse_indices,
        sparse_values,
        sparse_shapes,
        dense_values,
        ragged_values,
        ragged_row_splits
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ragged_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse"},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse"},
        ArgumentDesc{"dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"ragged_values", ArgumentDesc::TensorCount::SequenceAttrList, "ragged_value_types"},
        ArgumentDesc{"ragged_row_splits", ArgumentDesc::TensorCount::SequenceAttrList, "ragged_split_types"}
    };

    enum class Attribute
    {
        Tdense,
        num_sparse,
        sparse_types,
        ragged_value_types,
        ragged_split_types,
        dense_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"num_sparse", AttributeType::Int},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"ragged_value_types", AttributeType::ListType},
        AttributeDesc{"ragged_split_types", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape}
    };
};

struct MapPeek
{
    static constexpr const char* name = "MapPeek";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct AttrBoolList
{
    static constexpr const char* name = "AttrBoolList";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListBool}
    };
};

struct TensorScatterMin
{
    static constexpr const char* name = "TensorScatterMin";
    
    enum class Argument
    {
        tensor,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct AttrMin
{
    static constexpr const char* name = "AttrMin";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Int}
    };
};

struct DebugIdentity
{
    static constexpr const char* name = "DebugIdentity";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        device_name,
        tensor_name,
        debug_urls,
        gated_grpc
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"device_name", AttributeType::String},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"debug_urls", AttributeType::ListString},
        AttributeDesc{"gated_grpc", AttributeType::Bool}
    };
};

struct ApplyAdagradDA
{
    static constexpr const char* name = "ApplyAdagradDA";
    
    enum class Argument
    {
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step,
        out
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_squared_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"global_step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct AttrListMin
{
    static constexpr const char* name = "AttrListMin";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListInt}
    };
};

struct TensorListPushBack
{
    static constexpr const char* name = "TensorListPushBack";
    
    enum class Argument
    {
        input_handle,
        tensor,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct ResourceAccumulatorApplyGradient
{
    static constexpr const char* name = "ResourceAccumulatorApplyGradient";
    
    enum class Argument
    {
        handle,
        local_step,
        gradient
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"local_step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct AttrEnum
{
    static constexpr const char* name = "AttrEnum";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::String}
    };
};

struct WindowDataset
{
    static constexpr const char* name = "WindowDataset";
    
    enum class Argument
    {
        input_dataset,
        size,
        shift,
        stride,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shift", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stride", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct InitializeTableFromDataset
{
    static constexpr const char* name = "InitializeTableFromDataset";
    
    enum class Argument
    {
        table_handle,
        dataset
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseSegmentMean
{
    static constexpr const char* name = "SparseSegmentMean";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct ResourceApplyAddSign
{
    static constexpr const char* name = "ResourceApplyAddSign";
    
    enum class Argument
    {
        var,
        m,
        lr,
        alpha,
        sign_decay,
        beta,
        grad
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sign_decay", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct AttrEnumList
{
    static constexpr const char* name = "AttrEnumList";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListString}
    };
};

struct EncodeWav
{
    static constexpr const char* name = "EncodeWav";
    
    enum class Argument
    {
        audio,
        sample_rate,
        contents
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"audio", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample_rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AttrShape
{
    static constexpr const char* name = "AttrShape";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Shape}
    };
};

struct ArgMax
{
    static constexpr const char* name = "ArgMax";
    
    enum class Argument
    {
        input,
        dimension,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dimension", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        output_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct AttrShapeList
{
    static constexpr const char* name = "AttrShapeList";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListShape}
    };
};

struct ParallelMapDataset
{
    static constexpr const char* name = "ParallelMapDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        num_parallel_calls,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        use_inter_op_parallelism,
        sloppy,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_inter_op_parallelism", AttributeType::Bool},
        AttributeDesc{"sloppy", AttributeType::Bool},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct QueueClose
{
    static constexpr const char* name = "QueueClose";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        cancel_pending_enqueues
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"cancel_pending_enqueues", AttributeType::Bool}
    };
};

struct TensorListPopBack
{
    static constexpr const char* name = "TensorListPopBack";
    
    enum class Argument
    {
        input_handle,
        element_shape,
        output_handle,
        tensor
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct AttrPartialShape
{
    static constexpr const char* name = "AttrPartialShape";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::Shape}
    };
};

struct LeftShift
{
    static constexpr const char* name = "LeftShift";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DecodeImage
{
    static constexpr const char* name = "DecodeImage";
    
    enum class Argument
    {
        contents,
        image
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        channels,
        dtype,
        expand_animations
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"channels", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"expand_animations", AttributeType::Bool}
    };
};

struct _MklSquaredDifference
{
    static constexpr const char* name = "_MklSquaredDifference";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AttrPartialShapeList
{
    static constexpr const char* name = "AttrPartialShapeList";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListShape}
    };
};

struct BiasAdd
{
    static constexpr const char* name = "BiasAdd";
    
    enum class Argument
    {
        value,
        bias,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        data_format
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct AttrDefault
{
    static constexpr const char* name = "AttrDefault";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::String}
    };
};

struct ShardedFilespec
{
    static constexpr const char* name = "ShardedFilespec";
    
    enum class Argument
    {
        basename,
        num_shards,
        filename
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"basename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_shards", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AccumulatorApplyGradient
{
    static constexpr const char* name = "AccumulatorApplyGradient";
    
    enum class Argument
    {
        handle,
        local_step,
        gradient
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"local_step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct AttrListDefault
{
    static constexpr const char* name = "AttrListDefault";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListInt}
    };
};

struct BlockLSTMGradV2
{
    static constexpr const char* name = "BlockLSTMGradV2";
    
    enum class Argument
    {
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        x_grad,
        cs_prev_grad,
        h_prev_grad,
        w_grad,
        wci_grad,
        wcf_grad,
        wco_grad,
        b_grad
    };

    static constexpr uint32_t input_arg_count = 18;
    static constexpr uint32_t output_arg_count = 8;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seq_len_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct GuaranteeConst
{
    static constexpr const char* name = "GuaranteeConst";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MapIncompleteSize
{
    static constexpr const char* name = "MapIncompleteSize";
    
    enum class Argument
    {
        size
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct XlaRecv
{
    static constexpr const char* name = "XlaRecv";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        tensor_name,
        shape
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct Sum
{
    static constexpr const char* name = "Sum";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct AttrEmptyListDefault
{
    static constexpr const char* name = "AttrEmptyListDefault";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"a", AttributeType::ListFloat}
    };
};

struct ModelDataset
{
    static constexpr const char* name = "ModelDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        algorithm,
        cpu_budget,
        ram_budget,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"algorithm", AttributeType::Int},
        AttributeDesc{"cpu_budget", AttributeType::Int},
        AttributeDesc{"ram_budget", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct CollectiveGatherV2
{
    static constexpr const char* name = "CollectiveGatherV2";
    
    enum class Argument
    {
        input,
        group_size,
        group_key,
        instance_key,
        ordering_token,
        data
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"instance_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ordering_token", ArgumentDesc::TensorCount::SequenceAttrInt, "Nordering_token"},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        communication_hint,
        timeout_seconds,
        Nordering_token
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float},
        AttributeDesc{"Nordering_token", AttributeType::Int}
    };
};

struct ReservedAttr
{
    static constexpr const char* name = "ReservedAttr";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        range
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"range", AttributeType::Int}
    };
};

struct AttrTypeDefault
{
    static constexpr const char* name = "AttrTypeDefault";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Sqrt
{
    static constexpr const char* name = "Sqrt";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AttrListTypeDefault
{
    static constexpr const char* name = "AttrListTypeDefault";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct TensorArrayCloseV3
{
    static constexpr const char* name = "TensorArrayCloseV3";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RealDiv
{
    static constexpr const char* name = "RealDiv";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct NIntsIn
{
    static constexpr const char* name = "NIntsIn";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct RegisterDataset
{
    static constexpr const char* name = "RegisterDataset";
    
    enum class Argument
    {
        dataset,
        address,
        protocol,
        dataset_id
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"address", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"protocol", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dataset_id", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        external_state_policy,
        element_spec
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"external_state_policy", AttributeType::Int},
        AttributeDesc{"element_spec", AttributeType::String}
    };
};

struct Ceil
{
    static constexpr const char* name = "Ceil";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct EnqueueTPUEmbeddingSparseTensorBatch
{
    static constexpr const char* name = "EnqueueTPUEmbeddingSparseTensorBatch";
    
    enum class Argument
    {
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sample_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"embedding_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"aggregation_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mode_override", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        T3,
        N,
        device_ordinal,
        combiners,
        table_ids,
        max_sequence_lengths,
        num_features
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"T3", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"device_ordinal", AttributeType::Int},
        AttributeDesc{"combiners", AttributeType::ListString},
        AttributeDesc{"table_ids", AttributeType::ListInt},
        AttributeDesc{"max_sequence_lengths", AttributeType::ListInt},
        AttributeDesc{"num_features", AttributeType::ListInt}
    };
};

struct ResourceScatterAdd
{
    static constexpr const char* name = "ResourceScatterAdd";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct ReverseSequence
{
    static constexpr const char* name = "ReverseSequence";
    
    enum class Argument
    {
        input,
        seq_lengths,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seq_lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seq_dim,
        batch_dim,
        T,
        Tlen
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seq_dim", AttributeType::Int},
        AttributeDesc{"batch_dim", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tlen", AttributeType::Type}
    };
};

struct NPolymorphicIn
{
    static constexpr const char* name = "NPolymorphicIn";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct NInPolymorphicTwice
{
    static constexpr const char* name = "NInPolymorphicTwice";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct TensorArrayGradV3
{
    static constexpr const char* name = "TensorArrayGradV3";
    
    enum class Argument
    {
        handle,
        flow_in,
        grad_handle,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        source
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"source", AttributeType::String}
    };
};

struct _MklNativeFusedDepthwiseConv2dNative
{
    static constexpr const char* name = "_MklNativeFusedDepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct _MklConcatV2
{
    static constexpr const char* name = "_MklConcatV2";
    
    enum class Argument
    {
        values,
        axis,
        mkl_values,
        mkl_axis,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mkl_axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct Conv2D
{
    static constexpr const char* name = "Conv2D";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct NInTwoTypeVariables
{
    static constexpr const char* name = "NInTwoTypeVariables";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        S,
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct BatchSvd
{
    static constexpr const char* name = "BatchSvd";
    
    enum class Argument
    {
        input,
        s,
        u,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"s", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"u", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compute_uv,
        full_matrices,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"compute_uv", AttributeType::Bool},
        AttributeDesc{"full_matrices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct IsNan
{
    static constexpr const char* name = "IsNan";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InPolymorphicTwice
{
    static constexpr const char* name = "InPolymorphicTwice";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "M"}
    };

    enum class Attribute
    {
        T,
        N,
        M
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"M", AttributeType::Int}
    };
};

struct NIntsOut
{
    static constexpr const char* name = "NIntsOut";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct SparseSliceGrad
{
    static constexpr const char* name = "SparseSliceGrad";
    
    enum class Argument
    {
        backprop_val_grad,
        input_indices,
        input_start,
        output_indices,
        val_grad
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"backprop_val_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"val_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Reshape
{
    static constexpr const char* name = "Reshape";
    
    enum class Argument
    {
        tensor,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct StringStrip
{
    static constexpr const char* name = "StringStrip";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ParallelInterleaveDatasetV3
{
    static constexpr const char* name = "ParallelInterleaveDatasetV3";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        deterministic,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"deterministic", AttributeType::String},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Roll
{
    static constexpr const char* name = "Roll";
    
    enum class Argument
    {
        input,
        shift,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shift", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshift,
        Taxis
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshift", AttributeType::Type},
        AttributeDesc{"Taxis", AttributeType::Type}
    };
};

struct MapAndBatchDataset
{
    static constexpr const char* name = "MapAndBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct ListDiff
{
    static constexpr const char* name = "ListDiff";
    
    enum class Argument
    {
        x,
        y,
        out,
        idx
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"idx", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_idx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_idx", AttributeType::Type}
    };
};

struct NIntsOutDefault
{
    static constexpr const char* name = "NIntsOutDefault";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct FIFOQueue
{
    static constexpr const char* name = "FIFOQueue";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Snapshot
{
    static constexpr const char* name = "Snapshot";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct NPolymorphicOut
{
    static constexpr const char* name = "NPolymorphicOut";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct RaggedTensorToTensor
{
    static constexpr const char* name = "RaggedTensorToTensor";
    
    enum class Argument
    {
        shape,
        values,
        default_value,
        row_partition_tensors,
        result
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"default_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_partition_tensors", ArgumentDesc::TensorCount::SequenceAttrInt, "num_row_partition_tensors"},
        ArgumentDesc{"result", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindex,
        Tshape,
        num_row_partition_tensors,
        row_partition_types
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindex", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type},
        AttributeDesc{"num_row_partition_tensors", AttributeType::Int},
        AttributeDesc{"row_partition_types", AttributeType::ListString}
    };
};

struct MatrixBandPart
{
    static constexpr const char* name = "MatrixBandPart";
    
    enum class Argument
    {
        input,
        num_lower,
        num_upper,
        band
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_lower", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_upper", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"band", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindex", AttributeType::Type}
    };
};

struct NPolymorphicOutDefault
{
    static constexpr const char* name = "NPolymorphicOutDefault";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct QuantizedResizeBilinear
{
    static constexpr const char* name = "QuantizedResizeBilinear";
    
    enum class Argument
    {
        images,
        size,
        min,
        max,
        resized_images,
        out_min,
        out_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct NPolymorphicRestrictOut
{
    static constexpr const char* name = "NPolymorphicRestrictOut";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct DatasetToTFRecord
{
    static constexpr const char* name = "DatasetToTFRecord";
    
    enum class Argument
    {
        input_dataset,
        filename,
        compression_type
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RefIn
{
    static constexpr const char* name = "RefIn";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TwoRefsIn
{
    static constexpr const char* name = "TwoRefsIn";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ShuffleDatasetV2
{
    static constexpr const char* name = "ShuffleDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        seed_generator,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed_generator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TensorArrayGatherV2
{
    static constexpr const char* name = "TensorArrayGatherV2";
    
    enum class Argument
    {
        handle,
        indices,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct BoostedTreesCalculateBestFeatureSplitV2
{
    static constexpr const char* name = "BoostedTreesCalculateBestFeatureSplitV2";
    
    enum class Argument
    {
        node_id_range,
        stats_summaries_list,
        split_types,
        candidate_feature_ids,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        node_ids,
        gains,
        feature_ids,
        feature_dimensions,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_with_default_directions
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 8;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_id_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summaries_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"split_types", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"candidate_feature_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_complexity", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_node_weight", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gains", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_dimensions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thresholds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"left_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"right_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"split_with_default_directions", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_features,
        logits_dimension
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int},
        AttributeDesc{"logits_dimension", AttributeType::Int}
    };
};

struct RefOut
{
    static constexpr const char* name = "RefOut";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LearnedUnigramCandidateSampler
{
    static constexpr const char* name = "LearnedUnigramCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        range_max,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"range_max", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct SimpleStruct
{
    static constexpr const char* name = "SimpleStruct";
    
    enum class Argument
    {
        a
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "n_a"}
    };

    enum class Attribute
    {
        n_a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"n_a", AttributeType::Int}
    };
};

struct SparseApplyRMSProp
{
    static constexpr const char* name = "SparseApplyRMSProp";
    
    enum class Argument
    {
        var,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ConcatenateDataset
{
    static constexpr const char* name = "ConcatenateDataset";
    
    enum class Argument
    {
        input_dataset,
        another_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"another_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ShardDataset
{
    static constexpr const char* name = "ShardDataset";
    
    enum class Argument
    {
        input_dataset,
        num_shards,
        index,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_shards", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        require_non_empty,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"require_non_empty", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExtractJpegShape
{
    static constexpr const char* name = "ExtractJpegShape";
    
    enum class Argument
    {
        contents,
        image_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct MixedStruct
{
    static constexpr const char* name = "MixedStruct";
    
    enum class Argument
    {
        a,
        b
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "n_a"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        n_a
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"n_a", AttributeType::Int}
    };
};

struct IsFinite
{
    static constexpr const char* name = "IsFinite";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResourceAccumulatorSetGlobalStep
{
    static constexpr const char* name = "ResourceAccumulatorSetGlobalStep";
    
    enum class Argument
    {
        handle,
        new_global_step
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"new_global_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ComplexStruct
{
    static constexpr const char* name = "ComplexStruct";
    
    enum class Argument
    {
        a,
        b,
        c
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::SequenceAttrInt, "n_a"},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::SequenceAttrInt, "n_b"},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::SequenceAttrList, "t_c"}
    };

    enum class Attribute
    {
        n_a,
        n_b,
        t_c
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"n_a", AttributeType::Int},
        AttributeDesc{"n_b", AttributeType::Int},
        AttributeDesc{"t_c", AttributeType::ListType}
    };
};

struct DevicePlacementOp
{
    static constexpr const char* name = "DevicePlacementOp";
    
    enum class Argument
    {
        device
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"device", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QueueSizeV2
{
    static constexpr const char* name = "QueueSizeV2";
    
    enum class Argument
    {
        handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DtypeWithDefaultOp
{
    static constexpr const char* name = "DtypeWithDefaultOp";
    
    enum class Argument
    {
        in,
        dtype
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dtype", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ToBool
{
    static constexpr const char* name = "ToBool";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct IsTensorFloat32Enabled
{
    static constexpr const char* name = "IsTensorFloat32Enabled";
    
    enum class Argument
    {
        enabled
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"enabled", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _XlaAotOnlyVarHandleOp
{
    static constexpr const char* name = "_XlaAotOnlyVarHandleOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct FakeQuantWithMinMaxVars
{
    static constexpr const char* name = "FakeQuantWithMinMaxVars";
    
    enum class Argument
    {
        inputs,
        min,
        max,
        outputs
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct XlaLaunch
{
    static constexpr const char* name = "XlaLaunch";
    
    enum class Argument
    {
        constants,
        args,
        resources,
        results
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"constants", ArgumentDesc::TensorCount::SequenceAttrList, "Tconstants"},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Targs"},
        ArgumentDesc{"resources", ArgumentDesc::TensorCount::SequenceAttrInt, "Nresources"},
        ArgumentDesc{"results", ArgumentDesc::TensorCount::SequenceAttrList, "Tresults"}
    };

    enum class Attribute
    {
        Tconstants,
        Targs,
        Nresources,
        Tresults,
        function
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Tconstants", AttributeType::ListType},
        AttributeDesc{"Targs", AttributeType::ListType},
        AttributeDesc{"Nresources", AttributeType::Int},
        AttributeDesc{"Tresults", AttributeType::ListType},
        AttributeDesc{"function", AttributeType::Func}
    };
};

struct XlaClusterOutput
{
    static constexpr const char* name = "XlaClusterOutput";
    
    enum class Argument
    {
        input,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchNormWithGlobalNormalization
{
    static constexpr const char* name = "BatchNormWithGlobalNormalization";
    
    enum class Argument
    {
        t,
        m,
        v,
        beta,
        gamma,
        result
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gamma", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        variance_epsilon,
        scale_after_normalization
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"variance_epsilon", AttributeType::Float},
        AttributeDesc{"scale_after_normalization", AttributeType::Bool}
    };
};

struct SparseApplyFtrlV2
{
    static constexpr const char* name = "SparseApplyFtrlV2";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        out
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_shrinkage", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct Cumsum
{
    static constexpr const char* name = "Cumsum";
    
    enum class Argument
    {
        x,
        axis,
        out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        exclusive,
        reverse,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"exclusive", AttributeType::Bool},
        AttributeDesc{"reverse", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct _XlaCompile
{
    static constexpr const char* name = "_XlaCompile";
    
    enum class Argument
    {
        constants,
        args,
        resources,
        key,
        compilation_successful
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"constants", ArgumentDesc::TensorCount::SequenceAttrList, "Tconstants"},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Targs"},
        ArgumentDesc{"resources", ArgumentDesc::TensorCount::SequenceAttrInt, "Nresources"},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compilation_successful", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tconstants,
        must_compile,
        Targs,
        Nresources,
        function
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Tconstants", AttributeType::ListType},
        AttributeDesc{"must_compile", AttributeType::Bool},
        AttributeDesc{"Targs", AttributeType::ListType},
        AttributeDesc{"Nresources", AttributeType::Int},
        AttributeDesc{"function", AttributeType::Func}
    };
};

struct _XlaRun
{
    static constexpr const char* name = "_XlaRun";
    
    enum class Argument
    {
        args,
        key,
        results
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Targs"},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"results", ArgumentDesc::TensorCount::SequenceAttrList, "Tresults"}
    };

    enum class Attribute
    {
        Targs,
        Tresults
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Targs", AttributeType::ListType},
        AttributeDesc{"Tresults", AttributeType::ListType}
    };
};

struct RandomShuffle
{
    static constexpr const char* name = "RandomShuffle";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _XlaMerge
{
    static constexpr const char* name = "_XlaMerge";
    
    enum class Argument
    {
        partitioned_call,
        xla_run,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"partitioned_call", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"xla_run", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AssertCardinalityDataset
{
    static constexpr const char* name = "AssertCardinalityDataset";
    
    enum class Argument
    {
        input_dataset,
        cardinality,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cardinality", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Requantize
{
    static constexpr const char* name = "Requantize";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"requested_output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"requested_output_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct BatchSelfAdjointEig
{
    static constexpr const char* name = "BatchSelfAdjointEig";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Fact
{
    static constexpr const char* name = "Fact";
    
    enum class Argument
    {
        fact
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"fact", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RaggedCountSparseOutput
{
    static constexpr const char* name = "RaggedCountSparseOutput";
    
    enum class Argument
    {
        splits,
        values,
        weights,
        output_indices,
        output_values,
        output_dense_shape
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dense_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        minlength,
        maxlength,
        binary_output,
        output_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"minlength", AttributeType::Int},
        AttributeDesc{"maxlength", AttributeType::Int},
        AttributeDesc{"binary_output", AttributeType::Bool},
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct XlaVariadicReduce
{
    static constexpr const char* name = "XlaVariadicReduce";
    
    enum class Argument
    {
        input,
        init_value,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"init_value", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N,
        T,
        dimensions_to_reduce,
        reducer
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dimensions_to_reduce", AttributeType::ListInt},
        AttributeDesc{"reducer", AttributeType::Func}
    };
};

struct _DisconnectHostFromDistributedTPUSystem
{
    static constexpr const char* name = "_DisconnectHostFromDistributedTPUSystem";
    
    enum class Argument
    {
        number_of_tpu_chips
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"number_of_tpu_chips", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OrderedMapPeek
{
    static constexpr const char* name = "OrderedMapPeek";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Bitcast
{
    static constexpr const char* name = "Bitcast";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct LogUniformCandidateSampler
{
    static constexpr const char* name = "LogUniformCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        range_max,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"range_max", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct ReaderNumRecordsProducedV2
{
    static constexpr const char* name = "ReaderNumRecordsProducedV2";
    
    enum class Argument
    {
        reader_handle,
        records_produced
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"records_produced", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Lgamma
{
    static constexpr const char* name = "Lgamma";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CTCBeamSearchDecoder
{
    static constexpr const char* name = "CTCBeamSearchDecoder";
    
    enum class Argument
    {
        inputs,
        sequence_length,
        decoded_indices,
        decoded_values,
        decoded_shape,
        log_probability
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"decoded_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "top_paths"},
        ArgumentDesc{"decoded_values", ArgumentDesc::TensorCount::SequenceAttrInt, "top_paths"},
        ArgumentDesc{"decoded_shape", ArgumentDesc::TensorCount::SequenceAttrInt, "top_paths"},
        ArgumentDesc{"log_probability", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        beam_width,
        top_paths,
        merge_repeated,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"beam_width", AttributeType::Int},
        AttributeDesc{"top_paths", AttributeType::Int},
        AttributeDesc{"merge_repeated", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Pack
{
    static constexpr const char* name = "Pack";
    
    enum class Argument
    {
        values,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        axis
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct TPUReplicateMetadata
{
    static constexpr const char* name = "TPUReplicateMetadata";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        num_replicas,
        num_cores_per_replica,
        topology,
        use_tpu,
        device_assignment,
        computation_shape,
        host_compute_core,
        padding_map,
        step_marker_location,
        allow_soft_placement,
        use_spmd_for_xla_partitioning
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"num_replicas", AttributeType::Int},
        AttributeDesc{"num_cores_per_replica", AttributeType::Int},
        AttributeDesc{"topology", AttributeType::String},
        AttributeDesc{"use_tpu", AttributeType::Bool},
        AttributeDesc{"device_assignment", AttributeType::ListInt},
        AttributeDesc{"computation_shape", AttributeType::ListInt},
        AttributeDesc{"host_compute_core", AttributeType::ListString},
        AttributeDesc{"padding_map", AttributeType::ListString},
        AttributeDesc{"step_marker_location", AttributeType::String},
        AttributeDesc{"allow_soft_placement", AttributeType::Bool},
        AttributeDesc{"use_spmd_for_xla_partitioning", AttributeType::Bool}
    };
};

struct QuantizedMaxPool
{
    static constexpr const char* name = "QuantizedMaxPool";
    
    enum class Argument
    {
        input,
        min_input,
        max_input,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct DeepCopy
{
    static constexpr const char* name = "DeepCopy";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklMaxPoolGrad
{
    static constexpr const char* name = "_MklMaxPoolGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        workspace,
        mkl_orig_input,
        mkl_orig_output,
        mkl_grad,
        mkl_workspace,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        workspace_enabled,
        padding,
        data_format,
        explicit_paddings
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"workspace_enabled", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt}
    };
};

struct RefNextIteration
{
    static constexpr const char* name = "RefNextIteration";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InplaceUpdate
{
    static constexpr const char* name = "InplaceUpdate";
    
    enum class Argument
    {
        x,
        i,
        v,
        y
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RefIdentity
{
    static constexpr const char* name = "RefIdentity";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InplaceAdd
{
    static constexpr const char* name = "InplaceAdd";
    
    enum class Argument
    {
        x,
        i,
        v,
        y
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SamplingDataset
{
    static constexpr const char* name = "SamplingDataset";
    
    enum class Argument
    {
        input_dataset,
        rate,
        seed,
        seed2,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct FixedLengthRecordDatasetV2
{
    static constexpr const char* name = "FixedLengthRecordDatasetV2";
    
    enum class Argument
    {
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        compression_type,
        handle
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"header_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"footer_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CudnnRNNBackpropV2
{
    static constexpr const char* name = "CudnnRNNBackpropV2";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        input_backprop,
        input_h_backprop,
        input_c_backprop,
        params_backprop
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"host_reserved", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct _NcclBroadcastRecv
{
    static constexpr const char* name = "_NcclBroadcastRecv";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_devices,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct InplaceSub
{
    static constexpr const char* name = "InplaceSub";
    
    enum class Argument
    {
        x,
        i,
        v,
        y
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklPadWithFusedConv2D
{
    static constexpr const char* name = "_MklPadWithFusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        paddings,
        mkl_input,
        mkl_filter,
        mkl_args,
        mkl_paddings,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"mkl_paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations,
        fused_ops,
        Tpaddings,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct AvgPool3DGrad
{
    static constexpr const char* name = "AvgPool3DGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StridedSlice
{
    static constexpr const char* name = "StridedSlice";
    
    enum class Argument
    {
        input,
        begin,
        end,
        strides,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"end", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index,
        begin_mask,
        end_mask,
        ellipsis_mask,
        new_axis_mask,
        shrink_axis_mask
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"begin_mask", AttributeType::Int},
        AttributeDesc{"end_mask", AttributeType::Int},
        AttributeDesc{"ellipsis_mask", AttributeType::Int},
        AttributeDesc{"new_axis_mask", AttributeType::Int},
        AttributeDesc{"shrink_axis_mask", AttributeType::Int}
    };
};

struct Empty
{
    static constexpr const char* name = "Empty";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        init
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"init", AttributeType::Bool}
    };
};

struct ReaderReadV2
{
    static constexpr const char* name = "ReaderReadV2";
    
    enum class Argument
    {
        reader_handle,
        queue_handle,
        key,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"queue_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OrderedMapUnstageNoKey
{
    static constexpr const char* name = "OrderedMapUnstageNoKey";
    
    enum class Argument
    {
        indices,
        key,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Unpack
{
    static constexpr const char* name = "Unpack";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "num"}
    };

    enum class Attribute
    {
        num,
        T,
        axis
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct RiscSort
{
    static constexpr const char* name = "RiscSort";
    
    enum class Argument
    {
        input,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Index,
        T,
        direction
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"direction", AttributeType::String}
    };
};

struct UnravelIndex
{
    static constexpr const char* name = "UnravelIndex";
    
    enum class Argument
    {
        indices,
        dims,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dims", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct BroadcastTo
{
    static constexpr const char* name = "BroadcastTo";
    
    enum class Argument
    {
        input,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct BytesProducedStatsDataset
{
    static constexpr const char* name = "BytesProducedStatsDataset";
    
    enum class Argument
    {
        input_dataset,
        tag,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalStatsAggregatorSummary
{
    static constexpr const char* name = "ExperimentalStatsAggregatorSummary";
    
    enum class Argument
    {
        iterator,
        summary
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QuantizeAndDequantizeV4
{
    static constexpr const char* name = "QuantizeAndDequantizeV4";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        signed_input,
        num_bits,
        range_given,
        T,
        round_mode,
        narrow_range,
        axis
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"signed_input", AttributeType::Bool},
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"range_given", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"round_mode", AttributeType::String},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct RetrieveTPUEmbeddingFrequencyEstimatorParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingFrequencyEstimatorParameters";
    
    enum class Argument
    {
        parameters,
        last_hit_step
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"last_hit_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct Concat
{
    static constexpr const char* name = "Concat";
    
    enum class Argument
    {
        concat_dim,
        values,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"concat_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TFRecordReader
{
    static constexpr const char* name = "TFRecordReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        compression_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"compression_type", AttributeType::String}
    };
};

struct _FusedDepthwiseConv2dNative
{
    static constexpr const char* name = "_FusedDepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        padding,
        data_format,
        dilations,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct ConcatV2
{
    static constexpr const char* name = "ConcatV2";
    
    enum class Argument
    {
        values,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct ConcatOffset
{
    static constexpr const char* name = "ConcatOffset";
    
    enum class Argument
    {
        concat_dim,
        shape,
        offset
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"concat_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct _MklMatMul
{
    static constexpr const char* name = "_MklMatMul";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        transpose_a,
        transpose_b,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CumulativeLogsumexp
{
    static constexpr const char* name = "CumulativeLogsumexp";
    
    enum class Argument
    {
        x,
        axis,
        out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        exclusive,
        reverse,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"exclusive", AttributeType::Bool},
        AttributeDesc{"reverse", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct MaxPool
{
    static constexpr const char* name = "MaxPool";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding,
        explicit_paddings,
        data_format
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct TensorArraySplit
{
    static constexpr const char* name = "TensorArraySplit";
    
    enum class Argument
    {
        handle,
        value,
        lengths,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchSelfAdjointEigV2
{
    static constexpr const char* name = "BatchSelfAdjointEigV2";
    
    enum class Argument
    {
        input,
        e,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compute_v,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"compute_v", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixDeterminant
{
    static constexpr const char* name = "MatrixDeterminant";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct PrelinearizeTuple
{
    static constexpr const char* name = "PrelinearizeTuple";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtypes,
        shapes,
        layouts
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"layouts", AttributeType::ListInt}
    };
};

struct SplitV
{
    static constexpr const char* name = "SplitV";
    
    enum class Argument
    {
        value,
        size_splits,
        split_dim,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"split_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "num_split"}
    };

    enum class Attribute
    {
        num_split,
        T,
        Tlen
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num_split", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tlen", AttributeType::Type}
    };
};

struct ResizeNearestNeighborGrad
{
    static constexpr const char* name = "ResizeNearestNeighborGrad";
    
    enum class Argument
    {
        grads,
        size,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct EmptyTensorList
{
    static constexpr const char* name = "EmptyTensorList";
    
    enum class Argument
    {
        element_shape,
        max_num_elements,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_num_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct Const
{
    static constexpr const char* name = "Const";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        value,
        dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"value", AttributeType::Tensor},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct HostConst
{
    static constexpr const char* name = "HostConst";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        value,
        dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"value", AttributeType::Tensor},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct RiscSqueeze
{
    static constexpr const char* name = "RiscSqueeze";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        squeeze_dims
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"squeeze_dims", AttributeType::ListInt}
    };
};

struct QuantizedMatMulWithBiasAndRelu
{
    static constexpr const char* name = "QuantizedMatMulWithBiasAndRelu";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String}
    };
};

struct BoostedTreesQuantileStreamResourceAddSummaries
{
    static constexpr const char* name = "BoostedTreesQuantileStreamResourceAddSummaries";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        summaries
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct _EagerConst
{
    static constexpr const char* name = "_EagerConst";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ImmutableConst
{
    static constexpr const char* name = "ImmutableConst";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        memory_region_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"memory_region_name", AttributeType::String}
    };
};

struct ZerosLike
{
    static constexpr const char* name = "ZerosLike";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OnesLike
{
    static constexpr const char* name = "OnesLike";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct While
{
    static constexpr const char* name = "While";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        cond,
        body,
        output_shapes,
        parallel_iterations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"cond", AttributeType::Func},
        AttributeDesc{"body", AttributeType::Func},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"parallel_iterations", AttributeType::Int}
    };
};

struct AddN
{
    static constexpr const char* name = "AddN";
    
    enum class Argument
    {
        inputs,
        sum
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"sum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Rint
{
    static constexpr const char* name = "Rint";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Diag
{
    static constexpr const char* name = "Diag";
    
    enum class Argument
    {
        diagonal,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchMatrixInverse
{
    static constexpr const char* name = "BatchMatrixInverse";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RightShift
{
    static constexpr const char* name = "RightShift";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklConv2DBackpropFilterWithBias
{
    static constexpr const char* name = "_MklConv2DBackpropFilterWithBias";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        mkl_input,
        mkl_filter_size,
        mkl_out_backprop,
        output,
        bias_grad,
        mkl_output,
        mkl_bias_grad
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_bias_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct Rank
{
    static constexpr const char* name = "Rank";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DiagPart
{
    static constexpr const char* name = "DiagPart";
    
    enum class Argument
    {
        input,
        diagonal
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixDiag
{
    static constexpr const char* name = "MatrixDiag";
    
    enum class Argument
    {
        diagonal,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResizeNearestNeighbor
{
    static constexpr const char* name = "ResizeNearestNeighbor";
    
    enum class Argument
    {
        images,
        size,
        resized_images
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct AnonymousIterator
{
    static constexpr const char* name = "AnonymousIterator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct MatrixDiagV3
{
    static constexpr const char* name = "MatrixDiagV3";
    
    enum class Argument
    {
        diagonal,
        k,
        num_rows,
        num_cols,
        padding_value,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_rows", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align", AttributeType::String}
    };
};

struct SparseCross
{
    static constexpr const char* name = "SparseCross";
    
    enum class Argument
    {
        indices,
        values,
        shapes,
        dense_inputs,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"dense_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dense_types"},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        hashed_output,
        num_buckets,
        hash_key,
        sparse_types,
        dense_types,
        out_type,
        internal_type
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"hashed_output", AttributeType::Bool},
        AttributeDesc{"num_buckets", AttributeType::Int},
        AttributeDesc{"hash_key", AttributeType::Int},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"dense_types", AttributeType::ListType},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"internal_type", AttributeType::Type}
    };
};

struct StackPush
{
    static constexpr const char* name = "StackPush";
    
    enum class Argument
    {
        handle,
        elem,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"elem", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        swap_memory
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"swap_memory", AttributeType::Bool}
    };
};

struct MatrixSetDiag
{
    static constexpr const char* name = "MatrixSetDiag";
    
    enum class Argument
    {
        input,
        diagonal,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseCrossV2
{
    static constexpr const char* name = "SparseCrossV2";
    
    enum class Argument
    {
        indices,
        values,
        shapes,
        dense_inputs,
        sep,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"dense_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dense_types"},
        ArgumentDesc{"sep", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        sparse_types,
        dense_types
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"dense_types", AttributeType::ListType}
    };
};

struct StackPushV2
{
    static constexpr const char* name = "StackPushV2";
    
    enum class Argument
    {
        handle,
        elem,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"elem", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        swap_memory
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"swap_memory", AttributeType::Bool}
    };
};

struct MatrixSetDiagV2
{
    static constexpr const char* name = "MatrixSetDiagV2";
    
    enum class Argument
    {
        input,
        diagonal,
        k,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BoostedTreesMakeQuantileSummaries
{
    static constexpr const char* name = "BoostedTreesMakeQuantileSummaries";
    
    enum class Argument
    {
        float_values,
        example_weights,
        epsilon,
        summaries
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"float_values", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"example_weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct ExperimentalParseExampleDataset
{
    static constexpr const char* name = "ExperimentalParseExampleDataset";
    
    enum class Argument
    {
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sparse_keys,
        dense_keys,
        sparse_types,
        Tdense,
        dense_shapes,
        output_types,
        output_shapes,
        sloppy
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"sparse_keys", AttributeType::ListString},
        AttributeDesc{"dense_keys", AttributeType::ListString},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"sloppy", AttributeType::Bool}
    };
};

struct _MklNativeConv3D
{
    static constexpr const char* name = "_MklNativeConv3D";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct MatrixSetDiagV3
{
    static constexpr const char* name = "MatrixSetDiagV3";
    
    enum class Argument
    {
        input,
        diagonal,
        k,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align", AttributeType::String}
    };
};

struct ResourceSparseApplyRMSProp
{
    static constexpr const char* name = "ResourceSparseApplyRMSProp";
    
    enum class Argument
    {
        var,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceAccumulatorTakeGradient
{
    static constexpr const char* name = "ResourceAccumulatorTakeGradient";
    
    enum class Argument
    {
        handle,
        num_required,
        average
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_required", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"average", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct SparseSegmentSqrtNGrad
{
    static constexpr const char* name = "SparseSegmentSqrtNGrad";
    
    enum class Argument
    {
        grad,
        indices,
        segment_ids,
        output_dim0,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dim0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct TPUPartitionedOutput
{
    static constexpr const char* name = "TPUPartitionedOutput";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "num_splits"}
    };

    enum class Attribute
    {
        T,
        num_splits,
        partition_dim
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_splits", AttributeType::Int},
        AttributeDesc{"partition_dim", AttributeType::Int}
    };
};

struct MatrixDiagPartV2
{
    static constexpr const char* name = "MatrixDiagPartV2";
    
    enum class Argument
    {
        input,
        k,
        padding_value,
        diagonal
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchMatrixDiag
{
    static constexpr const char* name = "BatchMatrixDiag";
    
    enum class Argument
    {
        diagonal,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixDiagPartV3
{
    static constexpr const char* name = "MatrixDiagPartV3";
    
    enum class Argument
    {
        input,
        k,
        padding_value,
        diagonal
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align", AttributeType::String}
    };
};

struct Reverse
{
    static constexpr const char* name = "Reverse";
    
    enum class Argument
    {
        tensor,
        dims,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dims", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ReverseV2
{
    static constexpr const char* name = "ReverseV2";
    
    enum class Argument
    {
        tensor,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _ParallelConcatStart
{
    static constexpr const char* name = "_ParallelConcatStart";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct TensorListSetItem
{
    static constexpr const char* name = "TensorListSetItem";
    
    enum class Argument
    {
        input_handle,
        index,
        item,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"item", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct Identity
{
    static constexpr const char* name = "Identity";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SnapshotDataset
{
    static constexpr const char* name = "SnapshotDataset";
    
    enum class Argument
    {
        input_dataset,
        path,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        compression,
        reader_path_prefix,
        writer_path_prefix,
        shard_size_bytes,
        pending_snapshot_expiry_seconds,
        num_reader_threads,
        reader_buffer_size,
        num_writer_threads,
        writer_buffer_size,
        shuffle_on_read,
        seed,
        seed2,
        mode,
        snapshot_name
    };

    static constexpr std::array<AttributeDesc, 16> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"reader_path_prefix", AttributeType::String},
        AttributeDesc{"writer_path_prefix", AttributeType::String},
        AttributeDesc{"shard_size_bytes", AttributeType::Int},
        AttributeDesc{"pending_snapshot_expiry_seconds", AttributeType::Int},
        AttributeDesc{"num_reader_threads", AttributeType::Int},
        AttributeDesc{"reader_buffer_size", AttributeType::Int},
        AttributeDesc{"num_writer_threads", AttributeType::Int},
        AttributeDesc{"writer_buffer_size", AttributeType::Int},
        AttributeDesc{"shuffle_on_read", AttributeType::Bool},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"snapshot_name", AttributeType::String}
    };
};

struct BlockLSTMGrad
{
    static constexpr const char* name = "BlockLSTMGrad";
    
    enum class Argument
    {
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        x_grad,
        cs_prev_grad,
        h_prev_grad,
        w_grad,
        wci_grad,
        wcf_grad,
        wco_grad,
        b_grad
    };

    static constexpr uint32_t input_arg_count = 18;
    static constexpr uint32_t output_arg_count = 8;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seq_len_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchMatrixDiagPart
{
    static constexpr const char* name = "BatchMatrixDiagPart";
    
    enum class Argument
    {
        input,
        diagonal
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _ParallelConcatUpdate
{
    static constexpr const char* name = "_ParallelConcatUpdate";
    
    enum class Argument
    {
        value,
        update,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        loc
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"loc", AttributeType::Int}
    };
};

struct CudnnRNNParamsToCanonical
{
    static constexpr const char* name = "CudnnRNNParamsToCanonical";
    
    enum class Argument
    {
        num_layers,
        num_units,
        input_size,
        params,
        weights,
        biases
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"num_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_units", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params"},
        ArgumentDesc{"biases", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params"}
    };

    enum class Attribute
    {
        T,
        num_params,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_params", AttributeType::Int},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct FusedBatchNorm
{
    static constexpr const char* name = "FusedBatchNorm";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        exponential_avg_factor,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct Gather
{
    static constexpr const char* name = "Gather";
    
    enum class Argument
    {
        params,
        indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        validate_indices,
        Tparams,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"Tparams", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct LoadTPUEmbeddingCenteredRMSPropParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingCenteredRMSPropParameters";
    
    enum class Argument
    {
        parameters,
        ms,
        mom,
        mg
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct GatherNd
{
    static constexpr const char* name = "GatherNd";
    
    enum class Argument
    {
        params,
        indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tparams,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tparams", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct TensorArraySplitV3
{
    static constexpr const char* name = "TensorArraySplitV3";
    
    enum class Argument
    {
        handle,
        value,
        lengths,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LookupTableImport
{
    static constexpr const char* name = "LookupTableImport";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct ResourceScatterDiv
{
    static constexpr const char* name = "ResourceScatterDiv";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct _MklIdentity
{
    static constexpr const char* name = "_MklIdentity";
    
    enum class Argument
    {
        input,
        mkl_input,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchMatrixSolveLs
{
    static constexpr const char* name = "BatchMatrixSolveLs";
    
    enum class Argument
    {
        matrix,
        rhs,
        l2_regularizer,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_regularizer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        fast
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"fast", AttributeType::Bool}
    };
};

struct IdentityN
{
    static constexpr const char* name = "IdentityN";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct LoadDataset
{
    static constexpr const char* name = "LoadDataset";
    
    enum class Argument
    {
        path,
        reader_func_other_args,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reader_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Treader_func_args"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        compression,
        reader_func,
        Treader_func_args
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"reader_func", AttributeType::Func},
        AttributeDesc{"Treader_func_args", AttributeType::ListType}
    };
};

struct DebugGradientIdentity
{
    static constexpr const char* name = "DebugGradientIdentity";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExpandDims
{
    static constexpr const char* name = "ExpandDims";
    
    enum class Argument
    {
        input,
        dim,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tdim
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tdim", AttributeType::Type}
    };
};

struct DebugGradientRefIdentity
{
    static constexpr const char* name = "DebugGradientRefIdentity";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct PlaceholderWithDefault
{
    static constexpr const char* name = "PlaceholderWithDefault";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct ApproximateEqual
{
    static constexpr const char* name = "ApproximateEqual";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tolerance
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tolerance", AttributeType::Float}
    };
};

struct AllCandidateSampler
{
    static constexpr const char* name = "AllCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct TensorScatterUpdate
{
    static constexpr const char* name = "TensorScatterUpdate";
    
    enum class Argument
    {
        tensor,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct ScalarSummary
{
    static constexpr const char* name = "ScalarSummary";
    
    enum class Argument
    {
        tags,
        values,
        summary
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tags", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Sigmoid
{
    static constexpr const char* name = "Sigmoid";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FloorMod
{
    static constexpr const char* name = "FloorMod";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeFusedBatchNormEx
{
    static constexpr const char* name = "_MklNativeFusedBatchNormEx";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        side_input,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"side_input", ArgumentDesc::TensorCount::SequenceAttrInt, "num_side_inputs"},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        exponential_avg_factor,
        data_format,
        num_side_inputs,
        activation_mode,
        is_training
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"num_side_inputs", AttributeType::Int},
        AttributeDesc{"activation_mode", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct CheckNumerics
{
    static constexpr const char* name = "CheckNumerics";
    
    enum class Argument
    {
        tensor,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        message
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"message", AttributeType::String}
    };
};

struct XlaBroadcastHelper
{
    static constexpr const char* name = "XlaBroadcastHelper";
    
    enum class Argument
    {
        lhs,
        rhs,
        broadcast_dims,
        lhs_output,
        rhs_output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"lhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"broadcast_dims", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lhs_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct CheckNumericsV2
{
    static constexpr const char* name = "CheckNumericsV2";
    
    enum class Argument
    {
        tensor,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        message
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"message", AttributeType::String}
    };
};

struct Send
{
    static constexpr const char* name = "Send";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct GetSessionHandle
{
    static constexpr const char* name = "GetSessionHandle";
    
    enum class Argument
    {
        value,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatefulUniform
{
    static constexpr const char* name = "StatefulUniform";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct StatsAggregatorHandleV2
{
    static constexpr const char* name = "StatsAggregatorHandleV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ResourceStridedSliceAssign
{
    static constexpr const char* name = "ResourceStridedSliceAssign";
    
    enum class Argument
    {
        ref,
        begin,
        end,
        strides,
        value
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"end", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index,
        begin_mask,
        end_mask,
        ellipsis_mask,
        new_axis_mask,
        shrink_axis_mask
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"begin_mask", AttributeType::Int},
        AttributeDesc{"end_mask", AttributeType::Int},
        AttributeDesc{"ellipsis_mask", AttributeType::Int},
        AttributeDesc{"new_axis_mask", AttributeType::Int},
        AttributeDesc{"shrink_axis_mask", AttributeType::Int}
    };
};

struct MatrixLogarithm
{
    static constexpr const char* name = "MatrixLogarithm";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InvertPermutation
{
    static constexpr const char* name = "InvertPermutation";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AnonymousMultiDeviceIterator
{
    static constexpr const char* name = "AnonymousMultiDeviceIterator";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        devices,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"devices", AttributeType::ListString},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Transpose
{
    static constexpr const char* name = "Transpose";
    
    enum class Argument
    {
        x,
        perm,
        y
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"perm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tperm
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tperm", AttributeType::Type}
    };
};

struct Barrier
{
    static constexpr const char* name = "Barrier";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Sin
{
    static constexpr const char* name = "Sin";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Enter
{
    static constexpr const char* name = "Enter";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        frame_name,
        is_constant,
        parallel_iterations
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"frame_name", AttributeType::String},
        AttributeDesc{"is_constant", AttributeType::Bool},
        AttributeDesc{"parallel_iterations", AttributeType::Int}
    };
};

struct _MklQuantizeV2
{
    static constexpr const char* name = "_MklQuantizeV2";
    
    enum class Argument
    {
        input,
        min_range,
        max_range,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        mode,
        round_mode,
        narrow_range,
        axis,
        ensure_minimum_range
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"round_mode", AttributeType::String},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int},
        AttributeDesc{"ensure_minimum_range", AttributeType::Float}
    };
};

struct TensorListFromTensor
{
    static constexpr const char* name = "TensorListFromTensor";
    
    enum class Argument
    {
        tensor,
        element_shape,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct SparseSegmentSumGrad
{
    static constexpr const char* name = "SparseSegmentSumGrad";
    
    enum class Argument
    {
        grad,
        indices,
        segment_ids,
        output_dim0,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dim0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct _MklTranspose
{
    static constexpr const char* name = "_MklTranspose";
    
    enum class Argument
    {
        x,
        perm,
        y
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"perm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tperm
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tperm", AttributeType::Type}
    };
};

struct DebugNumericSummary
{
    static constexpr const char* name = "DebugNumericSummary";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        device_name,
        tensor_name,
        debug_urls,
        lower_bound,
        upper_bound,
        mute_if_healthy,
        gated_grpc
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"device_name", AttributeType::String},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"debug_urls", AttributeType::ListString},
        AttributeDesc{"lower_bound", AttributeType::Float},
        AttributeDesc{"upper_bound", AttributeType::Float},
        AttributeDesc{"mute_if_healthy", AttributeType::Bool},
        AttributeDesc{"gated_grpc", AttributeType::Bool}
    };
};

struct ConjugateTranspose
{
    static constexpr const char* name = "ConjugateTranspose";
    
    enum class Argument
    {
        x,
        perm,
        y
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"perm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tperm
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tperm", AttributeType::Type}
    };
};

struct _MklConjugateTranspose
{
    static constexpr const char* name = "_MklConjugateTranspose";
    
    enum class Argument
    {
        x,
        perm,
        y
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"perm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tperm
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tperm", AttributeType::Type}
    };
};

struct ExperimentalParallelInterleaveDataset
{
    static constexpr const char* name = "ExperimentalParallelInterleaveDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        handle
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sloppy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_output_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"prefetch_input_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Unique
{
    static constexpr const char* name = "Unique";
    
    enum class Argument
    {
        x,
        y,
        idx
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"idx", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_idx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_idx", AttributeType::Type}
    };
};

struct UniqueV2
{
    static constexpr const char* name = "UniqueV2";
    
    enum class Argument
    {
        x,
        axis,
        y,
        idx
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"idx", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Taxis,
        out_idx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Taxis", AttributeType::Type},
        AttributeDesc{"out_idx", AttributeType::Type}
    };
};

struct TakeDataset
{
    static constexpr const char* name = "TakeDataset";
    
    enum class Argument
    {
        input_dataset,
        count,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct UniqueWithCounts
{
    static constexpr const char* name = "UniqueWithCounts";
    
    enum class Argument
    {
        x,
        y,
        idx,
        count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"idx", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_idx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_idx", AttributeType::Type}
    };
};

struct UniqueWithCountsV2
{
    static constexpr const char* name = "UniqueWithCountsV2";
    
    enum class Argument
    {
        x,
        axis,
        y,
        idx,
        count
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"idx", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Taxis,
        out_idx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Taxis", AttributeType::Type},
        AttributeDesc{"out_idx", AttributeType::Type}
    };
};

struct AdjustSaturation
{
    static constexpr const char* name = "AdjustSaturation";
    
    enum class Argument
    {
        images,
        scale,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct VariableShape
{
    static constexpr const char* name = "VariableShape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        out_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct ParallelDynamicStitch
{
    static constexpr const char* name = "ParallelDynamicStitch";
    
    enum class Argument
    {
        indices,
        data,
        merged
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"merged", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklEluGrad
{
    static constexpr const char* name = "_MklEluGrad";
    
    enum class Argument
    {
        gradients,
        features,
        mkl_gradients,
        mkl_features,
        backprops,
        mkl_backprops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Shape
{
    static constexpr const char* name = "Shape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct KmeansPlusPlusInitialization
{
    static constexpr const char* name = "KmeansPlusPlusInitialization";
    
    enum class Argument
    {
        points,
        num_to_sample,
        seed,
        num_retries_per_sample,
        samples
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"points", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_to_sample", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_retries_per_sample", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"samples", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Tan
{
    static constexpr const char* name = "Tan";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscReduce
{
    static constexpr const char* name = "RiscReduce";
    
    enum class Argument
    {
        tensor,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reduce_type,
        Index,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"reduce_type", AttributeType::String},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Inv
{
    static constexpr const char* name = "Inv";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ShapeN
{
    static constexpr const char* name = "ShapeN";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        N,
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct QueueIsClosedV2
{
    static constexpr const char* name = "QueueIsClosedV2";
    
    enum class Argument
    {
        handle,
        is_closed
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_closed", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ScatterUpdate
{
    static constexpr const char* name = "ScatterUpdate";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct EnsureShape
{
    static constexpr const char* name = "EnsureShape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AvgPool3D
{
    static constexpr const char* name = "AvgPool3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BoostedTreesQuantileStreamResourceDeserialize
{
    static constexpr const char* name = "BoostedTreesQuantileStreamResourceDeserialize";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        bucket_boundaries
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucket_boundaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_streams"}
    };

    enum class Attribute
    {
        num_streams
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_streams", AttributeType::Int}
    };
};

struct StridedSliceGrad
{
    static constexpr const char* name = "StridedSliceGrad";
    
    enum class Argument
    {
        shape,
        begin,
        end,
        strides,
        dy,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"end", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index,
        begin_mask,
        end_mask,
        ellipsis_mask,
        new_axis_mask,
        shrink_axis_mask
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"begin_mask", AttributeType::Int},
        AttributeDesc{"end_mask", AttributeType::Int},
        AttributeDesc{"ellipsis_mask", AttributeType::Int},
        AttributeDesc{"new_axis_mask", AttributeType::Int},
        AttributeDesc{"shrink_axis_mask", AttributeType::Int}
    };
};

struct RiscFft
{
    static constexpr const char* name = "RiscFft";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct DummyMemoryCache
{
    static constexpr const char* name = "DummyMemoryCache";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorStridedSliceUpdate
{
    static constexpr const char* name = "TensorStridedSliceUpdate";
    
    enum class Argument
    {
        input,
        begin,
        end,
        strides,
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"end", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Index,
        begin_mask,
        end_mask,
        ellipsis_mask,
        new_axis_mask,
        shrink_axis_mask
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Index", AttributeType::Type},
        AttributeDesc{"begin_mask", AttributeType::Int},
        AttributeDesc{"end_mask", AttributeType::Int},
        AttributeDesc{"ellipsis_mask", AttributeType::Int},
        AttributeDesc{"new_axis_mask", AttributeType::Int},
        AttributeDesc{"shrink_axis_mask", AttributeType::Int}
    };
};

struct ReaderReadUpToV2
{
    static constexpr const char* name = "ReaderReadUpToV2";
    
    enum class Argument
    {
        reader_handle,
        queue_handle,
        num_records,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"queue_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_records", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklMaxPool
{
    static constexpr const char* name = "_MklMaxPool";
    
    enum class Argument
    {
        input,
        mkl_input,
        output,
        workspace,
        mkl_output,
        mkl_workspace
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding,
        data_format,
        explicit_paddings,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct MultiDeviceIterator
{
    static constexpr const char* name = "MultiDeviceIterator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        devices,
        shared_name,
        container,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"devices", AttributeType::ListString},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TileGrad
{
    static constexpr const char* name = "TileGrad";
    
    enum class Argument
    {
        input,
        multiples,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"multiples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorMapHasKey
{
    static constexpr const char* name = "TensorMapHasKey";
    
    enum class Argument
    {
        input_handle,
        key,
        has_key
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"has_key", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"key_dtype", AttributeType::Type}
    };
};

struct BroadcastArgs
{
    static constexpr const char* name = "BroadcastArgs";
    
    enum class Argument
    {
        s0,
        s1,
        r0
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"s0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"s1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r0", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklFusedMatMul
{
    static constexpr const char* name = "_MklFusedMatMul";
    
    enum class Argument
    {
        a,
        b,
        args,
        mkl_a,
        mkl_b,
        mkl_args,
        product,
        mkl_product
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"mkl_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        is_filter_const,
        transpose_a,
        transpose_b,
        T,
        num_args,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct BroadcastGradientArgs
{
    static constexpr const char* name = "BroadcastGradientArgs";
    
    enum class Argument
    {
        s0,
        s1,
        r0,
        r1
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"s0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"s1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r1", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct PadV2
{
    static constexpr const char* name = "PadV2";
    
    enum class Argument
    {
        input,
        paddings,
        constant_values,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"constant_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct MirrorPad
{
    static constexpr const char* name = "MirrorPad";
    
    enum class Argument
    {
        input,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings,
        mode
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String}
    };
};

struct MirrorPadGrad
{
    static constexpr const char* name = "MirrorPadGrad";
    
    enum class Argument
    {
        input,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings,
        mode
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String}
    };
};

struct Placeholder
{
    static constexpr const char* name = "Placeholder";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct GeneratorDataset
{
    static constexpr const char* name = "GeneratorDataset";
    
    enum class Argument
    {
        init_func_other_args,
        next_func_other_args,
        finalize_func_other_args,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"init_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tinit_func_args"},
        ArgumentDesc{"next_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tnext_func_args"},
        ArgumentDesc{"finalize_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tfinalize_func_args"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        init_func,
        next_func,
        finalize_func,
        Tinit_func_args,
        Tnext_func_args,
        Tfinalize_func_args,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"init_func", AttributeType::Func},
        AttributeDesc{"next_func", AttributeType::Func},
        AttributeDesc{"finalize_func", AttributeType::Func},
        AttributeDesc{"Tinit_func_args", AttributeType::ListType},
        AttributeDesc{"Tnext_func_args", AttributeType::ListType},
        AttributeDesc{"Tfinalize_func_args", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RiscLogicalNot
{
    static constexpr const char* name = "RiscLogicalNot";
    
    enum class Argument
    {
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct PlaceholderV2
{
    static constexpr const char* name = "PlaceholderV2";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct Squeeze
{
    static constexpr const char* name = "Squeeze";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        squeeze_dims
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"squeeze_dims", AttributeType::ListInt}
    };
};

struct EmptyTensorMap
{
    static constexpr const char* name = "EmptyTensorMap";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AccumulatorSetGlobalStep
{
    static constexpr const char* name = "AccumulatorSetGlobalStep";
    
    enum class Argument
    {
        handle,
        new_global_step
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"new_global_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct MergeV2Checkpoints
{
    static constexpr const char* name = "MergeV2Checkpoints";
    
    enum class Argument
    {
        checkpoint_prefixes,
        destination_prefix
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"checkpoint_prefixes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"destination_prefix", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        delete_old_dirs
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"delete_old_dirs", AttributeType::Bool}
    };
};

struct ImageSummary
{
    static constexpr const char* name = "ImageSummary";
    
    enum class Argument
    {
        tag,
        tensor,
        summary
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_images,
        T,
        bad_color
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"max_images", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"bad_color", AttributeType::Tensor}
    };
};

struct SpaceToBatchND
{
    static constexpr const char* name = "SpaceToBatchND";
    
    enum class Argument
    {
        input,
        block_shape,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tblock_shape,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tblock_shape", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct InterleaveDataset
{
    static constexpr const char* name = "InterleaveDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SpaceToBatch
{
    static constexpr const char* name = "SpaceToBatch";
    
    enum class Argument
    {
        input,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings,
        block_size
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"block_size", AttributeType::Int}
    };
};

struct PriorityQueueV2
{
    static constexpr const char* name = "PriorityQueueV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct BatchToSpaceND
{
    static constexpr const char* name = "BatchToSpaceND";
    
    enum class Argument
    {
        input,
        block_shape,
        crops,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"crops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tblock_shape,
        Tcrops
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tblock_shape", AttributeType::Type},
        AttributeDesc{"Tcrops", AttributeType::Type}
    };
};

struct DivNoNan
{
    static constexpr const char* name = "DivNoNan";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResourceApplyAdam
{
    static constexpr const char* name = "ResourceApplyAdam";
    
    enum class Argument
    {
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct TensorArrayWriteV2
{
    static constexpr const char* name = "TensorArrayWriteV2";
    
    enum class Argument
    {
        handle,
        index,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchToSpace
{
    static constexpr const char* name = "BatchToSpace";
    
    enum class Argument
    {
        input,
        crops,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"crops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        block_size,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"block_size", AttributeType::Int},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct SpaceToDepth
{
    static constexpr const char* name = "SpaceToDepth";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        block_size,
        data_format
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"block_size", AttributeType::Int},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct ResizeBilinear
{
    static constexpr const char* name = "ResizeBilinear";
    
    enum class Argument
    {
        images,
        size,
        resized_images
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct DepthToSpace
{
    static constexpr const char* name = "DepthToSpace";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        block_size,
        data_format
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"block_size", AttributeType::Int},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct LoadTPUEmbeddingMomentumParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingMomentumParameters";
    
    enum class Argument
    {
        parameters,
        momenta
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct SparseReduceMax
{
    static constexpr const char* name = "SparseReduceMax";
    
    enum class Argument
    {
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_axes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExtractImagePatches
{
    static constexpr const char* name = "ExtractImagePatches";
    
    enum class Argument
    {
        images,
        patches
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"patches", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksizes,
        strides,
        rates,
        T,
        padding
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksizes", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"rates", AttributeType::ListInt},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct _UnaryOpsComposition
{
    static constexpr const char* name = "_UnaryOpsComposition";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        op_names
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"op_names", AttributeType::ListString}
    };
};

struct ExtractVolumePatches
{
    static constexpr const char* name = "ExtractVolumePatches";
    
    enum class Argument
    {
        input,
        patches
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"patches", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksizes,
        strides,
        T,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"ksizes", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct FractionalMaxPool
{
    static constexpr const char* name = "FractionalMaxPool";
    
    enum class Argument
    {
        value,
        output,
        row_pooling_sequence,
        col_pooling_sequence
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_pooling_sequence", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pooling_ratio,
        pseudo_random,
        overlapping,
        deterministic,
        seed,
        seed2,
        T
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"pooling_ratio", AttributeType::ListFloat},
        AttributeDesc{"pseudo_random", AttributeType::Bool},
        AttributeDesc{"overlapping", AttributeType::Bool},
        AttributeDesc{"deterministic", AttributeType::Bool},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BoostedTreesBucketize
{
    static constexpr const char* name = "BoostedTreesBucketize";
    
    enum class Argument
    {
        float_values,
        bucket_boundaries,
        buckets
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"float_values", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"bucket_boundaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"buckets", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct OneHot
{
    static constexpr const char* name = "OneHot";
    
    enum class Argument
    {
        indices,
        depth,
        on_value,
        off_value,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"depth", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"on_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"off_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        axis,
        T,
        TI
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"axis", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"TI", AttributeType::Type}
    };
};

struct CollectiveReduce
{
    static constexpr const char* name = "CollectiveReduce";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        group_size,
        group_key,
        instance_key,
        merge_op,
        final_op,
        subdiv_offsets,
        wait_for,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"group_size", AttributeType::Int},
        AttributeDesc{"group_key", AttributeType::Int},
        AttributeDesc{"instance_key", AttributeType::Int},
        AttributeDesc{"merge_op", AttributeType::String},
        AttributeDesc{"final_op", AttributeType::String},
        AttributeDesc{"subdiv_offsets", AttributeType::ListInt},
        AttributeDesc{"wait_for", AttributeType::ListInt},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct QuantizeAndDequantize
{
    static constexpr const char* name = "QuantizeAndDequantize";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        signed_input,
        num_bits,
        range_given,
        input_min,
        input_max,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"signed_input", AttributeType::Bool},
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"range_given", AttributeType::Bool},
        AttributeDesc{"input_min", AttributeType::Float},
        AttributeDesc{"input_max", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CollectiveReduceV2
{
    static constexpr const char* name = "CollectiveReduceV2";
    
    enum class Argument
    {
        input,
        group_size,
        group_key,
        instance_key,
        ordering_token,
        data
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"instance_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ordering_token", ArgumentDesc::TensorCount::SequenceAttrInt, "Nordering_token"},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        merge_op,
        final_op,
        communication_hint,
        timeout_seconds,
        Nordering_token,
        max_subdivs_per_device
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"merge_op", AttributeType::String},
        AttributeDesc{"final_op", AttributeType::String},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float},
        AttributeDesc{"Nordering_token", AttributeType::Int},
        AttributeDesc{"max_subdivs_per_device", AttributeType::Int}
    };
};

struct QuantizeAndDequantizeV2
{
    static constexpr const char* name = "QuantizeAndDequantizeV2";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        signed_input,
        num_bits,
        range_given,
        T,
        round_mode,
        narrow_range,
        axis
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"signed_input", AttributeType::Bool},
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"range_given", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"round_mode", AttributeType::String},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct QuantizeAndDequantizeV4Grad
{
    static constexpr const char* name = "QuantizeAndDequantizeV4Grad";
    
    enum class Argument
    {
        gradients,
        input,
        input_min,
        input_max,
        input_backprop,
        input_min_backprop,
        input_max_backprop
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        axis
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct QueueDequeueManyV2
{
    static constexpr const char* name = "QueueDequeueManyV2";
    
    enum class Argument
    {
        handle,
        n,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"n", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct ScatterNdNonAliasingAdd
{
    static constexpr const char* name = "ScatterNdNonAliasingAdd";
    
    enum class Argument
    {
        input,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct BoostedTreesAggregateStats
{
    static constexpr const char* name = "BoostedTreesAggregateStats";
    
    enum class Argument
    {
        node_ids,
        gradients,
        hessians,
        feature,
        stats_summary
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"hessians", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_splits,
        num_buckets
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"max_splits", AttributeType::Int},
        AttributeDesc{"num_buckets", AttributeType::Int}
    };
};

struct QuantizeAndDequantizeV3
{
    static constexpr const char* name = "QuantizeAndDequantizeV3";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        num_bits,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_bits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        signed_input,
        range_given,
        T,
        narrow_range,
        axis
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"signed_input", AttributeType::Bool},
        AttributeDesc{"range_given", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int}
    };
};

struct UnicodeDecodeWithOffsets
{
    static constexpr const char* name = "UnicodeDecodeWithOffsets";
    
    enum class Argument
    {
        input,
        row_splits,
        char_values,
        char_to_byte_starts
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"char_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"char_to_byte_starts", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        input_encoding,
        errors,
        replacement_char,
        replace_control_characters,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"input_encoding", AttributeType::String},
        AttributeDesc{"errors", AttributeType::String},
        AttributeDesc{"replacement_char", AttributeType::Int},
        AttributeDesc{"replace_control_characters", AttributeType::Bool},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct QuantizeV2
{
    static constexpr const char* name = "QuantizeV2";
    
    enum class Argument
    {
        input,
        min_range,
        max_range,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        mode,
        round_mode,
        narrow_range,
        axis,
        ensure_minimum_range
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"round_mode", AttributeType::String},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int},
        AttributeDesc{"ensure_minimum_range", AttributeType::Float}
    };
};

struct NcclAllReduce
{
    static constexpr const char* name = "NcclAllReduce";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reduction,
        T,
        num_devices,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"reduction", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorArrayGrad
{
    static constexpr const char* name = "TensorArrayGrad";
    
    enum class Argument
    {
        handle,
        flow_in,
        grad_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        source
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"source", AttributeType::String}
    };
};

struct BitwiseOr
{
    static constexpr const char* name = "BitwiseOr";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Dequantize
{
    static constexpr const char* name = "Dequantize";
    
    enum class Argument
    {
        input,
        min_range,
        max_range,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        mode,
        narrow_range,
        axis,
        dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct RiscMin
{
    static constexpr const char* name = "RiscMin";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedConcat
{
    static constexpr const char* name = "QuantizedConcat";
    
    enum class Argument
    {
        concat_dim,
        values,
        input_mins,
        input_maxes,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"concat_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"input_mins", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"input_maxes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct EncodeJpegVariableQuality
{
    static constexpr const char* name = "EncodeJpegVariableQuality";
    
    enum class Argument
    {
        images,
        quality,
        contents
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"quality", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QuantizedReshape
{
    static constexpr const char* name = "QuantizedReshape";
    
    enum class Argument
    {
        tensor,
        shape,
        input_min,
        input_max,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct SparseSegmentMeanWithNumSegments
{
    static constexpr const char* name = "SparseSegmentMeanWithNumSegments";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tnumsegments,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct TensorArraySizeV3
{
    static constexpr const char* name = "TensorArraySizeV3";
    
    enum class Argument
    {
        handle,
        flow_in,
        size
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct MapDefun
{
    static constexpr const char* name = "MapDefun";
    
    enum class Argument
    {
        arguments,
        captured_inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"captured_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tcaptured"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        Targuments,
        Tcaptured,
        output_types,
        output_shapes,
        f,
        max_intra_op_parallelism
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"Tcaptured", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"max_intra_op_parallelism", AttributeType::Int}
    };
};

struct QuantizedInstanceNorm
{
    static constexpr const char* name = "QuantizedInstanceNorm";
    
    enum class Argument
    {
        x,
        x_min,
        x_max,
        y,
        y_min,
        y_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        output_range_given,
        given_y_min,
        given_y_max,
        variance_epsilon,
        min_separation
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"output_range_given", AttributeType::Bool},
        AttributeDesc{"given_y_min", AttributeType::Float},
        AttributeDesc{"given_y_max", AttributeType::Float},
        AttributeDesc{"variance_epsilon", AttributeType::Float},
        AttributeDesc{"min_separation", AttributeType::Float}
    };
};

struct UpperBound
{
    static constexpr const char* name = "UpperBound";
    
    enum class Argument
    {
        sorted_inputs,
        values,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sorted_inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct TensorListConcatLists
{
    static constexpr const char* name = "TensorListConcatLists";
    
    enum class Argument
    {
        input_a,
        input_b,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct XlaDynamicSlice
{
    static constexpr const char* name = "XlaDynamicSlice";
    
    enum class Argument
    {
        input,
        start_indices,
        size_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"start_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct AnonymousRandomSeedGenerator
{
    static constexpr const char* name = "AnonymousRandomSeedGenerator";
    
    enum class Argument
    {
        seed,
        seed2,
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FilterDataset
{
    static constexpr const char* name = "FilterDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        predicate,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"predicate", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct LowerBound
{
    static constexpr const char* name = "LowerBound";
    
    enum class Argument
    {
        sorted_inputs,
        values,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sorted_inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct Relu6Grad
{
    static constexpr const char* name = "Relu6Grad";
    
    enum class Argument
    {
        gradients,
        features,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ScatterNd
{
    static constexpr const char* name = "ScatterNd";
    
    enum class Argument
    {
        indices,
        updates,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct TensorScatterAdd
{
    static constexpr const char* name = "TensorScatterAdd";
    
    enum class Argument
    {
        tensor,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct SelectV2
{
    static constexpr const char* name = "SelectV2";
    
    enum class Argument
    {
        condition,
        t,
        e,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"condition", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct GetSessionTensor
{
    static constexpr const char* name = "GetSessionTensor";
    
    enum class Argument
    {
        handle,
        value
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct ScaleAndTranslateGrad
{
    static constexpr const char* name = "ScaleAndTranslateGrad";
    
    enum class Argument
    {
        grads,
        original_image,
        scale,
        translation,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"original_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"translation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        kernel_type,
        antialias
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"kernel_type", AttributeType::String},
        AttributeDesc{"antialias", AttributeType::Bool}
    };
};

struct InfeedEnqueuePrelinearizedBuffer
{
    static constexpr const char* name = "InfeedEnqueuePrelinearizedBuffer";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct DeserializeSparse
{
    static constexpr const char* name = "DeserializeSparse";
    
    enum class Argument
    {
        serialized_sparse,
        sparse_indices,
        sparse_values,
        sparse_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized_sparse", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tserialized
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tserialized", AttributeType::Type}
    };
};

struct TensorScatterSub
{
    static constexpr const char* name = "TensorScatterSub";
    
    enum class Argument
    {
        tensor,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct MatrixInverse
{
    static constexpr const char* name = "MatrixInverse";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AdjustContrastv2
{
    static constexpr const char* name = "AdjustContrastv2";
    
    enum class Argument
    {
        images,
        contrast_factor,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contrast_factor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ParallelMapDatasetV2
{
    static constexpr const char* name = "ParallelMapDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        num_parallel_calls,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        use_inter_op_parallelism,
        deterministic,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_inter_op_parallelism", AttributeType::Bool},
        AttributeDesc{"deterministic", AttributeType::String},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct QueueCloseV2
{
    static constexpr const char* name = "QueueCloseV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        cancel_pending_enqueues
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"cancel_pending_enqueues", AttributeType::Bool}
    };
};

struct TensorScatterMax
{
    static constexpr const char* name = "TensorScatterMax";
    
    enum class Argument
    {
        tensor,
        indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct RiscNeg
{
    static constexpr const char* name = "RiscNeg";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FakeQuantWithMinMaxArgsGradient
{
    static constexpr const char* name = "FakeQuantWithMinMaxArgsGradient";
    
    enum class Argument
    {
        gradients,
        inputs,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        min,
        max,
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"min", AttributeType::Float},
        AttributeDesc{"max", AttributeType::Float},
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct BatchCholesky
{
    static constexpr const char* name = "BatchCholesky";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OutfeedEnqueue
{
    static constexpr const char* name = "OutfeedEnqueue";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct TPUPartitionedCall
{
    static constexpr const char* name = "TPUPartitionedCall";
    
    enum class Argument
    {
        args,
        device_ordinal,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"device_ordinal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        f,
        autotuner_thresh
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"autotuner_thresh", AttributeType::Int}
    };
};

struct FakeQuantWithMinMaxVarsGradient
{
    static constexpr const char* name = "FakeQuantWithMinMaxVarsGradient";
    
    enum class Argument
    {
        gradients,
        inputs,
        min,
        max,
        backprops_wrt_input,
        backprop_wrt_min,
        backprop_wrt_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops_wrt_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop_wrt_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop_wrt_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct CSVDatasetV2
{
    static constexpr const char* name = "CSVDatasetV2";
    
    enum class Argument
    {
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        exclude_cols,
        handle
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"header", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"field_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"use_quote_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"na_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"select_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"},
        ArgumentDesc{"exclude_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct FakeQuantWithMinMaxVarsPerChannel
{
    static constexpr const char* name = "FakeQuantWithMinMaxVarsPerChannel";
    
    enum class Argument
    {
        inputs,
        min,
        max,
        outputs
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct FakeQuantWithMinMaxVarsPerChannelGradient
{
    static constexpr const char* name = "FakeQuantWithMinMaxVarsPerChannelGradient";
    
    enum class Argument
    {
        gradients,
        inputs,
        min,
        max,
        backprops_wrt_input,
        backprop_wrt_min,
        backprop_wrt_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops_wrt_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop_wrt_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop_wrt_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bits,
        narrow_range
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bits", AttributeType::Int},
        AttributeDesc{"narrow_range", AttributeType::Bool}
    };
};

struct UnsortedSegmentProd
{
    static constexpr const char* name = "UnsortedSegmentProd";
    
    enum class Argument
    {
        data,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        Tnumsegments
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type}
    };
};

struct ResourceSparseApplyAdagrad
{
    static constexpr const char* name = "ResourceSparseApplyAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct GroupByReducerDataset
{
    static constexpr const char* name = "GroupByReducerDataset";
    
    enum class Argument
    {
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tkey_func_other_arguments"},
        ArgumentDesc{"init_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tinit_func_other_arguments"},
        ArgumentDesc{"reduce_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Treduce_func_other_arguments"},
        ArgumentDesc{"finalize_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tfinalize_func_other_arguments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_func,
        init_func,
        reduce_func,
        finalize_func,
        Tkey_func_other_arguments,
        Tinit_func_other_arguments,
        Treduce_func_other_arguments,
        Tfinalize_func_other_arguments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"key_func", AttributeType::Func},
        AttributeDesc{"init_func", AttributeType::Func},
        AttributeDesc{"reduce_func", AttributeType::Func},
        AttributeDesc{"finalize_func", AttributeType::Func},
        AttributeDesc{"Tkey_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Tinit_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Treduce_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Tfinalize_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Fingerprint
{
    static constexpr const char* name = "Fingerprint";
    
    enum class Argument
    {
        data,
        method,
        fingerprint
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"method", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fingerprint", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResizeBicubic
{
    static constexpr const char* name = "ResizeBicubic";
    
    enum class Argument
    {
        images,
        size,
        resized_images
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct _MklConcat
{
    static constexpr const char* name = "_MklConcat";
    
    enum class Argument
    {
        concat_dim,
        values,
        mkl_concat_dim,
        mkl_values,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"concat_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mkl_concat_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AnonymousMemoryCache
{
    static constexpr const char* name = "AnonymousMemoryCache";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BatchMatrixSetDiag
{
    static constexpr const char* name = "BatchMatrixSetDiag";
    
    enum class Argument
    {
        input,
        diagonal,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"diagonal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayConcat
{
    static constexpr const char* name = "TensorArrayConcat";
    
    enum class Argument
    {
        handle,
        flow_in,
        value,
        lengths
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape_except0
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape_except0", AttributeType::Shape}
    };
};

struct BatchMatrixBandPart
{
    static constexpr const char* name = "BatchMatrixBandPart";
    
    enum class Argument
    {
        input,
        num_lower,
        num_upper,
        band
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_lower", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_upper", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"band", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct IteratorGetNext
{
    static constexpr const char* name = "IteratorGetNext";
    
    enum class Argument
    {
        iterator,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalPrivateThreadPoolDataset
{
    static constexpr const char* name = "ExperimentalPrivateThreadPoolDataset";
    
    enum class Argument
    {
        input_dataset,
        num_threads,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_threads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct CacheDatasetV2
{
    static constexpr const char* name = "CacheDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        filename,
        cache,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cache", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct DecodeWav
{
    static constexpr const char* name = "DecodeWav";
    
    enum class Argument
    {
        contents,
        audio,
        sample_rate
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"audio", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample_rate", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        desired_channels,
        desired_samples
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"desired_channels", AttributeType::Int},
        AttributeDesc{"desired_samples", AttributeType::Int}
    };
};

struct AudioSpectrogram
{
    static constexpr const char* name = "AudioSpectrogram";
    
    enum class Argument
    {
        input,
        spectrogram
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"spectrogram", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        window_size,
        stride,
        magnitude_squared
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"window_size", AttributeType::Int},
        AttributeDesc{"stride", AttributeType::Int},
        AttributeDesc{"magnitude_squared", AttributeType::Bool}
    };
};

struct ShuffleAndRepeatDatasetV2
{
    static constexpr const char* name = "ShuffleAndRepeatDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        seed,
        seed2,
        count,
        seed_generator,
        handle
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed_generator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reshuffle_each_iteration,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"reshuffle_each_iteration", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _MklMaximum
{
    static constexpr const char* name = "_MklMaximum";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FractionalAvgPoolGrad
{
    static constexpr const char* name = "FractionalAvgPoolGrad";
    
    enum class Argument
    {
        orig_input_tensor_shape,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_tensor_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        overlapping,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"overlapping", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Mfcc
{
    static constexpr const char* name = "Mfcc";
    
    enum class Argument
    {
        spectrogram,
        sample_rate,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"spectrogram", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample_rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        upper_frequency_limit,
        lower_frequency_limit,
        filterbank_channel_count,
        dct_coefficient_count
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"upper_frequency_limit", AttributeType::Float},
        AttributeDesc{"lower_frequency_limit", AttributeType::Float},
        AttributeDesc{"filterbank_channel_count", AttributeType::Int},
        AttributeDesc{"dct_coefficient_count", AttributeType::Int}
    };
};

struct StatefulStandardNormalV2
{
    static constexpr const char* name = "StatefulStandardNormalV2";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct _NcclBroadcastSend
{
    static constexpr const char* name = "_NcclBroadcastSend";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_devices,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct PaddedBatchDataset
{
    static constexpr const char* name = "PaddedBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padded_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"padding_values", ArgumentDesc::TensorCount::SequenceAttrList, "Toutput_types"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Toutput_types,
        output_shapes,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Toutput_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct IFFT3D
{
    static constexpr const char* name = "IFFT3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct BatchFunction
{
    static constexpr const char* name = "BatchFunction";
    
    enum class Argument
    {
        in_tensors,
        captured_tensors,
        out_tensors
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"in_tensors", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"captured_tensors", ArgumentDesc::TensorCount::SequenceAttrList, "Tcaptured"},
        ArgumentDesc{"out_tensors", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        f,
        num_batch_threads,
        max_batch_size,
        batch_timeout_micros,
        max_enqueued_batches,
        allowed_batch_sizes,
        container,
        shared_name,
        batching_queue,
        Tin,
        Tcaptured,
        Tout,
        enable_large_batch_splitting
    };

    static constexpr std::array<AttributeDesc, 13> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"num_batch_threads", AttributeType::Int},
        AttributeDesc{"max_batch_size", AttributeType::Int},
        AttributeDesc{"batch_timeout_micros", AttributeType::Int},
        AttributeDesc{"max_enqueued_batches", AttributeType::Int},
        AttributeDesc{"allowed_batch_sizes", AttributeType::ListInt},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"batching_queue", AttributeType::String},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tcaptured", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"enable_large_batch_splitting", AttributeType::Bool}
    };
};

struct SerializeIterator
{
    static constexpr const char* name = "SerializeIterator";
    
    enum class Argument
    {
        resource_handle,
        serialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        external_state_policy
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"external_state_policy", AttributeType::Int}
    };
};

struct Batch
{
    static constexpr const char* name = "Batch";
    
    enum class Argument
    {
        in_tensors,
        batched_tensors,
        batch_index,
        id
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"in_tensors", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"batched_tensors", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"batch_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"id", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_batch_threads,
        max_batch_size,
        max_enqueued_batches,
        batch_timeout_micros,
        allowed_batch_sizes,
        grad_timeout_micros,
        container,
        shared_name,
        batching_queue,
        T
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"num_batch_threads", AttributeType::Int},
        AttributeDesc{"max_batch_size", AttributeType::Int},
        AttributeDesc{"max_enqueued_batches", AttributeType::Int},
        AttributeDesc{"batch_timeout_micros", AttributeType::Int},
        AttributeDesc{"allowed_batch_sizes", AttributeType::ListInt},
        AttributeDesc{"grad_timeout_micros", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"batching_queue", AttributeType::String},
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct RsqrtGrad
{
    static constexpr const char* name = "RsqrtGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Unbatch
{
    static constexpr const char* name = "Unbatch";
    
    enum class Argument
    {
        batched_tensor,
        batch_index,
        id,
        unbatched_tensor
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"batched_tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"id", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"unbatched_tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        timeout_micros,
        container,
        shared_name,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"timeout_micros", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InTopK
{
    static constexpr const char* name = "InTopK";
    
    enum class Argument
    {
        predictions,
        targets,
        precision
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"predictions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"targets", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"precision", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        k,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"k", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseTensorSliceDataset
{
    static constexpr const char* name = "SparseTensorSliceDataset";
    
    enum class Argument
    {
        indices,
        values,
        dense_shape,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tvalues
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tvalues", AttributeType::Type}
    };
};

struct UnbatchGrad
{
    static constexpr const char* name = "UnbatchGrad";
    
    enum class Argument
    {
        original_input,
        batch_index,
        grad,
        id,
        batched_grad
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"original_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"id", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batched_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BoostedTreesCenterBias
{
    static constexpr const char* name = "BoostedTreesCenterBias";
    
    enum class Argument
    {
        tree_ensemble_handle,
        mean_gradients,
        mean_hessians,
        l1,
        l2,
        continue_centering
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean_hessians", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"continue_centering", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseApplyAdagrad
{
    static constexpr const char* name = "SparseApplyAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct Invert
{
    static constexpr const char* name = "Invert";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LookupTableRemoveV2
{
    static constexpr const char* name = "LookupTableRemoveV2";
    
    enum class Argument
    {
        table_handle,
        keys
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type}
    };
};

struct _If
{
    static constexpr const char* name = "_If";
    
    enum class Argument
    {
        cond,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"cond", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tcond,
        Tin,
        Tout,
        then_branch,
        else_branch
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Tcond", AttributeType::Type},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"then_branch", AttributeType::Func},
        AttributeDesc{"else_branch", AttributeType::Func}
    };
};

struct PopulationCount
{
    static constexpr const char* name = "PopulationCount";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArray
{
    static constexpr const char* name = "TensorArray";
    
    enum class Argument
    {
        size,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        dynamic_size,
        clear_after_read,
        tensor_array_name,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"dynamic_size", AttributeType::Bool},
        AttributeDesc{"clear_after_read", AttributeType::Bool},
        AttributeDesc{"tensor_array_name", AttributeType::String},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct BitwiseAnd
{
    static constexpr const char* name = "BitwiseAnd";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeConv2DBackpropFilter
{
    static constexpr const char* name = "_MklNativeConv2DBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct BitwiseXor
{
    static constexpr const char* name = "BitwiseXor";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Add
{
    static constexpr const char* name = "Add";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BoostedTreesEnsembleResourceHandleOp
{
    static constexpr const char* name = "BoostedTreesEnsembleResourceHandleOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct IsBoostedTreesEnsembleInitialized
{
    static constexpr const char* name = "IsBoostedTreesEnsembleInitialized";
    
    enum class Argument
    {
        tree_ensemble_handle,
        is_initialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_initialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OutfeedDequeueTupleV2
{
    static constexpr const char* name = "OutfeedDequeueTupleV2";
    
    enum class Argument
    {
        device_ordinal,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"device_ordinal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes,
        shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape}
    };
};

struct ResourceAccumulatorNumAccumulated
{
    static constexpr const char* name = "ResourceAccumulatorNumAccumulated";
    
    enum class Argument
    {
        handle,
        num_accumulated
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_accumulated", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FresnelCos
{
    static constexpr const char* name = "FresnelCos";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BiasAddGrad
{
    static constexpr const char* name = "BiasAddGrad";
    
    enum class Argument
    {
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        data_format
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct BoostedTreesCalculateBestGainsPerFeature
{
    static constexpr const char* name = "BoostedTreesCalculateBestGainsPerFeature";
    
    enum class Argument
    {
        node_id_range,
        stats_summary_list,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        node_ids_list,
        gains_list,
        thresholds_list,
        left_node_contribs_list,
        right_node_contribs_list
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_id_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_complexity", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_node_weight", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"gains_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"thresholds_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"left_node_contribs_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"right_node_contribs_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        max_splits,
        num_features
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"max_splits", AttributeType::Int},
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct ShuffleDataset
{
    static constexpr const char* name = "ShuffleDataset";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        seed,
        seed2,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reshuffle_each_iteration,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"reshuffle_each_iteration", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TensorArrayGather
{
    static constexpr const char* name = "TensorArrayGather";
    
    enum class Argument
    {
        handle,
        indices,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct BoostedTreesCalculateBestFeatureSplit
{
    static constexpr const char* name = "BoostedTreesCalculateBestFeatureSplit";
    
    enum class Argument
    {
        node_id_range,
        stats_summary,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        node_ids,
        gains,
        feature_dimensions,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_with_default_directions
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_id_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_complexity", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_node_weight", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gains", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_dimensions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thresholds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"left_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"right_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"split_with_default_directions", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        logits_dimension,
        split_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"logits_dimension", AttributeType::Int},
        AttributeDesc{"split_type", AttributeType::String}
    };
};

struct BarrierInsertMany
{
    static constexpr const char* name = "BarrierInsertMany";
    
    enum class Argument
    {
        handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        component_index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"component_index", AttributeType::Int}
    };
};

struct BoostedTreesSparseCalculateBestFeatureSplit
{
    static constexpr const char* name = "BoostedTreesSparseCalculateBestFeatureSplit";
    
    enum class Argument
    {
        node_id_range,
        stats_summary_indices,
        stats_summary_values,
        stats_summary_shape,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        node_ids,
        gains,
        feature_dimensions,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_with_default_directions
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_id_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_complexity", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_node_weight", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gains", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_dimensions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thresholds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"left_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"right_node_contribs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"split_with_default_directions", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        logits_dimension,
        split_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"logits_dimension", AttributeType::Int},
        AttributeDesc{"split_type", AttributeType::String}
    };
};

struct BoostedTreesCreateEnsemble
{
    static constexpr const char* name = "BoostedTreesCreateEnsemble";
    
    enum class Argument
    {
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stamp_token", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_ensemble_serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BoostedTreesDeserializeEnsemble
{
    static constexpr const char* name = "BoostedTreesDeserializeEnsemble";
    
    enum class Argument
    {
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stamp_token", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_ensemble_serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BiasAddV1
{
    static constexpr const char* name = "BiasAddV1";
    
    enum class Argument
    {
        value,
        bias,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LoadTPUEmbeddingProximalYogiParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingProximalYogiParameters";
    
    enum class Argument
    {
        parameters,
        v,
        m
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RandomGamma
{
    static constexpr const char* name = "RandomGamma";
    
    enum class Argument
    {
        shape,
        alpha,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        S,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResourceConditionalAccumulator
{
    static constexpr const char* name = "ResourceConditionalAccumulator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        container,
        shared_name,
        reduction_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"reduction_type", AttributeType::String}
    };
};

struct BoostedTreesGetEnsembleStates
{
    static constexpr const char* name = "BoostedTreesGetEnsembleStates";
    
    enum class Argument
    {
        tree_ensemble_handle,
        stamp_token,
        num_trees,
        num_finalized_trees,
        num_attempted_layers,
        last_layer_nodes_range
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stamp_token", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_trees", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_finalized_trees", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_attempted_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"last_layer_nodes_range", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct NegTrain
{
    static constexpr const char* name = "NegTrain";
    
    enum class Argument
    {
        w_in,
        w_out,
        examples,
        labels,
        lr
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"w_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"examples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        vocab_count,
        num_negative_samples
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"vocab_count", AttributeType::ListInt},
        AttributeDesc{"num_negative_samples", AttributeType::Int}
    };
};

struct BoostedTreesMakeStatsSummary
{
    static constexpr const char* name = "BoostedTreesMakeStatsSummary";
    
    enum class Argument
    {
        node_ids,
        gradients,
        hessians,
        bucketized_features_list,
        stats_summary
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"hessians", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucketized_features_list", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"stats_summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_splits,
        num_buckets,
        num_features
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"max_splits", AttributeType::Int},
        AttributeDesc{"num_buckets", AttributeType::Int},
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct BoostedTreesSparseAggregateStats
{
    static constexpr const char* name = "BoostedTreesSparseAggregateStats";
    
    enum class Argument
    {
        node_ids,
        gradients,
        hessians,
        feature_indices,
        feature_values,
        feature_shape,
        stats_summary_indices,
        stats_summary_values,
        stats_summary_shape
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"hessians", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_summary_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_splits,
        num_buckets
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"max_splits", AttributeType::Int},
        AttributeDesc{"num_buckets", AttributeType::Int}
    };
};

struct BoostedTreesPredict
{
    static constexpr const char* name = "BoostedTreesPredict";
    
    enum class Argument
    {
        tree_ensemble_handle,
        bucketized_features,
        logits
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucketized_features", ArgumentDesc::TensorCount::SequenceAttrInt, "num_bucketized_features"},
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bucketized_features,
        logits_dimension
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bucketized_features", AttributeType::Int},
        AttributeDesc{"logits_dimension", AttributeType::Int}
    };
};

struct ApplyProximalAdagrad
{
    static constexpr const char* name = "ApplyProximalAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        l1,
        l2,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct BoostedTreesExampleDebugOutputs
{
    static constexpr const char* name = "BoostedTreesExampleDebugOutputs";
    
    enum class Argument
    {
        tree_ensemble_handle,
        bucketized_features,
        examples_debug_outputs_serialized
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucketized_features", ArgumentDesc::TensorCount::SequenceAttrInt, "num_bucketized_features"},
        ArgumentDesc{"examples_debug_outputs_serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bucketized_features,
        logits_dimension
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bucketized_features", AttributeType::Int},
        AttributeDesc{"logits_dimension", AttributeType::Int}
    };
};

struct ComputeBatchSize
{
    static constexpr const char* name = "ComputeBatchSize";
    
    enum class Argument
    {
        input_dataset,
        batch_size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ClipByValue
{
    static constexpr const char* name = "ClipByValue";
    
    enum class Argument
    {
        t,
        clip_value_min,
        clip_value_max,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"clip_value_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"clip_value_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SigmoidGrad
{
    static constexpr const char* name = "SigmoidGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LoadTPUEmbeddingAdagradParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingAdagradParameters";
    
    enum class Argument
    {
        parameters,
        accumulators
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct BoostedTreesSerializeEnsemble
{
    static constexpr const char* name = "BoostedTreesSerializeEnsemble";
    
    enum class Argument
    {
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stamp_token", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_ensemble_serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BoostedTreesTrainingPredict
{
    static constexpr const char* name = "BoostedTreesTrainingPredict";
    
    enum class Argument
    {
        tree_ensemble_handle,
        cached_tree_ids,
        cached_node_ids,
        bucketized_features,
        partial_logits,
        tree_ids,
        node_ids
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cached_tree_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cached_node_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucketized_features", ArgumentDesc::TensorCount::SequenceAttrInt, "num_bucketized_features"},
        ArgumentDesc{"partial_logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tree_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_bucketized_features,
        logits_dimension
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_bucketized_features", AttributeType::Int},
        AttributeDesc{"logits_dimension", AttributeType::Int}
    };
};

struct SnapshotNestedDatasetReader
{
    static constexpr const char* name = "SnapshotNestedDatasetReader";
    
    enum class Argument
    {
        inputs,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct BoostedTreesUpdateEnsemble
{
    static constexpr const char* name = "BoostedTreesUpdateEnsemble";
    
    enum class Argument
    {
        tree_ensemble_handle,
        feature_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        max_depth,
        learning_rate
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"gains", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"thresholds", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"left_node_contribs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"right_node_contribs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"max_depth", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"learning_rate", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pruning_mode,
        num_features
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"pruning_mode", AttributeType::Int},
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct BoostedTreesUpdateEnsembleV2
{
    static constexpr const char* name = "BoostedTreesUpdateEnsembleV2";
    
    enum class Argument
    {
        tree_ensemble_handle,
        feature_ids,
        dimension_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_types,
        max_depth,
        learning_rate,
        pruning_mode
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tree_ensemble_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_ids", ArgumentDesc::TensorCount::SequenceAttrInt, "num_groups"},
        ArgumentDesc{"dimension_ids", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"node_ids", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"gains", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"thresholds", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"left_node_contribs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"right_node_contribs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"split_types", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"},
        ArgumentDesc{"max_depth", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"learning_rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pruning_mode", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_features,
        logits_dimension,
        num_groups
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int},
        AttributeDesc{"logits_dimension", AttributeType::Int},
        AttributeDesc{"num_groups", AttributeType::Int}
    };
};

struct BoostedTreesQuantileStreamResourceHandleOp
{
    static constexpr const char* name = "BoostedTreesQuantileStreamResourceHandleOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct RangeDataset
{
    static constexpr const char* name = "RangeDataset";
    
    enum class Argument
    {
        start,
        stop,
        step,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ScatterNdSub
{
    static constexpr const char* name = "ScatterNdSub";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct IsBoostedTreesQuantileStreamResourceInitialized
{
    static constexpr const char* name = "IsBoostedTreesQuantileStreamResourceInitialized";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        is_initialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_initialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OrderedMapUnstage
{
    static constexpr const char* name = "OrderedMapUnstage";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct BoostedTreesFlushQuantileSummaries
{
    static constexpr const char* name = "BoostedTreesFlushQuantileSummaries";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        summaries
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct BoostedTreesQuantileStreamResourceFlush
{
    static constexpr const char* name = "BoostedTreesQuantileStreamResourceFlush";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        num_buckets
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_buckets", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        generate_quantiles
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"generate_quantiles", AttributeType::Bool}
    };
};

struct BoostedTreesQuantileStreamResourceGetBucketBoundaries
{
    static constexpr const char* name = "BoostedTreesQuantileStreamResourceGetBucketBoundaries";
    
    enum class Argument
    {
        quantile_stream_resource_handle,
        bucket_boundaries
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"quantile_stream_resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bucket_boundaries", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int}
    };
};

struct Cumprod
{
    static constexpr const char* name = "Cumprod";
    
    enum class Argument
    {
        x,
        axis,
        out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        exclusive,
        reverse,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"exclusive", AttributeType::Bool},
        AttributeDesc{"reverse", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct UniformCandidateSampler
{
    static constexpr const char* name = "UniformCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        range_max,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"range_max", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct DebugNanCount
{
    static constexpr const char* name = "DebugNanCount";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        device_name,
        tensor_name,
        debug_urls,
        gated_grpc
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"device_name", AttributeType::String},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"debug_urls", AttributeType::ListString},
        AttributeDesc{"gated_grpc", AttributeType::Bool}
    };
};

struct MutableHashTable
{
    static constexpr const char* name = "MutableHashTable";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct ThreadUnsafeUnigramCandidateSampler
{
    static constexpr const char* name = "ThreadUnsafeUnigramCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        range_max,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"range_max", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct _VarHandlesOp
{
    static constexpr const char* name = "_VarHandlesOp";
    
    enum class Argument
    {
        resources
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resources", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        containers,
        shared_names,
        N,
        dtypes,
        shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"containers", AttributeType::ListString},
        AttributeDesc{"shared_names", AttributeType::ListString},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape}
    };
};

struct FixedUnigramCandidateSampler
{
    static constexpr const char* name = "FixedUnigramCandidateSampler";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        true_expected_count,
        sampled_expected_count
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"true_expected_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_expected_count", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        num_sampled,
        unique,
        range_max,
        vocab_file,
        distortion,
        num_reserved_ids,
        num_shards,
        shard,
        unigrams,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 12> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"num_sampled", AttributeType::Int},
        AttributeDesc{"unique", AttributeType::Bool},
        AttributeDesc{"range_max", AttributeType::Int},
        AttributeDesc{"vocab_file", AttributeType::String},
        AttributeDesc{"distortion", AttributeType::Float},
        AttributeDesc{"num_reserved_ids", AttributeType::Int},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard", AttributeType::Int},
        AttributeDesc{"unigrams", AttributeType::ListFloat},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct ComputeAccidentalHits
{
    static constexpr const char* name = "ComputeAccidentalHits";
    
    enum class Argument
    {
        true_classes,
        sampled_candidates,
        indices,
        ids,
        weights
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"true_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sampled_candidates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_true,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num_true", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct TensorArrayGradWithShape
{
    static constexpr const char* name = "TensorArrayGradWithShape";
    
    enum class Argument
    {
        handle,
        flow_in,
        shape_to_prepend,
        grad_handle,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape_to_prepend", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        source
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"source", AttributeType::String}
    };
};

struct LoadAndRemapMatrix
{
    static constexpr const char* name = "LoadAndRemapMatrix";
    
    enum class Argument
    {
        ckpt_path,
        old_tensor_name,
        row_remapping,
        col_remapping,
        initializing_values,
        output_matrix
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ckpt_path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"old_tensor_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_remapping", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_remapping", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initializing_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_matrix", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_rows,
        num_cols,
        max_rows_in_memory
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num_rows", AttributeType::Int},
        AttributeDesc{"num_cols", AttributeType::Int},
        AttributeDesc{"max_rows_in_memory", AttributeType::Int}
    };
};

struct KMC2ChainInitialization
{
    static constexpr const char* name = "KMC2ChainInitialization";
    
    enum class Argument
    {
        distances,
        seed,
        index
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"distances", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct NearestNeighbors
{
    static constexpr const char* name = "NearestNeighbors";
    
    enum class Argument
    {
        points,
        centers,
        k,
        nearest_center_indices,
        nearest_center_distances
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"points", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"centers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nearest_center_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nearest_center_distances", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DecodeBmp
{
    static constexpr const char* name = "DecodeBmp";
    
    enum class Argument
    {
        contents,
        image
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        channels
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"channels", AttributeType::Int}
    };
};

struct QueueDequeueUpTo
{
    static constexpr const char* name = "QueueDequeueUpTo";
    
    enum class Argument
    {
        handle,
        n,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"n", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct DecodePng
{
    static constexpr const char* name = "DecodePng";
    
    enum class Argument
    {
        contents,
        image
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        channels,
        dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"channels", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct DataFormatDimMap
{
    static constexpr const char* name = "DataFormatDimMap";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        src_format,
        dst_format
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"src_format", AttributeType::String},
        AttributeDesc{"dst_format", AttributeType::String}
    };
};

struct CollectiveBcastRecv
{
    static constexpr const char* name = "CollectiveBcastRecv";
    
    enum class Argument
    {
        data
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        group_size,
        group_key,
        instance_key,
        shape,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"group_size", AttributeType::Int},
        AttributeDesc{"group_key", AttributeType::Int},
        AttributeDesc{"instance_key", AttributeType::Int},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct _NcclReduceRecv
{
    static constexpr const char* name = "_NcclReduceRecv";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reduction,
        T,
        num_devices,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"reduction", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorArrayPack
{
    static constexpr const char* name = "TensorArrayPack";
    
    enum class Argument
    {
        handle,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct CollectiveBcastSendV2
{
    static constexpr const char* name = "CollectiveBcastSendV2";
    
    enum class Argument
    {
        input,
        group_size,
        group_key,
        instance_key,
        data
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"instance_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct QueueDequeueUpToV2
{
    static constexpr const char* name = "QueueDequeueUpToV2";
    
    enum class Argument
    {
        handle,
        n,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"n", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct CollectiveBcastRecvV2
{
    static constexpr const char* name = "CollectiveBcastRecvV2";
    
    enum class Argument
    {
        group_size,
        group_key,
        instance_key,
        shape,
        data
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"group_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"instance_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshape,
        communication_hint,
        timeout_seconds
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type},
        AttributeDesc{"communication_hint", AttributeType::String},
        AttributeDesc{"timeout_seconds", AttributeType::Float}
    };
};

struct Switch
{
    static constexpr const char* name = "Switch";
    
    enum class Argument
    {
        data,
        pred,
        output_false,
        output_true
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pred", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_false", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_true", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Log
{
    static constexpr const char* name = "Log";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Qr
{
    static constexpr const char* name = "Qr";
    
    enum class Argument
    {
        input,
        q,
        r
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"q", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        full_matrices,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"full_matrices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Einsum
{
    static constexpr const char* name = "Einsum";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        equation,
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"equation", AttributeType::String},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RefSwitch
{
    static constexpr const char* name = "RefSwitch";
    
    enum class Argument
    {
        data,
        pred,
        output_false,
        output_true
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pred", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_false", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_true", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FusedBatchNormGrad
{
    static constexpr const char* name = "FusedBatchNormGrad";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct RefSelect
{
    static constexpr const char* name = "RefSelect";
    
    enum class Argument
    {
        index,
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct MaxPoolGradGrad
{
    static constexpr const char* name = "MaxPoolGradGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayUnpack
{
    static constexpr const char* name = "TensorArrayUnpack";
    
    enum class Argument
    {
        handle,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Merge
{
    static constexpr const char* name = "Merge";
    
    enum class Argument
    {
        inputs,
        output,
        value_index
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value_index", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct MapDataset
{
    static constexpr const char* name = "MapDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        use_inter_op_parallelism,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_inter_op_parallelism", AttributeType::Bool},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct _MklQuantizedConv2DAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct ResourceApplyAdagradDA
{
    static constexpr const char* name = "ResourceApplyAdagradDA";
    
    enum class Argument
    {
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_squared_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"global_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct TensorArrayConcatV3
{
    static constexpr const char* name = "TensorArrayConcatV3";
    
    enum class Argument
    {
        handle,
        flow_in,
        value,
        lengths
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape_except0
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape_except0", AttributeType::Shape}
    };
};

struct RefMerge
{
    static constexpr const char* name = "RefMerge";
    
    enum class Argument
    {
        inputs,
        output,
        value_index
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value_index", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct DecodeAndCropJpeg
{
    static constexpr const char* name = "DecodeAndCropJpeg";
    
    enum class Argument
    {
        contents,
        crop_window,
        image
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"crop_window", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        channels,
        ratio,
        fancy_upscaling,
        try_recover_truncated,
        acceptable_fraction,
        dct_method
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"channels", AttributeType::Int},
        AttributeDesc{"ratio", AttributeType::Int},
        AttributeDesc{"fancy_upscaling", AttributeType::Bool},
        AttributeDesc{"try_recover_truncated", AttributeType::Bool},
        AttributeDesc{"acceptable_fraction", AttributeType::Float},
        AttributeDesc{"dct_method", AttributeType::String}
    };
};

struct RefEnter
{
    static constexpr const char* name = "RefEnter";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        frame_name,
        is_constant,
        parallel_iterations
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"frame_name", AttributeType::String},
        AttributeDesc{"is_constant", AttributeType::Bool},
        AttributeDesc{"parallel_iterations", AttributeType::Int}
    };
};

struct StackClose
{
    static constexpr const char* name = "StackClose";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct XlaRngBitGenerator
{
    static constexpr const char* name = "XlaRngBitGenerator";
    
    enum class Argument
    {
        algorithm,
        initial_state,
        shape,
        output_key,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initial_state", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct Exit
{
    static constexpr const char* name = "Exit";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DeleteSessionTensor
{
    static constexpr const char* name = "DeleteSessionTensor";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ExperimentalNonSerializableDataset
{
    static constexpr const char* name = "ExperimentalNonSerializableDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct NextIteration
{
    static constexpr const char* name = "NextIteration";
    
    enum class Argument
    {
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OutfeedDequeueTuple
{
    static constexpr const char* name = "OutfeedDequeueTuple";
    
    enum class Argument
    {
        outputs
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes,
        shapes,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct LoopCond
{
    static constexpr const char* name = "LoopCond";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QuantizedDepthwiseConv2DWithBiasAndRelu
{
    static constexpr const char* name = "QuantizedDepthwiseConv2DWithBiasAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct Abort
{
    static constexpr const char* name = "Abort";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        error_msg,
        exit_without_error
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"error_msg", AttributeType::String},
        AttributeDesc{"exit_without_error", AttributeType::Bool}
    };
};

struct NonMaxSuppressionV3
{
    static constexpr const char* name = "NonMaxSuppressionV3";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        selected_indices
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iou_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"score_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        T_threshold
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"T_threshold", AttributeType::Type}
    };
};

struct DenseCountSparseOutput
{
    static constexpr const char* name = "DenseCountSparseOutput";
    
    enum class Argument
    {
        values,
        weights,
        output_indices,
        output_values,
        output_dense_shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dense_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        minlength,
        maxlength,
        binary_output,
        output_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"minlength", AttributeType::Int},
        AttributeDesc{"maxlength", AttributeType::Int},
        AttributeDesc{"binary_output", AttributeType::Bool},
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct OrderedMapSize
{
    static constexpr const char* name = "OrderedMapSize";
    
    enum class Argument
    {
        size
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct _MklQuantizedConv2DAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct ParseSingleSequenceExample
{
    static constexpr const char* name = "ParseSingleSequenceExample";
    
    enum class Argument
    {
        serialized,
        feature_list_dense_missing_assumed_empty,
        context_sparse_keys,
        context_dense_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        context_dense_defaults,
        debug_name,
        context_sparse_indices,
        context_sparse_values,
        context_sparse_shapes,
        context_dense_values,
        feature_list_sparse_indices,
        feature_list_sparse_values,
        feature_list_sparse_shapes,
        feature_list_dense_values
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 8;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_list_dense_missing_assumed_empty", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_sparse_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_dense_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_dense"},
        ArgumentDesc{"feature_list_sparse_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_dense_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_dense"},
        ArgumentDesc{"context_dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"debug_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "context_sparse_types"},
        ArgumentDesc{"context_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"feature_list_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_sparse_types"},
        ArgumentDesc{"feature_list_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_dense_types"}
    };

    enum class Attribute
    {
        Ncontext_sparse,
        Ncontext_dense,
        Nfeature_list_sparse,
        Nfeature_list_dense,
        context_sparse_types,
        Tcontext_dense,
        feature_list_dense_types,
        context_dense_shapes,
        feature_list_sparse_types,
        feature_list_dense_shapes
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Ncontext_sparse", AttributeType::Int},
        AttributeDesc{"Ncontext_dense", AttributeType::Int},
        AttributeDesc{"Nfeature_list_sparse", AttributeType::Int},
        AttributeDesc{"Nfeature_list_dense", AttributeType::Int},
        AttributeDesc{"context_sparse_types", AttributeType::ListType},
        AttributeDesc{"Tcontext_dense", AttributeType::ListType},
        AttributeDesc{"feature_list_dense_types", AttributeType::ListType},
        AttributeDesc{"context_dense_shapes", AttributeType::ListShape},
        AttributeDesc{"feature_list_sparse_types", AttributeType::ListType},
        AttributeDesc{"feature_list_dense_shapes", AttributeType::ListShape}
    };
};

struct SparseCountSparseOutput
{
    static constexpr const char* name = "SparseCountSparseOutput";
    
    enum class Argument
    {
        indices,
        values,
        dense_shape,
        weights,
        output_indices,
        output_values,
        output_dense_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dense_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        minlength,
        maxlength,
        binary_output,
        output_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"minlength", AttributeType::Int},
        AttributeDesc{"maxlength", AttributeType::Int},
        AttributeDesc{"binary_output", AttributeType::Bool},
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct BatchMatrixSolve
{
    static constexpr const char* name = "BatchMatrixSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AnonymousSeedGenerator
{
    static constexpr const char* name = "AnonymousSeedGenerator";
    
    enum class Argument
    {
        seed,
        seed2,
        reshuffle,
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reshuffle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QuantizedConv2DAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct CTCLoss
{
    static constexpr const char* name = "CTCLoss";
    
    enum class Argument
    {
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        loss,
        gradient
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"loss", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        preprocess_collapse_repeated,
        ctc_merge_repeated,
        ignore_longer_outputs_than_inputs,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"preprocess_collapse_repeated", AttributeType::Bool},
        AttributeDesc{"ctc_merge_repeated", AttributeType::Bool},
        AttributeDesc{"ignore_longer_outputs_than_inputs", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Sign
{
    static constexpr const char* name = "Sign";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BarrierTakeMany
{
    static constexpr const char* name = "BarrierTakeMany";
    
    enum class Argument
    {
        handle,
        num_elements,
        indices,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        allow_small_batch,
        wait_for_incomplete,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"allow_small_batch", AttributeType::Bool},
        AttributeDesc{"wait_for_incomplete", AttributeType::Bool},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct CTCLossV2
{
    static constexpr const char* name = "CTCLossV2";
    
    enum class Argument
    {
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        loss,
        gradient
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"loss", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        preprocess_collapse_repeated,
        ctc_merge_repeated,
        ignore_longer_outputs_than_inputs
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"preprocess_collapse_repeated", AttributeType::Bool},
        AttributeDesc{"ctc_merge_repeated", AttributeType::Bool},
        AttributeDesc{"ignore_longer_outputs_than_inputs", AttributeType::Bool}
    };
};

struct WholeFileReaderV2
{
    static constexpr const char* name = "WholeFileReaderV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct StatelessRandomUniformInt
{
    static constexpr const char* name = "StatelessRandomUniformInt";
    
    enum class Argument
    {
        shape,
        seed,
        minval,
        maxval,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct CTCGreedyDecoder
{
    static constexpr const char* name = "CTCGreedyDecoder";
    
    enum class Argument
    {
        inputs,
        sequence_length,
        decoded_indices,
        decoded_values,
        decoded_shape,
        log_probability
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sequence_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"decoded_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"decoded_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"decoded_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"log_probability", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        merge_repeated,
        blank_index,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"merge_repeated", AttributeType::Bool},
        AttributeDesc{"blank_index", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FixedLengthRecordDataset
{
    static constexpr const char* name = "FixedLengthRecordDataset";
    
    enum class Argument
    {
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"header_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"footer_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CudnnRNNParamsSize
{
    static constexpr const char* name = "CudnnRNNParamsSize";
    
    enum class Argument
    {
        num_layers,
        num_units,
        input_size,
        params_size
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"num_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_units", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params_size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        S,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        num_proj
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"num_proj", AttributeType::Int}
    };
};

struct ScaleAndTranslate
{
    static constexpr const char* name = "ScaleAndTranslate";
    
    enum class Argument
    {
        images,
        size,
        scale,
        translation,
        resized_images
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"translation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        kernel_type,
        antialias
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"kernel_type", AttributeType::String},
        AttributeDesc{"antialias", AttributeType::Bool}
    };
};

struct ConfigureTPUEmbedding
{
    static constexpr const char* name = "ConfigureTPUEmbedding";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        config
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"config", AttributeType::String}
    };
};

struct CudnnRNN
{
    static constexpr const char* name = "CudnnRNN";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        reserve_space
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        is_training
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct CudnnRNNV2
{
    static constexpr const char* name = "CudnnRNNV2";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        reserve_space,
        host_reserved
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"host_reserved", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2,
        is_training
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct BatchMatMul
{
    static constexpr const char* name = "BatchMatMul";
    
    enum class Argument
    {
        x,
        y,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        adj_x,
        adj_y
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"adj_x", AttributeType::Bool},
        AttributeDesc{"adj_y", AttributeType::Bool}
    };
};

struct CudnnRNNBackprop
{
    static constexpr const char* name = "CudnnRNNBackprop";
    
    enum class Argument
    {
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        input_backprop,
        input_h_backprop,
        input_c_backprop,
        params_backprop
    };

    static constexpr uint32_t input_arg_count = 11;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_h_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_c_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"params_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct CudnnRNNCanonicalToParams
{
    static constexpr const char* name = "CudnnRNNCanonicalToParams";
    
    enum class Argument
    {
        num_layers,
        num_units,
        input_size,
        weights,
        biases,
        params
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"num_layers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_units", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params"},
        ArgumentDesc{"biases", ArgumentDesc::TensorCount::SequenceAttrInt, "num_params"},
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_params,
        rnn_mode,
        input_mode,
        direction,
        dropout,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_params", AttributeType::Int},
        AttributeDesc{"rnn_mode", AttributeType::String},
        AttributeDesc{"input_mode", AttributeType::String},
        AttributeDesc{"direction", AttributeType::String},
        AttributeDesc{"dropout", AttributeType::Float},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct DynamicPartition
{
    static constexpr const char* name = "DynamicPartition";
    
    enum class Argument
    {
        data,
        partitions,
        outputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"partitions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_partitions"}
    };

    enum class Attribute
    {
        num_partitions,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_partitions", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ScatterNdUpdate
{
    static constexpr const char* name = "ScatterNdUpdate";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct RandomShuffleQueue
{
    static constexpr const char* name = "RandomShuffleQueue";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        min_after_dequeue,
        seed,
        seed2,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"min_after_dequeue", AttributeType::Int},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct XlaReduce
{
    static constexpr const char* name = "XlaReduce";
    
    enum class Argument
    {
        input,
        init_value,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"init_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        dimensions_to_reduce,
        reducer
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dimensions_to_reduce", AttributeType::ListInt},
        AttributeDesc{"reducer", AttributeType::Func}
    };
};

struct QuantizedMatMulWithBiasAndRequantize
{
    static constexpr const char* name = "QuantizedMatMulWithBiasAndRequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String}
    };
};

struct AccumulatorTakeGradient
{
    static constexpr const char* name = "AccumulatorTakeGradient";
    
    enum class Argument
    {
        handle,
        num_required,
        average
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_required", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"average", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct FIFOQueueV2
{
    static constexpr const char* name = "FIFOQueueV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct CompositeTensorVariantFromComponents
{
    static constexpr const char* name = "CompositeTensorVariantFromComponents";
    
    enum class Argument
    {
        components,
        encoded
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"},
        ArgumentDesc{"encoded", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        metadata,
        Tcomponents
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"metadata", AttributeType::String},
        AttributeDesc{"Tcomponents", AttributeType::ListType}
    };
};

struct ExperimentalScanDataset
{
    static constexpr const char* name = "ExperimentalScanDataset";
    
    enum class Argument
    {
        input_dataset,
        initial_state,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initial_state", ArgumentDesc::TensorCount::SequenceAttrList, "Tstate"},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Tstate,
        Targuments,
        output_types,
        output_shapes,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Tstate", AttributeType::ListType},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct MatrixExponential
{
    static constexpr const char* name = "MatrixExponential";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ApplyFtrlV2
{
    static constexpr const char* name = "ApplyFtrlV2";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_shrinkage", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct VarIsInitializedOp
{
    static constexpr const char* name = "VarIsInitializedOp";
    
    enum class Argument
    {
        resource,
        is_initialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_initialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct PaddingFIFOQueueV2
{
    static constexpr const char* name = "PaddingFIFOQueueV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct PriorityQueue
{
    static constexpr const char* name = "PriorityQueue";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        component_types,
        shapes,
        capacity,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Lu
{
    static constexpr const char* name = "Lu";
    
    enum class Argument
    {
        input,
        lu,
        p
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lu", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"p", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        output_idx_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"output_idx_type", AttributeType::Type}
    };
};

struct QueueEnqueue
{
    static constexpr const char* name = "QueueEnqueue";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"}
    };

    enum class Attribute
    {
        Tcomponents,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tcomponents", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct QueueEnqueueV2
{
    static constexpr const char* name = "QueueEnqueueV2";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"}
    };

    enum class Attribute
    {
        Tcomponents,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tcomponents", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct QueueEnqueueMany
{
    static constexpr const char* name = "QueueEnqueueMany";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"}
    };

    enum class Attribute
    {
        Tcomponents,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tcomponents", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct ReaderResetV2
{
    static constexpr const char* name = "ReaderResetV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QueueEnqueueManyV2
{
    static constexpr const char* name = "QueueEnqueueManyV2";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Tcomponents"}
    };

    enum class Attribute
    {
        Tcomponents,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tcomponents", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct QueueDequeue
{
    static constexpr const char* name = "QueueDequeue";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct RandomDataset
{
    static constexpr const char* name = "RandomDataset";
    
    enum class Argument
    {
        seed,
        seed2,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct UnsortedSegmentMax
{
    static constexpr const char* name = "UnsortedSegmentMax";
    
    enum class Argument
    {
        data,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        Tnumsegments
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type}
    };
};

struct QueueDequeueV2
{
    static constexpr const char* name = "QueueDequeueV2";
    
    enum class Argument
    {
        handle,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct RetrieveTPUEmbeddingFTRLParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingFTRLParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        linears
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linears", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct MultiDeviceIteratorGetNextFromShard
{
    static constexpr const char* name = "MultiDeviceIteratorGetNextFromShard";
    
    enum class Argument
    {
        multi_device_iterator,
        shard_num,
        incarnation_id,
        components
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"multi_device_iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shard_num", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"incarnation_id", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct QueueDequeueMany
{
    static constexpr const char* name = "QueueDequeueMany";
    
    enum class Argument
    {
        handle,
        n,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"n", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "component_types"}
    };

    enum class Attribute
    {
        component_types,
        timeout_ms
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"component_types", AttributeType::ListType},
        AttributeDesc{"timeout_ms", AttributeType::Int}
    };
};

struct QueueIsClosed
{
    static constexpr const char* name = "QueueIsClosed";
    
    enum class Argument
    {
        handle,
        is_closed
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_closed", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct QueueSize
{
    static constexpr const char* name = "QueueSize";
    
    enum class Argument
    {
        handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AccumulatorNumAccumulated
{
    static constexpr const char* name = "AccumulatorNumAccumulated";
    
    enum class Argument
    {
        handle,
        num_accumulated
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_accumulated", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SegmentProd
{
    static constexpr const char* name = "SegmentProd";
    
    enum class Argument
    {
        data,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct _MklConv3D
{
    static constexpr const char* name = "_MklConv3D";
    
    enum class Argument
    {
        input,
        filter,
        mkl_input,
        mkl_filter,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct MatchingFilesDataset
{
    static constexpr const char* name = "MatchingFilesDataset";
    
    enum class Argument
    {
        patterns,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"patterns", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SaveSlices
{
    static constexpr const char* name = "SaveSlices";
    
    enum class Argument
    {
        filename,
        tensor_names,
        shapes_and_slices,
        data
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shapes_and_slices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct StringFormat
{
    static constexpr const char* name = "StringFormat";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        template_,
        placeholder,
        summarize
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"template", AttributeType::String},
        AttributeDesc{"placeholder", AttributeType::String},
        AttributeDesc{"summarize", AttributeType::Int}
    };
};

struct SparseConditionalAccumulator
{
    static constexpr const char* name = "SparseConditionalAccumulator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        container,
        shared_name,
        reduction_type
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"reduction_type", AttributeType::String}
    };
};

struct GreaterEqual
{
    static constexpr const char* name = "GreaterEqual";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatelessRandomPoisson
{
    static constexpr const char* name = "StatelessRandomPoisson";
    
    enum class Argument
    {
        shape,
        seed,
        lam,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lam", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Rtype,
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Rtype", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct SparseAccumulatorApplyGradient
{
    static constexpr const char* name = "SparseAccumulatorApplyGradient";
    
    enum class Argument
    {
        handle,
        local_step,
        gradient_indices,
        gradient_values,
        gradient_shape
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"local_step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        has_known_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"has_known_shape", AttributeType::Bool}
    };
};

struct ResourceScatterNdAdd
{
    static constexpr const char* name = "ResourceScatterNdAdd";
    
    enum class Argument
    {
        ref,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct SparseAccumulatorTakeGradient
{
    static constexpr const char* name = "SparseAccumulatorTakeGradient";
    
    enum class Argument
    {
        handle,
        num_required,
        indices,
        values,
        shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_required", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct RepeatDataset
{
    static constexpr const char* name = "RepeatDataset";
    
    enum class Argument
    {
        input_dataset,
        count,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct StackPopV2
{
    static constexpr const char* name = "StackPopV2";
    
    enum class Argument
    {
        handle,
        elem
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"elem", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        elem_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"elem_type", AttributeType::Type}
    };
};

struct StatelessSampleDistortedBoundingBox
{
    static constexpr const char* name = "StatelessSampleDistortedBoundingBox";
    
    enum class Argument
    {
        image_size,
        bounding_boxes,
        min_object_covered,
        seed,
        begin,
        size,
        bboxes
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bounding_boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_object_covered", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"begin", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bboxes", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tseed,
        aspect_ratio_range,
        area_range,
        max_attempts,
        use_image_if_no_bounding_boxes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type},
        AttributeDesc{"aspect_ratio_range", AttributeType::ListFloat},
        AttributeDesc{"area_range", AttributeType::ListFloat},
        AttributeDesc{"max_attempts", AttributeType::Int},
        AttributeDesc{"use_image_if_no_bounding_boxes", AttributeType::Bool}
    };
};

struct StackCloseV2
{
    static constexpr const char* name = "StackCloseV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct GroupByWindowDataset
{
    static constexpr const char* name = "GroupByWindowDataset";
    
    enum class Argument
    {
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tkey_func_other_arguments"},
        ArgumentDesc{"reduce_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Treduce_func_other_arguments"},
        ArgumentDesc{"window_size_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Twindow_size_func_other_arguments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_func,
        reduce_func,
        window_size_func,
        Tkey_func_other_arguments,
        Treduce_func_other_arguments,
        Twindow_size_func_other_arguments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"key_func", AttributeType::Func},
        AttributeDesc{"reduce_func", AttributeType::Func},
        AttributeDesc{"window_size_func", AttributeType::Func},
        AttributeDesc{"Tkey_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Treduce_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Twindow_size_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Stack
{
    static constexpr const char* name = "Stack";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        elem_type,
        stack_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"elem_type", AttributeType::Type},
        AttributeDesc{"stack_name", AttributeType::String}
    };
};

struct TensorArrayV3
{
    static constexpr const char* name = "TensorArrayV3";
    
    enum class Argument
    {
        size,
        handle,
        flow
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape,
        dynamic_size,
        clear_after_read,
        identical_element_shapes,
        tensor_array_name
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape},
        AttributeDesc{"dynamic_size", AttributeType::Bool},
        AttributeDesc{"clear_after_read", AttributeType::Bool},
        AttributeDesc{"identical_element_shapes", AttributeType::Bool},
        AttributeDesc{"tensor_array_name", AttributeType::String}
    };
};

struct XlaSpmdShardToFullShape
{
    static constexpr const char* name = "XlaSpmdShardToFullShape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        manual_sharding,
        full_shape,
        dim,
        unspecified_dims
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"manual_sharding", AttributeType::String},
        AttributeDesc{"full_shape", AttributeType::Shape},
        AttributeDesc{"dim", AttributeType::Int},
        AttributeDesc{"unspecified_dims", AttributeType::ListInt}
    };
};

struct TensorArrayWriteV3
{
    static constexpr const char* name = "TensorArrayWriteV3";
    
    enum class Argument
    {
        handle,
        index,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayReadV3
{
    static constexpr const char* name = "TensorArrayReadV3";
    
    enum class Argument
    {
        handle,
        index,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct ShuffleDatasetV3
{
    static constexpr const char* name = "ShuffleDatasetV3";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        seed,
        seed2,
        seed_generator,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed_generator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reshuffle_each_iteration,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"reshuffle_each_iteration", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TensorArrayGatherV3
{
    static constexpr const char* name = "TensorArrayGatherV3";
    
    enum class Argument
    {
        handle,
        indices,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct DebugNumericSummaryV2
{
    static constexpr const char* name = "DebugNumericSummaryV2";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_dtype,
        T,
        tensor_debug_mode,
        tensor_id
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"output_dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_debug_mode", AttributeType::Int},
        AttributeDesc{"tensor_id", AttributeType::Int}
    };
};

struct BarrierReadySize
{
    static constexpr const char* name = "BarrierReadySize";
    
    enum class Argument
    {
        handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorArrayScatterV3
{
    static constexpr const char* name = "TensorArrayScatterV3";
    
    enum class Argument
    {
        handle,
        indices,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayV2
{
    static constexpr const char* name = "TensorArrayV2";
    
    enum class Argument
    {
        size,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape,
        dynamic_size,
        clear_after_read,
        tensor_array_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape},
        AttributeDesc{"dynamic_size", AttributeType::Bool},
        AttributeDesc{"clear_after_read", AttributeType::Bool},
        AttributeDesc{"tensor_array_name", AttributeType::String}
    };
};

struct AvgPoolGrad
{
    static constexpr const char* name = "AvgPoolGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayGradV2
{
    static constexpr const char* name = "TensorArrayGradV2";
    
    enum class Argument
    {
        handle,
        flow_in,
        grad_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        source
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"source", AttributeType::String}
    };
};

struct ScanDataset
{
    static constexpr const char* name = "ScanDataset";
    
    enum class Argument
    {
        input_dataset,
        initial_state,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initial_state", ArgumentDesc::TensorCount::SequenceAttrList, "Tstate"},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Tstate,
        Targuments,
        output_types,
        output_shapes,
        preserve_cardinality,
        use_default_device
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Tstate", AttributeType::ListType},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool},
        AttributeDesc{"use_default_device", AttributeType::Bool}
    };
};

struct ExperimentalUnbatchDataset
{
    static constexpr const char* name = "ExperimentalUnbatchDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RecordInput
{
    static constexpr const char* name = "RecordInput";
    
    enum class Argument
    {
        records
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"records", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        file_pattern,
        file_random_seed,
        file_shuffle_shift_ratio,
        file_buffer_size,
        file_parallelism,
        batch_size,
        compression_type
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"file_pattern", AttributeType::String},
        AttributeDesc{"file_random_seed", AttributeType::Int},
        AttributeDesc{"file_shuffle_shift_ratio", AttributeType::Float},
        AttributeDesc{"file_buffer_size", AttributeType::Int},
        AttributeDesc{"file_parallelism", AttributeType::Int},
        AttributeDesc{"batch_size", AttributeType::Int},
        AttributeDesc{"compression_type", AttributeType::String}
    };
};

struct TensorArrayWrite
{
    static constexpr const char* name = "TensorArrayWrite";
    
    enum class Argument
    {
        handle,
        index,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayRead
{
    static constexpr const char* name = "TensorArrayRead";
    
    enum class Argument
    {
        handle,
        index,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct SegmentSum
{
    static constexpr const char* name = "SegmentSum";
    
    enum class Argument
    {
        data,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct Floor
{
    static constexpr const char* name = "Floor";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeAvgPool
{
    static constexpr const char* name = "_MklNativeAvgPool";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorArrayReadV2
{
    static constexpr const char* name = "TensorArrayReadV2";
    
    enum class Argument
    {
        handle,
        index,
        flow_in,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct SparseReshape
{
    static constexpr const char* name = "SparseReshape";
    
    enum class Argument
    {
        input_indices,
        input_shape,
        new_shape,
        output_indices,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"new_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorArrayScatter
{
    static constexpr const char* name = "TensorArrayScatter";
    
    enum class Argument
    {
        handle,
        indices,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FusedBatchNormV3
{
    static constexpr const char* name = "FusedBatchNormV3";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        exponential_avg_factor,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct TensorArrayScatterV2
{
    static constexpr const char* name = "TensorArrayScatterV2";
    
    enum class Argument
    {
        handle,
        indices,
        value,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LoadTPUEmbeddingAdagradMomentumParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingAdagradMomentumParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        momenta
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct OrderedMapClear
{
    static constexpr const char* name = "OrderedMapClear";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorArrayConcatV2
{
    static constexpr const char* name = "TensorArrayConcatV2";
    
    enum class Argument
    {
        handle,
        flow_in,
        value,
        lengths
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        element_shape_except0
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"element_shape_except0", AttributeType::Shape}
    };
};

struct SetStatsAggregatorDataset
{
    static constexpr const char* name = "SetStatsAggregatorDataset";
    
    enum class Argument
    {
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_aggregator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter_prefix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SqrtGrad
{
    static constexpr const char* name = "SqrtGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPoolV2
{
    static constexpr const char* name = "MaxPoolV2";
    
    enum class Argument
    {
        input,
        ksize,
        strides,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ksize", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        padding,
        data_format
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct TensorArraySplitV2
{
    static constexpr const char* name = "TensorArraySplitV2";
    
    enum class Argument
    {
        handle,
        value,
        lengths,
        flow_in,
        flow_out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct IteratorGetNextAsOptional
{
    static constexpr const char* name = "IteratorGetNextAsOptional";
    
    enum class Argument
    {
        iterator,
        optional
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"optional", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SparseMatrixSparseMatMul
{
    static constexpr const char* name = "SparseMatrixSparseMatMul";
    
    enum class Argument
    {
        a,
        b,
        c
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type,
        transpose_a,
        transpose_b,
        adjoint_a,
        adjoint_b
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"adjoint_a", AttributeType::Bool},
        AttributeDesc{"adjoint_b", AttributeType::Bool}
    };
};

struct TensorArraySize
{
    static constexpr const char* name = "TensorArraySize";
    
    enum class Argument
    {
        handle,
        flow_in,
        size
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorArraySizeV2
{
    static constexpr const char* name = "TensorArraySizeV2";
    
    enum class Argument
    {
        handle,
        flow_in,
        size
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"flow_in", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorArrayCloseV2
{
    static constexpr const char* name = "TensorArrayCloseV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BarrierClose
{
    static constexpr const char* name = "BarrierClose";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        cancel_pending_enqueues
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"cancel_pending_enqueues", AttributeType::Bool}
    };
};

struct BarrierIncompleteSize
{
    static constexpr const char* name = "BarrierIncompleteSize";
    
    enum class Argument
    {
        handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct GetSessionHandleV2
{
    static constexpr const char* name = "GetSessionHandleV2";
    
    enum class Argument
    {
        value,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct WorkerHeartbeat
{
    static constexpr const char* name = "WorkerHeartbeat";
    
    enum class Argument
    {
        request,
        response
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"request", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"response", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Stage
{
    static constexpr const char* name = "Stage";
    
    enum class Argument
    {
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct Select
{
    static constexpr const char* name = "Select";
    
    enum class Argument
    {
        condition,
        t,
        e,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"condition", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Unstage
{
    static constexpr const char* name = "Unstage";
    
    enum class Argument
    {
        values
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct StagePeek
{
    static constexpr const char* name = "StagePeek";
    
    enum class Argument
    {
        index,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct StageSize
{
    static constexpr const char* name = "StageSize";
    
    enum class Argument
    {
        size
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct MapStage
{
    static constexpr const char* name = "MapStage";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "fake_dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        fake_dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"fake_dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct RaggedGather
{
    static constexpr const char* name = "RaggedGather";
    
    enum class Argument
    {
        params_nested_splits,
        params_dense_values,
        indices,
        output_nested_splits,
        output_dense_values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"params_nested_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "PARAMS_RAGGED_RANK"},
        ArgumentDesc{"params_dense_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_nested_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "OUTPUT_RAGGED_RANK"},
        ArgumentDesc{"output_dense_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tvalues,
        Tindices,
        Tsplits,
        PARAMS_RAGGED_RANK,
        OUTPUT_RAGGED_RANK
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Tvalues", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type},
        AttributeDesc{"PARAMS_RAGGED_RANK", AttributeType::Int},
        AttributeDesc{"OUTPUT_RAGGED_RANK", AttributeType::Int}
    };
};

struct MapUnstage
{
    static constexpr const char* name = "MapUnstage";
    
    enum class Argument
    {
        key,
        indices,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct MapUnstageNoKey
{
    static constexpr const char* name = "MapUnstageNoKey";
    
    enum class Argument
    {
        indices,
        key,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct XlaKeyValueSort
{
    static constexpr const char* name = "XlaKeyValueSort";
    
    enum class Argument
    {
        keys,
        values,
        sorted_keys,
        sorted_values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sorted_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sorted_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        K,
        V
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"K", AttributeType::Type},
        AttributeDesc{"V", AttributeType::Type}
    };
};

struct SleepDataset
{
    static constexpr const char* name = "SleepDataset";
    
    enum class Argument
    {
        input_dataset,
        sleep_microseconds,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sleep_microseconds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct MapSize
{
    static constexpr const char* name = "MapSize";
    
    enum class Argument
    {
        size
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct MapClear
{
    static constexpr const char* name = "MapClear";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct OrderedMapIncompleteSize
{
    static constexpr const char* name = "OrderedMapIncompleteSize";
    
    enum class Argument
    {
        size
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        capacity,
        memory_limit,
        dtypes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"capacity", AttributeType::Int},
        AttributeDesc{"memory_limit", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorSliceDataset
{
    static constexpr const char* name = "TensorSliceDataset";
    
    enum class Argument
    {
        components,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Toutput_types"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Toutput_types,
        output_shapes,
        is_files
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Toutput_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"is_files", AttributeType::Bool}
    };
};

struct TensorMapStackKeys
{
    static constexpr const char* name = "TensorMapStackKeys";
    
    enum class Argument
    {
        input_handle,
        keys
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"key_dtype", AttributeType::Type}
    };
};

struct ZipDataset
{
    static constexpr const char* name = "ZipDataset";
    
    enum class Argument
    {
        input_datasets,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_datasets", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct MultiDeviceIteratorInit
{
    static constexpr const char* name = "MultiDeviceIteratorInit";
    
    enum class Argument
    {
        dataset,
        multi_device_iterator,
        max_buffer_size,
        incarnation_id
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"multi_device_iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"incarnation_id", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ResourceSparseApplyAdagradDA
{
    static constexpr const char* name = "ResourceSparseApplyAdagradDA";
    
    enum class Argument
    {
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_squared_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"global_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct Expm1
{
    static constexpr const char* name = "Expm1";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Conv3DBackpropInputV2
{
    static constexpr const char* name = "Conv3DBackpropInputV2";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        dilations,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct PrefetchDataset
{
    static constexpr const char* name = "PrefetchDataset";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        slack_period,
        legacy_autotune,
        buffer_size_min
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"slack_period", AttributeType::Int},
        AttributeDesc{"legacy_autotune", AttributeType::Bool},
        AttributeDesc{"buffer_size_min", AttributeType::Int}
    };
};

struct ParseExampleDatasetV2
{
    static constexpr const char* name = "ParseExampleDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sparse_keys,
        dense_keys,
        sparse_types,
        Tdense,
        dense_shapes,
        output_types,
        output_shapes,
        deterministic,
        ragged_keys,
        ragged_value_types,
        ragged_split_types
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"sparse_keys", AttributeType::ListString},
        AttributeDesc{"dense_keys", AttributeType::ListString},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"deterministic", AttributeType::String},
        AttributeDesc{"ragged_keys", AttributeType::ListString},
        AttributeDesc{"ragged_value_types", AttributeType::ListType},
        AttributeDesc{"ragged_split_types", AttributeType::ListType}
    };
};

struct ParallelInterleaveDatasetV2
{
    static constexpr const char* name = "ParallelInterleaveDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        sloppy
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"sloppy", AttributeType::Bool}
    };
};

struct ParallelInterleaveDatasetV4
{
    static constexpr const char* name = "ParallelInterleaveDatasetV4";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        num_parallel_calls,
        handle
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_output_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"prefetch_input_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        deterministic,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"deterministic", AttributeType::String},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct WindowOp
{
    static constexpr const char* name = "WindowOp";
    
    enum class Argument
    {
        inputs,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        Tinputs
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"Tinputs", AttributeType::ListType}
    };
};

struct DeleteRandomSeedGenerator
{
    static constexpr const char* name = "DeleteRandomSeedGenerator";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BatchDataset
{
    static constexpr const char* name = "BatchDataset";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct PaddedBatchDatasetV2
{
    static constexpr const char* name = "PaddedBatchDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padded_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"padding_values", ArgumentDesc::TensorCount::SequenceAttrList, "Toutput_types"},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        parallel_copy,
        Toutput_types,
        output_shapes,
        N
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"parallel_copy", AttributeType::Bool},
        AttributeDesc{"Toutput_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct DeleteSeedGenerator
{
    static constexpr const char* name = "DeleteSeedGenerator";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SaveDataset
{
    static constexpr const char* name = "SaveDataset";
    
    enum class Argument
    {
        input_dataset,
        path,
        shard_func_other_args
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shard_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tshard_func_args"}
    };

    enum class Attribute
    {
        compression,
        shard_func,
        use_shard_func,
        Tshard_func_args
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"shard_func", AttributeType::Func},
        AttributeDesc{"use_shard_func", AttributeType::Bool},
        AttributeDesc{"Tshard_func_args", AttributeType::ListType}
    };
};

struct DummySeedGenerator
{
    static constexpr const char* name = "DummySeedGenerator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ResizeArea
{
    static constexpr const char* name = "ResizeArea";
    
    enum class Argument
    {
        images,
        size,
        resized_images
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resized_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool}
    };
};

struct _MklQuantizedConv2DWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct ShuffleAndRepeatDataset
{
    static constexpr const char* name = "ShuffleAndRepeatDataset";
    
    enum class Argument
    {
        input_dataset,
        buffer_size,
        seed,
        seed2,
        count,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        reshuffle_each_iteration
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"reshuffle_each_iteration", AttributeType::Bool}
    };
};

struct OptionalGetValue
{
    static constexpr const char* name = "OptionalGetValue";
    
    enum class Argument
    {
        optional,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"optional", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ResourceApplyProximalGradientDescent
{
    static constexpr const char* name = "ResourceApplyProximalGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        l1,
        l2,
        delta
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct DeleteMemoryCache
{
    static constexpr const char* name = "DeleteMemoryCache";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklQuantizedConcatV2
{
    static constexpr const char* name = "_MklQuantizedConcatV2";
    
    enum class Argument
    {
        values,
        axis,
        input_mins,
        input_maxes,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_mins", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"input_maxes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct ResourceScatterNdMax
{
    static constexpr const char* name = "ResourceScatterNdMax";
    
    enum class Argument
    {
        ref,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct CacheDataset
{
    static constexpr const char* name = "CacheDataset";
    
    enum class Argument
    {
        input_dataset,
        filename,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TextLineDataset
{
    static constexpr const char* name = "TextLineDataset";
    
    enum class Argument
    {
        filenames,
        compression_type,
        buffer_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TFRecordDataset
{
    static constexpr const char* name = "TFRecordDataset";
    
    enum class Argument
    {
        filenames,
        compression_type,
        buffer_size,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderReadUpTo
{
    static constexpr const char* name = "ReaderReadUpTo";
    
    enum class Argument
    {
        reader_handle,
        queue_handle,
        num_records,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"queue_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_records", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SobolSample
{
    static constexpr const char* name = "SobolSample";
    
    enum class Argument
    {
        dim,
        num_results,
        skip,
        samples
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_results", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"skip", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"samples", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct Iterator
{
    static constexpr const char* name = "Iterator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shared_name,
        container,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct MutexLock
{
    static constexpr const char* name = "MutexLock";
    
    enum class Argument
    {
        mutex,
        mutex_lock
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"mutex", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mutex_lock", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct IteratorV2
{
    static constexpr const char* name = "IteratorV2";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shared_name,
        container,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct TPUCompileSucceededAssert
{
    static constexpr const char* name = "TPUCompileSucceededAssert";
    
    enum class Argument
    {
        compilation_status
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"compilation_status", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AnonymousIteratorV2
{
    static constexpr const char* name = "AnonymousIteratorV2";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct DeleteIterator
{
    static constexpr const char* name = "DeleteIterator";
    
    enum class Argument
    {
        handle,
        deleter
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DeleteMultiDeviceIterator
{
    static constexpr const char* name = "DeleteMultiDeviceIterator";
    
    enum class Argument
    {
        multi_device_iterator,
        iterators,
        deleter
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"multi_device_iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iterators", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"deleter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct MakeIterator
{
    static constexpr const char* name = "MakeIterator";
    
    enum class Argument
    {
        dataset,
        iterator
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReduceDataset
{
    static constexpr const char* name = "ReduceDataset";
    
    enum class Argument
    {
        input_dataset,
        initial_state,
        other_arguments,
        components
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"initial_state", ArgumentDesc::TensorCount::SequenceAttrList, "Tstate"},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        f,
        Tstate,
        Targuments,
        output_types,
        output_shapes,
        use_inter_op_parallelism
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Tstate", AttributeType::ListType},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_inter_op_parallelism", AttributeType::Bool}
    };
};

struct MaxPoolGradWithArgmax
{
    static constexpr const char* name = "MaxPoolGradWithArgmax";
    
    enum class Argument
    {
        input,
        grad,
        argmax,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"argmax", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        include_batch_in_index,
        Targmax,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"include_batch_in_index", AttributeType::Bool},
        AttributeDesc{"Targmax", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OneShotIterator
{
    static constexpr const char* name = "OneShotIterator";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dataset_factory,
        output_types,
        output_shapes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"dataset_factory", AttributeType::Func},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct IteratorGetNextSync
{
    static constexpr const char* name = "IteratorGetNextSync";
    
    enum class Argument
    {
        iterator,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RGBToHSV
{
    static constexpr const char* name = "RGBToHSV";
    
    enum class Argument
    {
        images,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DatasetToSingleElement
{
    static constexpr const char* name = "DatasetToSingleElement";
    
    enum class Argument
    {
        dataset,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct IteratorToStringHandle
{
    static constexpr const char* name = "IteratorToStringHandle";
    
    enum class Argument
    {
        resource_handle,
        string_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"string_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct IteratorFromStringHandle
{
    static constexpr const char* name = "IteratorFromStringHandle";
    
    enum class Argument
    {
        string_handle,
        resource_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"string_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resource_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct QuantizedConv2DPerChannel
{
    static constexpr const char* name = "QuantizedConv2DPerChannel";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct LatencyStatsDataset
{
    static constexpr const char* name = "LatencyStatsDataset";
    
    enum class Argument
    {
        input_dataset,
        tag,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct KthOrderStatistic
{
    static constexpr const char* name = "KthOrderStatistic";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        k
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"k", AttributeType::Int}
    };
};

struct IteratorFromStringHandleV2
{
    static constexpr const char* name = "IteratorFromStringHandleV2";
    
    enum class Argument
    {
        string_handle,
        resource_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"string_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"resource_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct DeserializeIterator
{
    static constexpr const char* name = "DeserializeIterator";
    
    enum class Argument
    {
        resource_handle,
        serialized
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DatasetToGraph
{
    static constexpr const char* name = "DatasetToGraph";
    
    enum class Argument
    {
        input_dataset,
        graph
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"graph", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        stateful_whitelist,
        allow_stateful,
        strip_device_assignment
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"stateful_whitelist", AttributeType::ListString},
        AttributeDesc{"allow_stateful", AttributeType::Bool},
        AttributeDesc{"strip_device_assignment", AttributeType::Bool}
    };
};

struct CopyHost
{
    static constexpr const char* name = "CopyHost";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name,
        debug_ops_spec
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"debug_ops_spec", AttributeType::ListString}
    };
};

struct RiscCholesky
{
    static constexpr const char* name = "RiscCholesky";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklLRN
{
    static constexpr const char* name = "_MklLRN";
    
    enum class Argument
    {
        input,
        mkl_input,
        output,
        workspace,
        mkl_output,
        mkl_workspace
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        depth_radius,
        bias,
        alpha,
        beta,
        workspace_enabled,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"depth_radius", AttributeType::Int},
        AttributeDesc{"bias", AttributeType::Float},
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"beta", AttributeType::Float},
        AttributeDesc{"workspace_enabled", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DatasetToGraphV2
{
    static constexpr const char* name = "DatasetToGraphV2";
    
    enum class Argument
    {
        input_dataset,
        graph
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"graph", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        external_state_policy,
        strip_device_assignment
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"external_state_policy", AttributeType::Int},
        AttributeDesc{"strip_device_assignment", AttributeType::Bool}
    };
};

struct ExperimentalLMDBDataset
{
    static constexpr const char* name = "ExperimentalLMDBDataset";
    
    enum class Argument
    {
        filenames,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct BatchMatrixTriangularSolve
{
    static constexpr const char* name = "BatchMatrixTriangularSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        lower,
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"lower", AttributeType::Bool},
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OptimizeDataset
{
    static constexpr const char* name = "OptimizeDataset";
    
    enum class Argument
    {
        input_dataset,
        optimizations,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"optimizations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        optimization_configs
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"optimization_configs", AttributeType::ListString}
    };
};

struct RiscRem
{
    static constexpr const char* name = "RiscRem";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct OptimizeDatasetV2
{
    static constexpr const char* name = "OptimizeDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        optimizations_enabled,
        optimizations_disabled,
        optimizations_default,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"optimizations_enabled", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"optimizations_disabled", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"optimizations_default", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        optimization_configs
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"optimization_configs", AttributeType::ListString}
    };
};

struct NotEqual
{
    static constexpr const char* name = "NotEqual";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        incompatible_shape_error
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"incompatible_shape_error", AttributeType::Bool}
    };
};

struct LinSpace
{
    static constexpr const char* name = "LinSpace";
    
    enum class Argument
    {
        start,
        stop,
        num,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct OptionalFromValue
{
    static constexpr const char* name = "OptionalFromValue";
    
    enum class Argument
    {
        components,
        optional
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "Toutput_types"},
        ArgumentDesc{"optional", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Toutput_types
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Toutput_types", AttributeType::ListType}
    };
};

struct OptionalNone
{
    static constexpr const char* name = "OptionalNone";
    
    enum class Argument
    {
        optional
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"optional", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ExperimentalSqlDataset
{
    static constexpr const char* name = "ExperimentalSqlDataset";
    
    enum class Argument
    {
        driver_name,
        data_source_name,
        query,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"driver_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data_source_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"query", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct StringUpper
{
    static constexpr const char* name = "StringUpper";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        encoding
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"encoding", AttributeType::String}
    };
};

struct OptionalHasValue
{
    static constexpr const char* name = "OptionalHasValue";
    
    enum class Argument
    {
        optional,
        has_value
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"optional", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"has_value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SnapshotDatasetReader
{
    static constexpr const char* name = "SnapshotDatasetReader";
    
    enum class Argument
    {
        shard_dir,
        start_index,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shard_dir", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"start_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        compression,
        version
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"version", AttributeType::Int}
    };
};

struct IdentityReader
{
    static constexpr const char* name = "IdentityReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct WrapDatasetVariant
{
    static constexpr const char* name = "WrapDatasetVariant";
    
    enum class Argument
    {
        input_handle,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StatelessMultinomial
{
    static constexpr const char* name = "StatelessMultinomial";
    
    enum class Argument
    {
        logits,
        num_samples,
        seed,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_samples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tseed,
        output_dtype
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type},
        AttributeDesc{"output_dtype", AttributeType::Type}
    };
};

struct MultiDeviceIteratorToStringHandle
{
    static constexpr const char* name = "MultiDeviceIteratorToStringHandle";
    
    enum class Argument
    {
        multi_device_iterator,
        string_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"multi_device_iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"string_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RiscExp
{
    static constexpr const char* name = "RiscExp";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MultiDeviceIteratorFromStringHandle
{
    static constexpr const char* name = "MultiDeviceIteratorFromStringHandle";
    
    enum class Argument
    {
        string_handle,
        multi_device_iterator
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"string_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"multi_device_iterator", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _MklQuantizedMatMulWithBiasAndDequantize
{
    static constexpr const char* name = "_MklQuantizedMatMulWithBiasAndDequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode,
        is_weight_const
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String},
        AttributeDesc{"is_weight_const", AttributeType::Bool}
    };
};

struct UnicodeScript
{
    static constexpr const char* name = "UnicodeScript";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct OptionsDataset
{
    static constexpr const char* name = "OptionsDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        serialized_options,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"serialized_options", AttributeType::String},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Timestamp
{
    static constexpr const char* name = "Timestamp";
    
    enum class Argument
    {
        ts
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ts", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct GetOptions
{
    static constexpr const char* name = "GetOptions";
    
    enum class Argument
    {
        input_dataset,
        serialized_options
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized_options", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct LMDBReader
{
    static constexpr const char* name = "LMDBReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct FinalizeDataset
{
    static constexpr const char* name = "FinalizeDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        has_captured_ref,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"has_captured_ref", AttributeType::Bool},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RFFT3D
{
    static constexpr const char* name = "RFFT3D";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct Copy
{
    static constexpr const char* name = "Copy";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name,
        debug_ops_spec
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"debug_ops_spec", AttributeType::ListString}
    };
};

struct DebugIdentityV2
{
    static constexpr const char* name = "DebugIdentityV2";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tfdbg_context_id,
        op_name,
        output_slot,
        tensor_debug_mode,
        debug_urls,
        circular_buffer_size,
        tfdbg_run_id
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tfdbg_context_id", AttributeType::String},
        AttributeDesc{"op_name", AttributeType::String},
        AttributeDesc{"output_slot", AttributeType::Int},
        AttributeDesc{"tensor_debug_mode", AttributeType::Int},
        AttributeDesc{"debug_urls", AttributeType::ListString},
        AttributeDesc{"circular_buffer_size", AttributeType::Int},
        AttributeDesc{"tfdbg_run_id", AttributeType::String}
    };
};

struct StatsAggregatorSummary
{
    static constexpr const char* name = "StatsAggregatorSummary";
    
    enum class Argument
    {
        iterator,
        summary
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"iterator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct EncodeProto
{
    static constexpr const char* name = "EncodeProto";
    
    enum class Argument
    {
        sizes,
        values,
        bytes
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "Tinput_types"},
        ArgumentDesc{"bytes", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        field_names,
        message_type,
        descriptor_source,
        Tinput_types
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"field_names", AttributeType::ListString},
        AttributeDesc{"message_type", AttributeType::String},
        AttributeDesc{"descriptor_source", AttributeType::String},
        AttributeDesc{"Tinput_types", AttributeType::ListType}
    };
};

struct AssertNextDataset
{
    static constexpr const char* name = "AssertNextDataset";
    
    enum class Argument
    {
        input_dataset,
        transformations,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transformations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RandomCrop
{
    static constexpr const char* name = "RandomCrop";
    
    enum class Argument
    {
        image,
        size,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        seed,
        seed2
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int}
    };
};

struct ExperimentalAssertNextDataset
{
    static constexpr const char* name = "ExperimentalAssertNextDataset";
    
    enum class Argument
    {
        input_dataset,
        transformations,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transformations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct IsotonicRegression
{
    static constexpr const char* name = "IsotonicRegression";
    
    enum class Argument
    {
        input,
        output,
        segments
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segments", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        output_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"output_dtype", AttributeType::Type}
    };
};

struct AutoShardDataset
{
    static constexpr const char* name = "AutoShardDataset";
    
    enum class Argument
    {
        input_dataset,
        num_workers,
        index,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_workers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        auto_shard_policy,
        output_types,
        output_shapes,
        num_replicas
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"auto_shard_policy", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"num_replicas", AttributeType::Int}
    };
};

struct ExperimentalAutoShardDataset
{
    static constexpr const char* name = "ExperimentalAutoShardDataset";
    
    enum class Argument
    {
        input_dataset,
        num_workers,
        index,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_workers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        auto_shard_policy,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"auto_shard_policy", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalBytesProducedStatsDataset
{
    static constexpr const char* name = "ExperimentalBytesProducedStatsDataset";
    
    enum class Argument
    {
        input_dataset,
        tag,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _MklNativeConv3DBackpropInputV2
{
    static constexpr const char* name = "_MklNativeConv3DBackpropInputV2";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        dilations,
        Tshape,
        padding,
        data_format
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tshape", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct ExperimentalIgnoreErrorsDataset
{
    static constexpr const char* name = "ExperimentalIgnoreErrorsDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        log_warning
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"log_warning", AttributeType::Bool}
    };
};

struct ChooseFastestBranchDataset
{
    static constexpr const char* name = "ChooseFastestBranchDataset";
    
    enum class Argument
    {
        input_dataset,
        ratio_numerator,
        ratio_denominator,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ratio_numerator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ratio_denominator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Targuments,
        num_elements_per_branch,
        branches,
        other_arguments_lengths,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"num_elements_per_branch", AttributeType::Int},
        AttributeDesc{"branches", AttributeType::ListFunc},
        AttributeDesc{"other_arguments_lengths", AttributeType::ListInt},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct GRUBlockCell
{
    static constexpr const char* name = "GRUBlockCell";
    
    enum class Argument
    {
        x,
        h_prev,
        w_ru,
        w_c,
        b_ru,
        b_c,
        r,
        u,
        c,
        h
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_ru", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_ru", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"u", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExperimentalChooseFastestDataset
{
    static constexpr const char* name = "ExperimentalChooseFastestDataset";
    
    enum class Argument
    {
        input_datasets,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_datasets", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        num_experiments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_experiments", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct IgammaGradA
{
    static constexpr const char* name = "IgammaGradA";
    
    enum class Argument
    {
        a,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CompressElement
{
    static constexpr const char* name = "CompressElement";
    
    enum class Argument
    {
        components,
        compressed
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "input_types"},
        ArgumentDesc{"compressed", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        input_types
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"input_types", AttributeType::ListType}
    };
};

struct QuantizeDownAndShrinkRange
{
    static constexpr const char* name = "QuantizeDownAndShrinkRange";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct UncompressElement
{
    static constexpr const char* name = "UncompressElement";
    
    enum class Argument
    {
        compressed,
        components
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"compressed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct CSVDataset
{
    static constexpr const char* name = "CSVDataset";
    
    enum class Argument
    {
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        handle
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"header", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"field_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"use_quote_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"na_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"select_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct BatchNormWithGlobalNormalizationGrad
{
    static constexpr const char* name = "BatchNormWithGlobalNormalizationGrad";
    
    enum class Argument
    {
        t,
        m,
        v,
        gamma,
        backprop,
        dx,
        dm,
        dv,
        db,
        dg
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gamma", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dx", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dv", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"db", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dg", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        variance_epsilon,
        scale_after_normalization
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"variance_epsilon", AttributeType::Float},
        AttributeDesc{"scale_after_normalization", AttributeType::Bool}
    };
};

struct ExperimentalCSVDataset
{
    static constexpr const char* name = "ExperimentalCSVDataset";
    
    enum class Argument
    {
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        handle
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"header", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"field_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"use_quote_delim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"na_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"select_cols", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct AssignAdd
{
    static constexpr const char* name = "AssignAdd";
    
    enum class Argument
    {
        ref,
        value,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ExperimentalDatasetCardinality
{
    static constexpr const char* name = "ExperimentalDatasetCardinality";
    
    enum class Argument
    {
        input_dataset,
        cardinality
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cardinality", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Complex
{
    static constexpr const char* name = "Complex";
    
    enum class Argument
    {
        real,
        imag,
        out
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"real", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"imag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct ExperimentalGroupByWindowDataset
{
    static constexpr const char* name = "ExperimentalGroupByWindowDataset";
    
    enum class Argument
    {
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tkey_func_other_arguments"},
        ArgumentDesc{"reduce_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Treduce_func_other_arguments"},
        ArgumentDesc{"window_size_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Twindow_size_func_other_arguments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_func,
        reduce_func,
        window_size_func,
        Tkey_func_other_arguments,
        Treduce_func_other_arguments,
        Twindow_size_func_other_arguments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"key_func", AttributeType::Func},
        AttributeDesc{"reduce_func", AttributeType::Func},
        AttributeDesc{"window_size_func", AttributeType::Func},
        AttributeDesc{"Tkey_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Treduce_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Twindow_size_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _XlaSendFromHostV2
{
    static constexpr const char* name = "_XlaSendFromHostV2";
    
    enum class Argument
    {
        inputs,
        dynamic_key,
        device_ordinal
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"dynamic_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"device_ordinal", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinputs,
        key
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"key", AttributeType::String}
    };
};

struct StatelessRandomGetKeyCounter
{
    static constexpr const char* name = "StatelessRandomGetKeyCounter";
    
    enum class Argument
    {
        seed,
        key,
        counter
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tseed
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct SparseToSparseSetOperation
{
    static constexpr const char* name = "SparseToSparseSetOperation";
    
    enum class Argument
    {
        set1_indices,
        set1_values,
        set1_shape,
        set2_indices,
        set2_values,
        set2_shape,
        result_indices,
        result_values,
        result_shape
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"set1_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set1_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set1_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        set_operation,
        validate_indices,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"set_operation", AttributeType::String},
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DatasetFromGraph
{
    static constexpr const char* name = "DatasetFromGraph";
    
    enum class Argument
    {
        graph_def,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"graph_def", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Acos
{
    static constexpr const char* name = "Acos";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExperimentalDatasetToTFRecord
{
    static constexpr const char* name = "ExperimentalDatasetToTFRecord";
    
    enum class Argument
    {
        input_dataset,
        filename,
        compression_type
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"compression_type", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DenseToSparseBatchDataset
{
    static constexpr const char* name = "DenseToSparseBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        row_shape,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SparseSegmentSumWithNumSegments
{
    static constexpr const char* name = "SparseSegmentSumWithNumSegments";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tnumsegments,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct TruncateMod
{
    static constexpr const char* name = "TruncateMod";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SlidingWindowDataset
{
    static constexpr const char* name = "SlidingWindowDataset";
    
    enum class Argument
    {
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_shift", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_stride", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalDenseToSparseBatchDataset
{
    static constexpr const char* name = "ExperimentalDenseToSparseBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        batch_size,
        row_shape,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct DirectedInterleaveDataset
{
    static constexpr const char* name = "DirectedInterleaveDataset";
    
    enum class Argument
    {
        selector_input_dataset,
        data_input_datasets,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"selector_input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data_input_datasets", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        N,
        stop_on_empty_dataset
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"stop_on_empty_dataset", AttributeType::Bool}
    };
};

struct ExperimentalDirectedInterleaveDataset
{
    static constexpr const char* name = "ExperimentalDirectedInterleaveDataset";
    
    enum class Argument
    {
        selector_input_dataset,
        data_input_datasets,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"selector_input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data_input_datasets", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct LRN
{
    static constexpr const char* name = "LRN";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        depth_radius,
        bias,
        alpha,
        beta,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"depth_radius", AttributeType::Int},
        AttributeDesc{"bias", AttributeType::Float},
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"beta", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExperimentalGroupByReducerDataset
{
    static constexpr const char* name = "ExperimentalGroupByReducerDataset";
    
    enum class Argument
    {
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tkey_func_other_arguments"},
        ArgumentDesc{"init_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tinit_func_other_arguments"},
        ArgumentDesc{"reduce_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Treduce_func_other_arguments"},
        ArgumentDesc{"finalize_func_other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Tfinalize_func_other_arguments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_func,
        init_func,
        reduce_func,
        finalize_func,
        Tkey_func_other_arguments,
        Tinit_func_other_arguments,
        Treduce_func_other_arguments,
        Tfinalize_func_other_arguments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"key_func", AttributeType::Func},
        AttributeDesc{"init_func", AttributeType::Func},
        AttributeDesc{"reduce_func", AttributeType::Func},
        AttributeDesc{"finalize_func", AttributeType::Func},
        AttributeDesc{"Tkey_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Tinit_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Treduce_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"Tfinalize_func_other_arguments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct GetElementAtIndex
{
    static constexpr const char* name = "GetElementAtIndex";
    
    enum class Argument
    {
        dataset,
        index,
        components
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"components", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct IgnoreErrorsDataset
{
    static constexpr const char* name = "IgnoreErrorsDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        log_warning
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"log_warning", AttributeType::Bool}
    };
};

struct ExperimentalIteratorGetDevice
{
    static constexpr const char* name = "ExperimentalIteratorGetDevice";
    
    enum class Argument
    {
        resource,
        device
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"device", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ExperimentalMapAndBatchDataset
{
    static constexpr const char* name = "ExperimentalMapAndBatchDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"batch_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct QuantizedAdd
{
    static constexpr const char* name = "QuantizedAdd";
    
    enum class Argument
    {
        x,
        y,
        min_x,
        max_x,
        min_y,
        max_y,
        z,
        min_z,
        max_z
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Toutput
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type}
    };
};

struct ResourceSparseApplyKerasMomentum
{
    static constexpr const char* name = "ResourceSparseApplyKerasMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        indices,
        momentum
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct ResourceScatterNdMin
{
    static constexpr const char* name = "ResourceScatterNdMin";
    
    enum class Argument
    {
        ref,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ExperimentalMapDataset
{
    static constexpr const char* name = "ExperimentalMapDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes,
        use_inter_op_parallelism,
        preserve_cardinality
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_inter_op_parallelism", AttributeType::Bool},
        AttributeDesc{"preserve_cardinality", AttributeType::Bool}
    };
};

struct ExperimentalMatchingFilesDataset
{
    static constexpr const char* name = "ExperimentalMatchingFilesDataset";
    
    enum class Argument
    {
        patterns,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"patterns", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct WholeFileReader
{
    static constexpr const char* name = "WholeFileReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ScatterMul
{
    static constexpr const char* name = "ScatterMul";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct NonSerializableDataset
{
    static constexpr const char* name = "NonSerializableDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct MaxIntraOpParallelismDataset
{
    static constexpr const char* name = "MaxIntraOpParallelismDataset";
    
    enum class Argument
    {
        input_dataset,
        max_intra_op_parallelism,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_intra_op_parallelism", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ParallelInterleaveDataset
{
    static constexpr const char* name = "ParallelInterleaveDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        handle
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sloppy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_output_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"prefetch_input_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct LegacyParallelInterleaveDatasetV2
{
    static constexpr const char* name = "LegacyParallelInterleaveDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        handle
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"cycle_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"block_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"buffer_output_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"prefetch_input_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        f,
        deterministic,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"deterministic", AttributeType::String},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Erf
{
    static constexpr const char* name = "Erf";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TruncateDiv
{
    static constexpr const char* name = "TruncateDiv";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Conv3DBackpropInput
{
    static constexpr const char* name = "Conv3DBackpropInput";
    
    enum class Argument
    {
        input,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct ParseExampleDataset
{
    static constexpr const char* name = "ParseExampleDataset";
    
    enum class Argument
    {
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_parallel_calls", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sparse_keys,
        dense_keys,
        sparse_types,
        Tdense,
        dense_shapes,
        output_types,
        output_shapes,
        sloppy,
        ragged_keys,
        ragged_value_types,
        ragged_split_types
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"sparse_keys", AttributeType::ListString},
        AttributeDesc{"dense_keys", AttributeType::ListString},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"sloppy", AttributeType::Bool},
        AttributeDesc{"ragged_keys", AttributeType::ListString},
        AttributeDesc{"ragged_value_types", AttributeType::ListType},
        AttributeDesc{"ragged_split_types", AttributeType::ListType}
    };
};

struct _TPUCompileMlirPlaceholderProgramKey
{
    static constexpr const char* name = "_TPUCompileMlirPlaceholderProgramKey";
    
    enum class Argument
    {
        program
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"program", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklDequantize
{
    static constexpr const char* name = "_MklDequantize";
    
    enum class Argument
    {
        input,
        min_range,
        max_range,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        narrow_range,
        axis,
        mode,
        dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"narrow_range", AttributeType::Bool},
        AttributeDesc{"axis", AttributeType::Int},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct ApplyCenteredRMSProp
{
    static constexpr const char* name = "ApplyCenteredRMSProp";
    
    enum class Argument
    {
        var,
        mg,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct PrivateThreadPoolDataset
{
    static constexpr const char* name = "PrivateThreadPoolDataset";
    
    enum class Argument
    {
        input_dataset,
        num_threads,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_threads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ResourceCountUpTo
{
    static constexpr const char* name = "ResourceCountUpTo";
    
    enum class Argument
    {
        resource,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        limit,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"limit", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Angle
{
    static constexpr const char* name = "Angle";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct ExperimentalRandomDataset
{
    static constexpr const char* name = "ExperimentalRandomDataset";
    
    enum class Argument
    {
        seed,
        seed2,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct FusedBatchNormGradV2
{
    static constexpr const char* name = "FusedBatchNormGradV2";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct ExperimentalRebatchDataset
{
    static constexpr const char* name = "ExperimentalRebatchDataset";
    
    enum class Argument
    {
        input_dataset,
        num_replicas,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_replicas", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        use_fallback
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_fallback", AttributeType::Bool}
    };
};

struct XlaSharding
{
    static constexpr const char* name = "XlaSharding";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        sharding,
        unspecified_dims
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"sharding", AttributeType::String},
        AttributeDesc{"unspecified_dims", AttributeType::ListInt}
    };
};

struct RebatchDataset
{
    static constexpr const char* name = "RebatchDataset";
    
    enum class Argument
    {
        input_dataset,
        num_replicas,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_replicas", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        use_fallback
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"use_fallback", AttributeType::Bool}
    };
};

struct DenseBincount
{
    static constexpr const char* name = "DenseBincount";
    
    enum class Argument
    {
        input,
        size,
        weights,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx,
        T,
        binary_output
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"binary_output", AttributeType::Bool}
    };
};

struct RaggedTensorToVariant
{
    static constexpr const char* name = "RaggedTensorToVariant";
    
    enum class Argument
    {
        rt_nested_splits,
        rt_dense_values,
        encoded_ragged
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"rt_nested_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "RAGGED_RANK"},
        ArgumentDesc{"rt_dense_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"encoded_ragged", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        RAGGED_RANK,
        Tvalues,
        Tsplits,
        batched_input
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"RAGGED_RANK", AttributeType::Int},
        AttributeDesc{"Tvalues", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type},
        AttributeDesc{"batched_input", AttributeType::Bool}
    };
};

struct RebatchDatasetV2
{
    static constexpr const char* name = "RebatchDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        batch_sizes,
        drop_remainder,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"drop_remainder", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalSetStatsAggregatorDataset
{
    static constexpr const char* name = "ExperimentalSetStatsAggregatorDataset";
    
    enum class Argument
    {
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stats_aggregator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter_prefix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalSleepDataset
{
    static constexpr const char* name = "ExperimentalSleepDataset";
    
    enum class Argument
    {
        input_dataset,
        sleep_microseconds,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sleep_microseconds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SoftplusGrad
{
    static constexpr const char* name = "SoftplusGrad";
    
    enum class Argument
    {
        gradients,
        features,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ExperimentalSlidingWindowDataset
{
    static constexpr const char* name = "ExperimentalSlidingWindowDataset";
    
    enum class Argument
    {
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_shift", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_stride", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct SnapshotDatasetV2
{
    static constexpr const char* name = "SnapshotDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        path,
        reader_func_other_args,
        shard_func_other_args,
        handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reader_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Treader_func_args"},
        ArgumentDesc{"shard_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tshard_func_args"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes,
        compression,
        reader_prefix,
        writer_prefix,
        hash_valid,
        hash,
        reader_func,
        shard_func,
        Treader_func_args,
        Tshard_func_args
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"reader_prefix", AttributeType::String},
        AttributeDesc{"writer_prefix", AttributeType::String},
        AttributeDesc{"hash_valid", AttributeType::Bool},
        AttributeDesc{"hash", AttributeType::Int},
        AttributeDesc{"reader_func", AttributeType::Func},
        AttributeDesc{"shard_func", AttributeType::Func},
        AttributeDesc{"Treader_func_args", AttributeType::ListType},
        AttributeDesc{"Tshard_func_args", AttributeType::ListType}
    };
};

struct HistogramSummary
{
    static constexpr const char* name = "HistogramSummary";
    
    enum class Argument
    {
        tag,
        values,
        summary
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedReluX
{
    static constexpr const char* name = "QuantizedReluX";
    
    enum class Argument
    {
        features,
        max_value,
        min_features,
        max_features,
        activations,
        min_activations,
        max_activations
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct SaveDatasetV2
{
    static constexpr const char* name = "SaveDatasetV2";
    
    enum class Argument
    {
        input_dataset,
        path,
        shard_func_other_args,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"path", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shard_func_other_args", ArgumentDesc::TensorCount::SequenceAttrList, "Tshard_func_args"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compression,
        shard_func,
        use_shard_func,
        Tshard_func_args,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"compression", AttributeType::String},
        AttributeDesc{"shard_func", AttributeType::Func},
        AttributeDesc{"use_shard_func", AttributeType::Bool},
        AttributeDesc{"Tshard_func_args", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Conv2DBackpropInput
{
    static constexpr const char* name = "Conv2DBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct SqlDataset
{
    static constexpr const char* name = "SqlDataset";
    
    enum class Argument
    {
        driver_name,
        data_source_name,
        query,
        handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"driver_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data_source_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"query", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct MatchingFiles
{
    static constexpr const char* name = "MatchingFiles";
    
    enum class Argument
    {
        pattern,
        filenames
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"pattern", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filenames", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Betainc
{
    static constexpr const char* name = "Betainc";
    
    enum class Argument
    {
        a,
        b,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ReadFile
{
    static constexpr const char* name = "ReadFile";
    
    enum class Argument
    {
        filename,
        contents
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklQuantizedConv2DWithBiasSumAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasSumAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        Tsummand,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 12> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Tsummand", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct StatsAggregatorHandle
{
    static constexpr const char* name = "StatsAggregatorHandle";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ExperimentalStatsAggregatorHandle
{
    static constexpr const char* name = "ExperimentalStatsAggregatorHandle";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct StatsAggregatorSetSummaryWriter
{
    static constexpr const char* name = "StatsAggregatorSetSummaryWriter";
    
    enum class Argument
    {
        stats_aggregator,
        summary
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"stats_aggregator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AddSparseToTensorsMap
{
    static constexpr const char* name = "AddSparseToTensorsMap";
    
    enum class Argument
    {
        sparse_indices,
        sparse_values,
        sparse_shape,
        sparse_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TakeWhileDataset
{
    static constexpr const char* name = "TakeWhileDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        predicate,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"predicate", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalTakeWhileDataset
{
    static constexpr const char* name = "ExperimentalTakeWhileDataset";
    
    enum class Argument
    {
        input_dataset,
        other_arguments,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"other_arguments", ArgumentDesc::TensorCount::SequenceAttrList, "Targuments"},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        predicate,
        Targuments,
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"predicate", AttributeType::Func},
        AttributeDesc{"Targuments", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalThreadPoolDataset
{
    static constexpr const char* name = "ExperimentalThreadPoolDataset";
    
    enum class Argument
    {
        input_dataset,
        thread_pool,
        handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thread_pool", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ReaderRestoreState
{
    static constexpr const char* name = "ReaderRestoreState";
    
    enum class Argument
    {
        reader_handle,
        state
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"state", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ThreadPoolHandle
{
    static constexpr const char* name = "ThreadPoolHandle";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_threads,
        max_intra_op_parallelism,
        display_name,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"num_threads", AttributeType::Int},
        AttributeDesc{"max_intra_op_parallelism", AttributeType::Int},
        AttributeDesc{"display_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ExperimentalThreadPoolHandle
{
    static constexpr const char* name = "ExperimentalThreadPoolHandle";
    
    enum class Argument
    {
        handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_threads,
        max_intra_op_parallelism,
        display_name,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"num_threads", AttributeType::Int},
        AttributeDesc{"max_intra_op_parallelism", AttributeType::Int},
        AttributeDesc{"display_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct BesselK1e
{
    static constexpr const char* name = "BesselK1e";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedDepthwiseConv2DWithBias
{
    static constexpr const char* name = "QuantizedDepthwiseConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct UnbatchDataset
{
    static constexpr const char* name = "UnbatchDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ExperimentalUniqueDataset
{
    static constexpr const char* name = "ExperimentalUniqueDataset";
    
    enum class Argument
    {
        input_dataset,
        handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_dataset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_types,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct IdentityReaderV2
{
    static constexpr const char* name = "IdentityReaderV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct DrawBoundingBoxes
{
    static constexpr const char* name = "DrawBoundingBoxes";
    
    enum class Argument
    {
        images,
        boxes,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DataServiceDataset
{
    static constexpr const char* name = "DataServiceDataset";
    
    enum class Argument
    {
        dataset_id,
        processing_mode,
        address,
        protocol,
        job_name,
        max_outstanding_requests,
        iteration_counter,
        handle
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset_id", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"processing_mode", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"address", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"protocol", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"job_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_outstanding_requests", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iteration_counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        task_refresh_interval_hint_ms,
        output_types,
        output_shapes,
        data_transfer_protocol,
        target_workers
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"task_refresh_interval_hint_ms", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"data_transfer_protocol", AttributeType::String},
        AttributeDesc{"target_workers", AttributeType::String}
    };
};

struct DataServiceDatasetV2
{
    static constexpr const char* name = "DataServiceDatasetV2";
    
    enum class Argument
    {
        dataset_id,
        processing_mode,
        address,
        protocol,
        job_name,
        consumer_index,
        num_consumers,
        max_outstanding_requests,
        iteration_counter,
        handle
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dataset_id", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"processing_mode", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"address", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"protocol", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"job_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"consumer_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_consumers", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_outstanding_requests", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iteration_counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        task_refresh_interval_hint_ms,
        output_types,
        output_shapes,
        data_transfer_protocol,
        target_workers
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"task_refresh_interval_hint_ms", AttributeType::Int},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"data_transfer_protocol", AttributeType::String},
        AttributeDesc{"target_workers", AttributeType::String}
    };
};

struct ResizeBicubicGrad
{
    static constexpr const char* name = "ResizeBicubicGrad";
    
    enum class Argument
    {
        grads,
        original_image,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"original_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct ResizeBilinearGrad
{
    static constexpr const char* name = "ResizeBilinearGrad";
    
    enum class Argument
    {
        grads,
        original_image,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"original_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        align_corners,
        half_pixel_centers
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"align_corners", AttributeType::Bool},
        AttributeDesc{"half_pixel_centers", AttributeType::Bool}
    };
};

struct StatelessRandomUniformIntV2
{
    static constexpr const char* name = "StatelessRandomUniformIntV2";
    
    enum class Argument
    {
        shape,
        key,
        counter,
        alg,
        minval,
        maxval,
        output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct DepthwiseConv2dNativeBackpropInput
{
    static constexpr const char* name = "DepthwiseConv2dNativeBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct Real
{
    static constexpr const char* name = "Real";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct DecodeJpeg
{
    static constexpr const char* name = "DecodeJpeg";
    
    enum class Argument
    {
        contents,
        image
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        channels,
        ratio,
        fancy_upscaling,
        try_recover_truncated,
        acceptable_fraction,
        dct_method
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"channels", AttributeType::Int},
        AttributeDesc{"ratio", AttributeType::Int},
        AttributeDesc{"fancy_upscaling", AttributeType::Bool},
        AttributeDesc{"try_recover_truncated", AttributeType::Bool},
        AttributeDesc{"acceptable_fraction", AttributeType::Float},
        AttributeDesc{"dct_method", AttributeType::String}
    };
};

struct AdjustContrast
{
    static constexpr const char* name = "AdjustContrast";
    
    enum class Argument
    {
        images,
        contrast_factor,
        min_value,
        max_value,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contrast_factor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorMapLookup
{
    static constexpr const char* name = "TensorMapLookup";
    
    enum class Argument
    {
        input_handle,
        key,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct RiscScatter
{
    static constexpr const char* name = "RiscScatter";
    
    enum class Argument
    {
        indices,
        updates,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct AdjustHue
{
    static constexpr const char* name = "AdjustHue";
    
    enum class Argument
    {
        images,
        delta,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DecodeGif
{
    static constexpr const char* name = "DecodeGif";
    
    enum class Argument
    {
        contents,
        image
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct HSVToRGB
{
    static constexpr const char* name = "HSVToRGB";
    
    enum class Argument
    {
        images,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct DrawBoundingBoxesV2
{
    static constexpr const char* name = "DrawBoundingBoxesV2";
    
    enum class Argument
    {
        images,
        boxes,
        colors,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"colors", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeDepthwiseConv2dNativeBackpropInput
{
    static constexpr const char* name = "_MklNativeDepthwiseConv2dNativeBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct ExtractGlimpse
{
    static constexpr const char* name = "ExtractGlimpse";
    
    enum class Argument
    {
        input,
        size,
        offsets,
        glimpse
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offsets", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"glimpse", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        centered,
        normalized,
        uniform_noise,
        noise
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"centered", AttributeType::Bool},
        AttributeDesc{"normalized", AttributeType::Bool},
        AttributeDesc{"uniform_noise", AttributeType::Bool},
        AttributeDesc{"noise", AttributeType::String}
    };
};

struct ExtractGlimpseV2
{
    static constexpr const char* name = "ExtractGlimpseV2";
    
    enum class Argument
    {
        input,
        size,
        offsets,
        glimpse
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offsets", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"glimpse", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        centered,
        normalized,
        uniform_noise,
        noise
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"centered", AttributeType::Bool},
        AttributeDesc{"normalized", AttributeType::Bool},
        AttributeDesc{"uniform_noise", AttributeType::Bool},
        AttributeDesc{"noise", AttributeType::String}
    };
};

struct LoadTPUEmbeddingRMSPropParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingRMSPropParameters";
    
    enum class Argument
    {
        parameters,
        ms,
        mom
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct SaveV2
{
    static constexpr const char* name = "SaveV2";
    
    enum class Argument
    {
        prefix,
        tensor_names,
        shape_and_slices,
        tensors
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"prefix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape_and_slices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensors", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType}
    };
};

struct MutableHashTableOfTensorsV2
{
    static constexpr const char* name = "MutableHashTableOfTensorsV2";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype,
        value_shape
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type},
        AttributeDesc{"value_shape", AttributeType::Shape}
    };
};

struct IsInf
{
    static constexpr const char* name = "IsInf";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CropAndResize
{
    static constexpr const char* name = "CropAndResize";
    
    enum class Argument
    {
        image,
        boxes,
        box_ind,
        crop_size,
        crops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"box_ind", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"crop_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"crops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        method,
        extrapolation_value
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"method", AttributeType::String},
        AttributeDesc{"extrapolation_value", AttributeType::Float}
    };
};

struct TFRecordReaderV2
{
    static constexpr const char* name = "TFRecordReaderV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        compression_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"compression_type", AttributeType::String}
    };
};

struct CropAndResizeGradImage
{
    static constexpr const char* name = "CropAndResizeGradImage";
    
    enum class Argument
    {
        grads,
        boxes,
        box_ind,
        image_size,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"box_ind", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        method
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"method", AttributeType::String}
    };
};

struct XlaPad
{
    static constexpr const char* name = "XlaPad";
    
    enum class Argument
    {
        input,
        padding_value,
        padding_low,
        padding_high,
        padding_interior,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_low", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_high", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding_interior", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct CropAndResizeGradBoxes
{
    static constexpr const char* name = "CropAndResizeGradBoxes";
    
    enum class Argument
    {
        grads,
        image,
        boxes,
        box_ind,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"box_ind", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        method
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"method", AttributeType::String}
    };
};

struct LoadTPUEmbeddingFTRLParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingFTRLParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        linears
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linears", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct NonMaxSuppression
{
    static constexpr const char* name = "NonMaxSuppression";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size,
        selected_indices
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        iou_threshold
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"iou_threshold", AttributeType::Float}
    };
};

struct Atanh
{
    static constexpr const char* name = "Atanh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct NonMaxSuppressionV4
{
    static constexpr const char* name = "NonMaxSuppressionV4";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        selected_indices,
        valid_outputs
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iou_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"score_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"valid_outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        T_threshold,
        pad_to_max_output_size
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"T_threshold", AttributeType::Type},
        AttributeDesc{"pad_to_max_output_size", AttributeType::Bool}
    };
};

struct NonMaxSuppressionV5
{
    static constexpr const char* name = "NonMaxSuppressionV5";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        soft_nms_sigma,
        selected_indices,
        selected_scores,
        valid_outputs
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iou_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"score_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"soft_nms_sigma", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"valid_outputs", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        pad_to_max_output_size
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"pad_to_max_output_size", AttributeType::Bool}
    };
};

struct NonMaxSuppressionWithOverlaps
{
    static constexpr const char* name = "NonMaxSuppressionWithOverlaps";
    
    enum class Argument
    {
        overlaps,
        scores,
        max_output_size,
        overlap_threshold,
        score_threshold,
        selected_indices
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"overlaps", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"overlap_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"score_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"selected_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseFillEmptyRowsGrad
{
    static constexpr const char* name = "SparseFillEmptyRowsGrad";
    
    enum class Argument
    {
        reverse_index_map,
        grad_values,
        d_values,
        d_default_value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reverse_index_map", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_default_value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CombinedNonMaxSuppression
{
    static constexpr const char* name = "CombinedNonMaxSuppression";
    
    enum class Argument
    {
        boxes,
        scores,
        max_output_size_per_class,
        max_total_size,
        iou_threshold,
        score_threshold,
        nmsed_boxes,
        nmsed_scores,
        nmsed_classes,
        valid_detections
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output_size_per_class", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_total_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"iou_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"score_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nmsed_boxes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nmsed_scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nmsed_classes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"valid_detections", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pad_per_class,
        clip_boxes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"pad_per_class", AttributeType::Bool},
        AttributeDesc{"clip_boxes", AttributeType::Bool}
    };
};

struct Prod
{
    static constexpr const char* name = "Prod";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct GenerateBoundingBoxProposals
{
    static constexpr const char* name = "GenerateBoundingBoxProposals";
    
    enum class Argument
    {
        scores,
        bbox_deltas,
        image_info,
        anchors,
        nms_threshold,
        pre_nms_topn,
        min_size,
        rois,
        roi_probabilities
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"scores", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bbox_deltas", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"image_info", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"anchors", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nms_threshold", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pre_nms_topn", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rois", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"roi_probabilities", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        post_nms_topn
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"post_nms_topn", AttributeType::Int}
    };
};

struct Acosh
{
    static constexpr const char* name = "Acosh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ImageProjectiveTransformV2
{
    static constexpr const char* name = "ImageProjectiveTransformV2";
    
    enum class Argument
    {
        images,
        transforms,
        output_shape,
        transformed_images
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transforms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transformed_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        interpolation,
        fill_mode
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"interpolation", AttributeType::String},
        AttributeDesc{"fill_mode", AttributeType::String}
    };
};

struct ImageProjectiveTransformV3
{
    static constexpr const char* name = "ImageProjectiveTransformV3";
    
    enum class Argument
    {
        images,
        transforms,
        output_shape,
        fill_value,
        transformed_images
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"images", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transforms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fill_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"transformed_images", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        interpolation,
        fill_mode
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"interpolation", AttributeType::String},
        AttributeDesc{"fill_mode", AttributeType::String}
    };
};

struct SquaredDifference
{
    static constexpr const char* name = "SquaredDifference";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RestoreV2
{
    static constexpr const char* name = "RestoreV2";
    
    enum class Argument
    {
        prefix,
        tensor_names,
        shape_and_slices,
        tensors
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"prefix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape_and_slices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensors", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType}
    };
};

struct Conv3DBackpropFilterV2
{
    static constexpr const char* name = "Conv3DBackpropFilterV2";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct Save
{
    static constexpr const char* name = "Save";
    
    enum class Argument
    {
        filename,
        tensor_names,
        data
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType}
    };
};

struct MutableHashTableOfTensors
{
    static constexpr const char* name = "MutableHashTableOfTensors";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype,
        value_shape
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type},
        AttributeDesc{"value_shape", AttributeType::Shape}
    };
};

struct UnsortedSegmentMin
{
    static constexpr const char* name = "UnsortedSegmentMin";
    
    enum class Argument
    {
        data,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        Tnumsegments
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type}
    };
};

struct _FusedMatMul
{
    static constexpr const char* name = "_FusedMatMul";
    
    enum class Argument
    {
        a,
        b,
        args,
        product
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        transpose_a,
        transpose_b,
        T,
        num_args,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct TopKV2
{
    static constexpr const char* name = "TopKV2";
    
    enum class Argument
    {
        input,
        k,
        values,
        indices
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sorted,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"sorted", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Restore
{
    static constexpr const char* name = "Restore";
    
    enum class Argument
    {
        file_pattern,
        tensor_name,
        tensor
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"file_pattern", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dt,
        preferred_shard
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dt", AttributeType::Type},
        AttributeDesc{"preferred_shard", AttributeType::Int}
    };
};

struct SparseApplyAdagradV2
{
    static constexpr const char* name = "SparseApplyAdagradV2";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        epsilon,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct RestoreSlice
{
    static constexpr const char* name = "RestoreSlice";
    
    enum class Argument
    {
        file_pattern,
        tensor_name,
        shape_and_slice,
        tensor
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"file_pattern", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape_and_slice", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dt,
        preferred_shard
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dt", AttributeType::Type},
        AttributeDesc{"preferred_shard", AttributeType::Int}
    };
};

struct ShardedFilename
{
    static constexpr const char* name = "ShardedFilename";
    
    enum class Argument
    {
        basename,
        shard,
        num_shards,
        filename
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"basename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shard", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_shards", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Relu6
{
    static constexpr const char* name = "Relu6";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TextLineReader
{
    static constexpr const char* name = "TextLineReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        skip_header_lines,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"skip_header_lines", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct StatefulUniformFullInt
{
    static constexpr const char* name = "StatefulUniformFullInt";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct TextLineReaderV2
{
    static constexpr const char* name = "TextLineReaderV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        skip_header_lines,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"skip_header_lines", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TensorListGather
{
    static constexpr const char* name = "TensorListGather";
    
    enum class Argument
    {
        input_handle,
        indices,
        element_shape,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct FixedLengthRecordReader
{
    static constexpr const char* name = "FixedLengthRecordReader";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        header_bytes,
        record_bytes,
        footer_bytes,
        hop_bytes,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"header_bytes", AttributeType::Int},
        AttributeDesc{"record_bytes", AttributeType::Int},
        AttributeDesc{"footer_bytes", AttributeType::Int},
        AttributeDesc{"hop_bytes", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct MatrixSquareRoot
{
    static constexpr const char* name = "MatrixSquareRoot";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaSpmdFullToShardShape
{
    static constexpr const char* name = "XlaSpmdFullToShardShape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        manual_sharding,
        dim,
        unspecified_dims
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"manual_sharding", AttributeType::String},
        AttributeDesc{"dim", AttributeType::Int},
        AttributeDesc{"unspecified_dims", AttributeType::ListInt}
    };
};

struct NthElement
{
    static constexpr const char* name = "NthElement";
    
    enum class Argument
    {
        input,
        n,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"n", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reverse,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"reverse", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FixedLengthRecordReaderV2
{
    static constexpr const char* name = "FixedLengthRecordReaderV2";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        header_bytes,
        record_bytes,
        footer_bytes,
        hop_bytes,
        container,
        shared_name,
        encoding
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"header_bytes", AttributeType::Int},
        AttributeDesc{"record_bytes", AttributeType::Int},
        AttributeDesc{"footer_bytes", AttributeType::Int},
        AttributeDesc{"hop_bytes", AttributeType::Int},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"encoding", AttributeType::String}
    };
};

struct ReaderRead
{
    static constexpr const char* name = "ReaderRead";
    
    enum class Argument
    {
        reader_handle,
        queue_handle,
        key,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"queue_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderNumRecordsProduced
{
    static constexpr const char* name = "ReaderNumRecordsProduced";
    
    enum class Argument
    {
        reader_handle,
        records_produced
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"records_produced", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderNumWorkUnitsCompleted
{
    static constexpr const char* name = "ReaderNumWorkUnitsCompleted";
    
    enum class Argument
    {
        reader_handle,
        units_completed
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"units_completed", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct LogMatrixDeterminant
{
    static constexpr const char* name = "LogMatrixDeterminant";
    
    enum class Argument
    {
        input,
        sign,
        log_abs_determinant
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sign", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"log_abs_determinant", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ReaderNumWorkUnitsCompletedV2
{
    static constexpr const char* name = "ReaderNumWorkUnitsCompletedV2";
    
    enum class Argument
    {
        reader_handle,
        units_completed
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"units_completed", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderSerializeState
{
    static constexpr const char* name = "ReaderSerializeState";
    
    enum class Argument
    {
        reader_handle,
        state
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"state", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderSerializeStateV2
{
    static constexpr const char* name = "ReaderSerializeStateV2";
    
    enum class Argument
    {
        reader_handle,
        state
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"state", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Xlog1py
{
    static constexpr const char* name = "Xlog1py";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AssignSubVariableOp
{
    static constexpr const char* name = "AssignSubVariableOp";
    
    enum class Argument
    {
        resource,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct ReaderRestoreStateV2
{
    static constexpr const char* name = "ReaderRestoreStateV2";
    
    enum class Argument
    {
        reader_handle,
        state
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"state", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ReaderReset
{
    static constexpr const char* name = "ReaderReset";
    
    enum class Argument
    {
        reader_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"reader_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseMatrixSoftmaxGrad
{
    static constexpr const char* name = "SparseMatrixSoftmaxGrad";
    
    enum class Argument
    {
        softmax,
        grad_softmax,
        gradient
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"softmax", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad_softmax", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct Multinomial
{
    static constexpr const char* name = "Multinomial";
    
    enum class Argument
    {
        logits,
        num_samples,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_samples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        T,
        output_dtype
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"output_dtype", AttributeType::Type}
    };
};

struct WriteFile
{
    static constexpr const char* name = "WriteFile";
    
    enum class Argument
    {
        filename,
        contents
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"contents", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Cholesky
{
    static constexpr const char* name = "Cholesky";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ApplyPowerSign
{
    static constexpr const char* name = "ApplyPowerSign";
    
    enum class Argument
    {
        var,
        m,
        lr,
        logbase,
        sign_decay,
        beta,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"logbase", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sign_decay", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct SelfAdjointEig
{
    static constexpr const char* name = "SelfAdjointEig";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Eig
{
    static constexpr const char* name = "Eig";
    
    enum class Argument
    {
        input,
        e,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compute_v,
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"compute_v", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct LookupTableSize
{
    static constexpr const char* name = "LookupTableSize";
    
    enum class Argument
    {
        table_handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SerializeSparse
{
    static constexpr const char* name = "SerializeSparse";
    
    enum class Argument
    {
        sparse_indices,
        sparse_values,
        sparse_shape,
        serialized_sparse
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized_sparse", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct SelfAdjointEigV2
{
    static constexpr const char* name = "SelfAdjointEigV2";
    
    enum class Argument
    {
        input,
        e,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"e", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compute_v,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"compute_v", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixSolve
{
    static constexpr const char* name = "MatrixSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklQuantizedConv2DWithBiasAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct BandedTriangularSolve
{
    static constexpr const char* name = "BandedTriangularSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        lower,
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"lower", AttributeType::Bool},
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscReverse
{
    static constexpr const char* name = "RiscReverse";
    
    enum class Argument
    {
        tensor,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MatrixTriangularSolve
{
    static constexpr const char* name = "MatrixTriangularSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        lower,
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"lower", AttributeType::Bool},
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct If
{
    static constexpr const char* name = "If";
    
    enum class Argument
    {
        cond,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"cond", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tcond,
        Tin,
        Tout,
        then_branch,
        else_branch,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tcond", AttributeType::Type},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"then_branch", AttributeType::Func},
        AttributeDesc{"else_branch", AttributeType::Func},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct RiscBitcast
{
    static constexpr const char* name = "RiscBitcast";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        SrcT,
        DstT
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"SrcT", AttributeType::Type},
        AttributeDesc{"DstT", AttributeType::Type}
    };
};

struct MatrixSolveLs
{
    static constexpr const char* name = "MatrixSolveLs";
    
    enum class Argument
    {
        matrix,
        rhs,
        l2_regularizer,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_regularizer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        fast
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"fast", AttributeType::Bool}
    };
};

struct _MklNativeConv2DBackpropFilterWithBias
{
    static constexpr const char* name = "_MklNativeConv2DBackpropFilterWithBias";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output,
        bias_grad
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct CountUpTo
{
    static constexpr const char* name = "CountUpTo";
    
    enum class Argument
    {
        ref,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        limit,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"limit", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Svd
{
    static constexpr const char* name = "Svd";
    
    enum class Argument
    {
        input,
        s,
        u,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"s", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"u", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compute_uv,
        full_matrices,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"compute_uv", AttributeType::Bool},
        AttributeDesc{"full_matrices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Exp
{
    static constexpr const char* name = "Exp";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TridiagonalMatMul
{
    static constexpr const char* name = "TridiagonalMatMul";
    
    enum class Argument
    {
        superdiag,
        maindiag,
        subdiag,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"superdiag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maindiag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"subdiag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TridiagonalSolve
{
    static constexpr const char* name = "TridiagonalSolve";
    
    enum class Argument
    {
        diagonals,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"diagonals", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        partial_pivoting,
        perturb_singular,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"partial_pivoting", AttributeType::Bool},
        AttributeDesc{"perturb_singular", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchMatrixDeterminant
{
    static constexpr const char* name = "BatchMatrixDeterminant";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscSign
{
    static constexpr const char* name = "RiscSign";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchCholeskyGrad
{
    static constexpr const char* name = "BatchCholeskyGrad";
    
    enum class Argument
    {
        l,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"l", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ResourceApplyAdagradV2
{
    static constexpr const char* name = "ResourceApplyAdagradV2";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct TensorListPushBackBatch
{
    static constexpr const char* name = "TensorListPushBackBatch";
    
    enum class Argument
    {
        input_handles,
        tensor,
        output_handles
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handles", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handles", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct TensorListLength
{
    static constexpr const char* name = "TensorListLength";
    
    enum class Argument
    {
        input_handle,
        length
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"length", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct Mean
{
    static constexpr const char* name = "Mean";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct TensorListStack
{
    static constexpr const char* name = "TensorListStack";
    
    enum class Argument
    {
        input_handle,
        element_shape,
        tensor
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        num_elements
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"num_elements", AttributeType::Int}
    };
};

struct _Retval
{
    static constexpr const char* name = "_Retval";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"index", AttributeType::Int}
    };
};

struct TensorListConcat
{
    static constexpr const char* name = "TensorListConcat";
    
    enum class Argument
    {
        input_handle,
        tensor,
        lengths
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        element_shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"element_shape", AttributeType::Shape}
    };
};

struct TensorListConcatV2
{
    static constexpr const char* name = "TensorListConcatV2";
    
    enum class Argument
    {
        input_handle,
        element_shape,
        leading_dims,
        tensor,
        lengths
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"leading_dims", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct _MklQuantizedMatMulWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedMatMulWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode,
        is_weight_const
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String},
        AttributeDesc{"is_weight_const", AttributeType::Bool}
    };
};

struct TensorListSplit
{
    static constexpr const char* name = "TensorListSplit";
    
    enum class Argument
    {
        tensor,
        element_shape,
        lengths,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lengths", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct TensorSummaryV2
{
    static constexpr const char* name = "TensorSummaryV2";
    
    enum class Argument
    {
        tag,
        tensor,
        serialized_summary_metadata,
        summary
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized_summary_metadata", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorListElementShape
{
    static constexpr const char* name = "TensorListElementShape";
    
    enum class Argument
    {
        input_handle,
        element_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct _HostCast
{
    static constexpr const char* name = "_HostCast";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        SrcT,
        DstT,
        Truncate
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"SrcT", AttributeType::Type},
        AttributeDesc{"DstT", AttributeType::Type},
        AttributeDesc{"Truncate", AttributeType::Bool}
    };
};

struct TensorListGetItem
{
    static constexpr const char* name = "TensorListGetItem";
    
    enum class Argument
    {
        input_handle,
        index,
        element_shape,
        item
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"item", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct TensorListResize
{
    static constexpr const char* name = "TensorListResize";
    
    enum class Argument
    {
        input_handle,
        size,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct TensorListScatter
{
    static constexpr const char* name = "TensorListScatter";
    
    enum class Argument
    {
        tensor,
        indices,
        element_shape,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct TensorListScatterV2
{
    static constexpr const char* name = "TensorListScatterV2";
    
    enum class Argument
    {
        tensor,
        indices,
        element_shape,
        num_elements,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"element_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_elements", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype,
        shape_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type},
        AttributeDesc{"shape_type", AttributeType::Type}
    };
};

struct NextAfter
{
    static constexpr const char* name = "NextAfter";
    
    enum class Argument
    {
        x1,
        x2,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TensorListScatterIntoExistingList
{
    static constexpr const char* name = "TensorListScatterIntoExistingList";
    
    enum class Argument
    {
        input_handle,
        tensor,
        indices,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        element_dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"element_dtype", AttributeType::Type}
    };
};

struct TensorMapSize
{
    static constexpr const char* name = "TensorMapSize";
    
    enum class Argument
    {
        input_handle,
        size
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AudioSummaryV2
{
    static constexpr const char* name = "AudioSummaryV2";
    
    enum class Argument
    {
        tag,
        tensor,
        sample_rate,
        summary
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample_rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_outputs
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"max_outputs", AttributeType::Int}
    };
};

struct TensorMapErase
{
    static constexpr const char* name = "TensorMapErase";
    
    enum class Argument
    {
        input_handle,
        key,
        output_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct Assert
{
    static constexpr const char* name = "Assert";
    
    enum class Argument
    {
        condition,
        data
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"condition", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        summarize
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"summarize", AttributeType::Int}
    };
};

struct Print
{
    static constexpr const char* name = "Print";
    
    enum class Argument
    {
        input,
        data,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::SequenceAttrList, "U"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        message,
        first_n,
        summarize
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::ListType},
        AttributeDesc{"message", AttributeType::String},
        AttributeDesc{"first_n", AttributeType::Int},
        AttributeDesc{"summarize", AttributeType::Int}
    };
};

struct PrintV2
{
    static constexpr const char* name = "PrintV2";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        output_stream,
        end
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"output_stream", AttributeType::String},
        AttributeDesc{"end", AttributeType::String}
    };
};

struct TensorSummary
{
    static constexpr const char* name = "TensorSummary";
    
    enum class Argument
    {
        tensor,
        summary
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        description,
        labels,
        display_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"description", AttributeType::String},
        AttributeDesc{"labels", AttributeType::ListString},
        AttributeDesc{"display_name", AttributeType::String}
    };
};

struct LookupTableFind
{
    static constexpr const char* name = "LookupTableFind";
    
    enum class Argument
    {
        table_handle,
        keys,
        default_value,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"default_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct LookupTableFindV2
{
    static constexpr const char* name = "LookupTableFindV2";
    
    enum class Argument
    {
        table_handle,
        keys,
        default_value,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"default_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct SerializeTensor
{
    static constexpr const char* name = "SerializeTensor";
    
    enum class Argument
    {
        tensor,
        serialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LookupTableInsert
{
    static constexpr const char* name = "LookupTableInsert";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct _FusedBatchNormGradEx
{
    static constexpr const char* name = "_FusedBatchNormGradEx";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        offset,
        y,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_4,
        reserve_space_5,
        side_input_backprop
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_5", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"side_input_backprop", ArgumentDesc::TensorCount::SequenceAttrInt, "num_side_inputs"}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        num_side_inputs,
        activation_mode,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"num_side_inputs", AttributeType::Int},
        AttributeDesc{"activation_mode", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct InvGrad
{
    static constexpr const char* name = "InvGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LookupTableInsertV2
{
    static constexpr const char* name = "LookupTableInsertV2";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct BatchMatMulV3
{
    static constexpr const char* name = "BatchMatMulV3";
    
    enum class Argument
    {
        x,
        y,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Ta,
        Tb,
        Tout,
        adj_x,
        adj_y
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Ta", AttributeType::Type},
        AttributeDesc{"Tb", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type},
        AttributeDesc{"adj_x", AttributeType::Bool},
        AttributeDesc{"adj_y", AttributeType::Bool}
    };
};

struct LookupTableExport
{
    static constexpr const char* name = "LookupTableExport";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tkeys,
        Tvalues
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tkeys", AttributeType::Type},
        AttributeDesc{"Tvalues", AttributeType::Type}
    };
};

struct LookupTableExportV2
{
    static constexpr const char* name = "LookupTableExportV2";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tkeys,
        Tvalues
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tkeys", AttributeType::Type},
        AttributeDesc{"Tvalues", AttributeType::Type}
    };
};

struct Rsqrt
{
    static constexpr const char* name = "Rsqrt";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LookupTableImportV2
{
    static constexpr const char* name = "LookupTableImportV2";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct HashTable
{
    static constexpr const char* name = "HashTable";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct HashTableV2
{
    static constexpr const char* name = "HashTableV2";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct MutableHashTableV2
{
    static constexpr const char* name = "MutableHashTableV2";
    
    enum class Argument
    {
        table_handle
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type}
    };
};

struct SparseMatrixSparseCholesky
{
    static constexpr const char* name = "SparseMatrixSparseCholesky";
    
    enum class Argument
    {
        input,
        permutation,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"permutation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct MutableDenseHashTable
{
    static constexpr const char* name = "MutableDenseHashTable";
    
    enum class Argument
    {
        empty_key,
        table_handle
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"empty_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype,
        value_shape,
        initial_num_buckets,
        max_load_factor
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type},
        AttributeDesc{"value_shape", AttributeType::Shape},
        AttributeDesc{"initial_num_buckets", AttributeType::Int},
        AttributeDesc{"max_load_factor", AttributeType::Float}
    };
};

struct LSTMBlockCellGrad
{
    static constexpr const char* name = "LSTMBlockCellGrad";
    
    enum class Argument
    {
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        cs_grad,
        h_grad,
        cs_prev_grad,
        dicfo,
        wci_grad,
        wcf_grad,
        wco_grad
    };

    static constexpr uint32_t input_arg_count = 16;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dicfo", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MutableDenseHashTableV2
{
    static constexpr const char* name = "MutableDenseHashTableV2";
    
    enum class Argument
    {
        empty_key,
        deleted_key,
        table_handle
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"empty_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deleted_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        use_node_name_sharing,
        key_dtype,
        value_dtype,
        value_shape,
        initial_num_buckets,
        max_load_factor
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"use_node_name_sharing", AttributeType::Bool},
        AttributeDesc{"key_dtype", AttributeType::Type},
        AttributeDesc{"value_dtype", AttributeType::Type},
        AttributeDesc{"value_shape", AttributeType::Shape},
        AttributeDesc{"initial_num_buckets", AttributeType::Int},
        AttributeDesc{"max_load_factor", AttributeType::Float}
    };
};

struct DenseToDenseSetOperation
{
    static constexpr const char* name = "DenseToDenseSetOperation";
    
    enum class Argument
    {
        set1,
        set2,
        result_indices,
        result_values,
        result_shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"set1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        set_operation,
        validate_indices,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"set_operation", AttributeType::String},
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RandomPoisson
{
    static constexpr const char* name = "RandomPoisson";
    
    enum class Argument
    {
        shape,
        rate,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        S,
        dtype
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct InitializeTable
{
    static constexpr const char* name = "InitializeTable";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tkey,
        Tval
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tkey", AttributeType::Type},
        AttributeDesc{"Tval", AttributeType::Type}
    };
};

struct _MklFusedConv2D
{
    static constexpr const char* name = "_MklFusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        mkl_input,
        mkl_filter,
        mkl_args,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations,
        use_cudnn_on_gpu,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 12> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct SparseMatMul
{
    static constexpr const char* name = "SparseMatMul";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        transpose_a,
        transpose_b,
        a_is_sparse,
        b_is_sparse,
        Ta,
        Tb
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"a_is_sparse", AttributeType::Bool},
        AttributeDesc{"b_is_sparse", AttributeType::Bool},
        AttributeDesc{"Ta", AttributeType::Type},
        AttributeDesc{"Tb", AttributeType::Type}
    };
};

struct RandomPoissonV2
{
    static constexpr const char* name = "RandomPoissonV2";
    
    enum class Argument
    {
        shape,
        rate,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rate", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        S,
        R,
        dtype
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"R", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct InitializeTableV2
{
    static constexpr const char* name = "InitializeTableV2";
    
    enum class Argument
    {
        table_handle,
        keys,
        values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tkey,
        Tval
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tkey", AttributeType::Type},
        AttributeDesc{"Tval", AttributeType::Type}
    };
};

struct ApplyAdam
{
    static constexpr const char* name = "ApplyAdam";
    
    enum class Argument
    {
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct InitializeTableFromTextFile
{
    static constexpr const char* name = "InitializeTableFromTextFile";
    
    enum class Argument
    {
        table_handle,
        filename
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_index,
        value_index,
        vocab_size,
        delimiter,
        offset
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"key_index", AttributeType::Int},
        AttributeDesc{"value_index", AttributeType::Int},
        AttributeDesc{"vocab_size", AttributeType::Int},
        AttributeDesc{"delimiter", AttributeType::String},
        AttributeDesc{"offset", AttributeType::Int}
    };
};

struct For
{
    static constexpr const char* name = "For";
    
    enum class Argument
    {
        start,
        limit,
        delta,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"limit", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        body
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"body", AttributeType::Func}
    };
};

struct Tanh
{
    static constexpr const char* name = "Tanh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct InitializeTableFromTextFileV2
{
    static constexpr const char* name = "InitializeTableFromTextFileV2";
    
    enum class Argument
    {
        table_handle,
        filename
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"table_handle", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filename", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        key_index,
        value_index,
        vocab_size,
        delimiter,
        offset
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"key_index", AttributeType::Int},
        AttributeDesc{"value_index", AttributeType::Int},
        AttributeDesc{"vocab_size", AttributeType::Int},
        AttributeDesc{"delimiter", AttributeType::String},
        AttributeDesc{"offset", AttributeType::Int}
    };
};

struct ResourceSparseApplyFtrlV2
{
    static constexpr const char* name = "ResourceSparseApplyFtrlV2";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_shrinkage", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct AccumulateNV2
{
    static constexpr const char* name = "AccumulateNV2";
    
    enum class Argument
    {
        inputs,
        sum
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"sum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        shape
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct BatchMatMulV2
{
    static constexpr const char* name = "BatchMatMulV2";
    
    enum class Argument
    {
        x,
        y,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        adj_x,
        adj_y
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"adj_x", AttributeType::Bool},
        AttributeDesc{"adj_y", AttributeType::Bool}
    };
};

struct RiscAbs
{
    static constexpr const char* name = "RiscAbs";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklBatchMatMulV2
{
    static constexpr const char* name = "_MklBatchMatMulV2";
    
    enum class Argument
    {
        x,
        y,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        adj_x,
        adj_y
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"adj_x", AttributeType::Bool},
        AttributeDesc{"adj_y", AttributeType::Bool}
    };
};

struct _MklLeakyReluGrad
{
    static constexpr const char* name = "_MklLeakyReluGrad";
    
    enum class Argument
    {
        gradients,
        features,
        mkl_gradients,
        mkl_features,
        backprops,
        mkl_backprops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        alpha
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"alpha", AttributeType::Float}
    };
};

struct Cast
{
    static constexpr const char* name = "Cast";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        SrcT,
        DstT,
        Truncate
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"SrcT", AttributeType::Type},
        AttributeDesc{"DstT", AttributeType::Type},
        AttributeDesc{"Truncate", AttributeType::Bool}
    };
};

struct Abs
{
    static constexpr const char* name = "Abs";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ComplexAbs
{
    static constexpr const char* name = "ComplexAbs";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct TPUCompile
{
    static constexpr const char* name = "TPUCompile";
    
    enum class Argument
    {
        dynamic_shapes,
        guaranteed_constants,
        compilation_status,
        program,
        may_modify_variables
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dynamic_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "NumDynamicShapes"},
        ArgumentDesc{"guaranteed_constants", ArgumentDesc::TensorCount::SequenceAttrList, "Tguaranteed_constants"},
        ArgumentDesc{"compilation_status", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"program", ArgumentDesc::TensorCount::SequenceAttrInt, "num_computations"},
        ArgumentDesc{"may_modify_variables", ArgumentDesc::TensorCount::SequenceAttrInt, "num_computations"}
    };

    enum class Attribute
    {
        num_computations,
        function,
        metadata,
        NumDynamicShapes,
        Tguaranteed_constants
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"num_computations", AttributeType::Int},
        AttributeDesc{"function", AttributeType::Func},
        AttributeDesc{"metadata", AttributeType::String},
        AttributeDesc{"NumDynamicShapes", AttributeType::Int},
        AttributeDesc{"Tguaranteed_constants", AttributeType::ListType}
    };
};

struct RiscGather
{
    static constexpr const char* name = "RiscGather";
    
    enum class Argument
    {
        params,
        indices,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"params", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        batch_dims,
        Tparams,
        Tindices,
        Taxis
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"batch_dims", AttributeType::Int},
        AttributeDesc{"Tparams", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Taxis", AttributeType::Type}
    };
};

struct Neg
{
    static constexpr const char* name = "Neg";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Softmax
{
    static constexpr const char* name = "Softmax";
    
    enum class Argument
    {
        logits,
        softmax
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"softmax", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Erfc
{
    static constexpr const char* name = "Erfc";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Expint
{
    static constexpr const char* name = "Expint";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ReciprocalGrad
{
    static constexpr const char* name = "ReciprocalGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatelessRandomUniformFullIntV2
{
    static constexpr const char* name = "StatelessRandomUniformFullIntV2";
    
    enum class Argument
    {
        shape,
        key,
        counter,
        alg,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct DataFormatVecPermute
{
    static constexpr const char* name = "DataFormatVecPermute";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        src_format,
        dst_format
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"src_format", AttributeType::String},
        AttributeDesc{"dst_format", AttributeType::String}
    };
};

struct Square
{
    static constexpr const char* name = "Square";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklQuantizedConv2D
{
    static constexpr const char* name = "_MklQuantizedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct StringToHashBucket
{
    static constexpr const char* name = "StringToHashBucket";
    
    enum class Argument
    {
        string_tensor,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"string_tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_buckets
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_buckets", AttributeType::Int}
    };
};

struct Sinh
{
    static constexpr const char* name = "Sinh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Cosh
{
    static constexpr const char* name = "Cosh";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatelessRandomUniform
{
    static constexpr const char* name = "StatelessRandomUniform";
    
    enum class Argument
    {
        shape,
        seed,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct TanhGrad
{
    static constexpr const char* name = "TanhGrad";
    
    enum class Argument
    {
        y,
        dy,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dy", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Digamma
{
    static constexpr const char* name = "Digamma";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Ndtri
{
    static constexpr const char* name = "Ndtri";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Cos
{
    static constexpr const char* name = "Cos";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Asin
{
    static constexpr const char* name = "Asin";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RequantizationRange
{
    static constexpr const char* name = "RequantizationRange";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type}
    };
};

struct Atan
{
    static constexpr const char* name = "Atan";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Polygamma
{
    static constexpr const char* name = "Polygamma";
    
    enum class Argument
    {
        a,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _ListToArray
{
    static constexpr const char* name = "_ListToArray";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        Tin,
        T,
        N
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct AddV2
{
    static constexpr const char* name = "AddV2";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaSelectAndScatter
{
    static constexpr const char* name = "XlaSelectAndScatter";
    
    enum class Argument
    {
        operand,
        window_dimensions,
        window_strides,
        padding,
        source,
        init_value,
        output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"operand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_dimensions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"source", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"init_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        select,
        scatter
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"select", AttributeType::Func},
        AttributeDesc{"scatter", AttributeType::Func}
    };
};

struct _MklAdd
{
    static constexpr const char* name = "_MklAdd";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseSoftmax
{
    static constexpr const char* name = "SparseSoftmax";
    
    enum class Argument
    {
        sp_indices,
        sp_values,
        sp_shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sp_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Conv2DBackpropFilter
{
    static constexpr const char* name = "Conv2DBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklAddV2
{
    static constexpr const char* name = "_MklAddV2";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Sub
{
    static constexpr const char* name = "Sub";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklSub
{
    static constexpr const char* name = "_MklSub";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LoadTPUEmbeddingProximalAdagradParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingProximalAdagradParameters";
    
    enum class Argument
    {
        parameters,
        accumulators
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct ParseSequenceExampleV2
{
    static constexpr const char* name = "ParseSequenceExampleV2";
    
    enum class Argument
    {
        serialized,
        debug_name,
        context_sparse_keys,
        context_dense_keys,
        context_ragged_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        feature_list_ragged_keys,
        feature_list_dense_missing_assumed_empty,
        context_dense_defaults,
        context_sparse_indices,
        context_sparse_values,
        context_sparse_shapes,
        context_dense_values,
        context_ragged_values,
        context_ragged_row_splits,
        feature_list_sparse_indices,
        feature_list_sparse_values,
        feature_list_sparse_shapes,
        feature_list_dense_values,
        feature_list_dense_lengths,
        feature_list_ragged_values,
        feature_list_ragged_outer_splits,
        feature_list_ragged_inner_splits
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 14;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"debug_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_sparse_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_dense_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_ragged_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_list_sparse_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_list_dense_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_list_ragged_keys", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_list_dense_missing_assumed_empty", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"context_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "context_sparse_types"},
        ArgumentDesc{"context_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"context_ragged_values", ArgumentDesc::TensorCount::SequenceAttrList, "context_ragged_value_types"},
        ArgumentDesc{"context_ragged_row_splits", ArgumentDesc::TensorCount::SequenceAttrList, "context_ragged_split_types"},
        ArgumentDesc{"feature_list_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_sparse_types"},
        ArgumentDesc{"feature_list_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_dense_types"},
        ArgumentDesc{"feature_list_dense_lengths", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_dense"},
        ArgumentDesc{"feature_list_ragged_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_ragged_value_types"},
        ArgumentDesc{"feature_list_ragged_outer_splits", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_ragged_split_types"},
        ArgumentDesc{"feature_list_ragged_inner_splits", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_ragged_split_types"}
    };

    enum class Attribute
    {
        Ncontext_sparse,
        Tcontext_dense,
        context_sparse_types,
        context_ragged_value_types,
        context_ragged_split_types,
        context_dense_shapes,
        Nfeature_list_sparse,
        Nfeature_list_dense,
        feature_list_dense_types,
        feature_list_sparse_types,
        feature_list_ragged_value_types,
        feature_list_ragged_split_types,
        feature_list_dense_shapes
    };

    static constexpr std::array<AttributeDesc, 13> attribute_descs
    {
        AttributeDesc{"Ncontext_sparse", AttributeType::Int},
        AttributeDesc{"Tcontext_dense", AttributeType::ListType},
        AttributeDesc{"context_sparse_types", AttributeType::ListType},
        AttributeDesc{"context_ragged_value_types", AttributeType::ListType},
        AttributeDesc{"context_ragged_split_types", AttributeType::ListType},
        AttributeDesc{"context_dense_shapes", AttributeType::ListShape},
        AttributeDesc{"Nfeature_list_sparse", AttributeType::Int},
        AttributeDesc{"Nfeature_list_dense", AttributeType::Int},
        AttributeDesc{"feature_list_dense_types", AttributeType::ListType},
        AttributeDesc{"feature_list_sparse_types", AttributeType::ListType},
        AttributeDesc{"feature_list_ragged_value_types", AttributeType::ListType},
        AttributeDesc{"feature_list_ragged_split_types", AttributeType::ListType},
        AttributeDesc{"feature_list_dense_shapes", AttributeType::ListShape}
    };
};

struct Mul
{
    static constexpr const char* name = "Mul";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklMul
{
    static constexpr const char* name = "_MklMul";
    
    enum class Argument
    {
        x,
        y,
        mkl_x,
        mkl_y,
        z,
        mkl_z
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Xlogy
{
    static constexpr const char* name = "Xlogy";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Xdivy
{
    static constexpr const char* name = "Xdivy";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Maximum
{
    static constexpr const char* name = "Maximum";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Minimum
{
    static constexpr const char* name = "Minimum";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedMatMulWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedMatMulWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String}
    };
};

struct Pow
{
    static constexpr const char* name = "Pow";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Igamma
{
    static constexpr const char* name = "Igamma";
    
    enum class Argument
    {
        a,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ApplyGradientDescent
{
    static constexpr const char* name = "ApplyGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        delta,
        out
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct Zeta
{
    static constexpr const char* name = "Zeta";
    
    enum class Argument
    {
        x,
        q,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"q", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Atan2
{
    static constexpr const char* name = "Atan2";
    
    enum class Argument
    {
        y,
        x,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Less
{
    static constexpr const char* name = "Less";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LessEqual
{
    static constexpr const char* name = "LessEqual";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklQuantizedConv2DPerChannel
{
    static constexpr const char* name = "_MklQuantizedConv2DPerChannel";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct Greater
{
    static constexpr const char* name = "Greater";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct __MklDummyPadWithFusedConv2D
{
    static constexpr const char* name = "__MklDummyPadWithFusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        paddings,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        padding,
        data_format,
        dilations,
        fused_ops,
        Tpaddings,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct ResourceApplyAdamWithAmsgrad
{
    static constexpr const char* name = "ResourceApplyAdamWithAmsgrad";
    
    enum class Argument
    {
        var,
        m,
        v,
        vhat,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 11;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"vhat", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceApplyGradientDescent
{
    static constexpr const char* name = "ResourceApplyGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        delta
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct _MklPadWithConv2D
{
    static constexpr const char* name = "_MklPadWithConv2D";
    
    enum class Argument
    {
        input,
        filter,
        paddings,
        mkl_input,
        mkl_filter,
        mkl_paddings,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        is_filter_const,
        dilations,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct Equal
{
    static constexpr const char* name = "Equal";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        incompatible_shape_error
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"incompatible_shape_error", AttributeType::Bool}
    };
};

struct _MklQuantizedMatMulWithBiasAndRelu
{
    static constexpr const char* name = "_MklQuantizedMatMulWithBiasAndRelu";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode,
        is_weight_const
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String},
        AttributeDesc{"is_weight_const", AttributeType::Bool}
    };
};

struct Variable
{
    static constexpr const char* name = "Variable";
    
    enum class Argument
    {
        ref
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        dtype,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct LogicalNot
{
    static constexpr const char* name = "LogicalNot";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklNativeDepthwiseConv2dNativeBackpropFilter
{
    static constexpr const char* name = "_MklNativeDepthwiseConv2dNativeBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct EuclideanNorm
{
    static constexpr const char* name = "EuclideanNorm";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct LogicalAnd
{
    static constexpr const char* name = "LogicalAnd";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct LogicalOr
{
    static constexpr const char* name = "LogicalOr";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct MatMul
{
    static constexpr const char* name = "MatMul";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        transpose_a,
        transpose_b,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Max
{
    static constexpr const char* name = "Max";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct ArgMin
{
    static constexpr const char* name = "ArgMin";
    
    enum class Argument
    {
        input,
        dimension,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dimension", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        output_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"output_type", AttributeType::Type}
    };
};

struct LRNGrad
{
    static constexpr const char* name = "LRNGrad";
    
    enum class Argument
    {
        input_grads,
        input_image,
        output_image,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        depth_radius,
        bias,
        alpha,
        beta,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"depth_radius", AttributeType::Int},
        AttributeDesc{"bias", AttributeType::Float},
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"beta", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SegmentMean
{
    static constexpr const char* name = "SegmentMean";
    
    enum class Argument
    {
        data,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct CloseSummaryWriter
{
    static constexpr const char* name = "CloseSummaryWriter";
    
    enum class Argument
    {
        writer
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SegmentMin
{
    static constexpr const char* name = "SegmentMin";
    
    enum class Argument
    {
        data,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct SegmentMax
{
    static constexpr const char* name = "SegmentMax";
    
    enum class Argument
    {
        data,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct XlaIf
{
    static constexpr const char* name = "XlaIf";
    
    enum class Argument
    {
        cond,
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"cond", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tcond,
        then_branch,
        else_branch,
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Tcond", AttributeType::Type},
        AttributeDesc{"then_branch", AttributeType::Func},
        AttributeDesc{"else_branch", AttributeType::Func},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct UnsortedSegmentSum
{
    static constexpr const char* name = "UnsortedSegmentSum";
    
    enum class Argument
    {
        data,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        Tnumsegments
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type}
    };
};

struct SparseSegmentSum
{
    static constexpr const char* name = "SparseSegmentSum";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct SparseApplyProximalAdagrad
{
    static constexpr const char* name = "SparseApplyProximalAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        l1,
        l2,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct SparseSegmentMeanGrad
{
    static constexpr const char* name = "SparseSegmentMeanGrad";
    
    enum class Argument
    {
        grad,
        indices,
        segment_ids,
        output_dim0,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_dim0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct SparseSegmentSqrtN
{
    static constexpr const char* name = "SparseSegmentSqrtN";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct SparseSegmentSqrtNWithNumSegments
{
    static constexpr const char* name = "SparseSegmentSqrtNWithNumSegments";
    
    enum class Argument
    {
        data,
        indices,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx,
        Tnumsegments,
        Tsegmentids
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type},
        AttributeDesc{"Tsegmentids", AttributeType::Type}
    };
};

struct Any
{
    static constexpr const char* name = "Any";
    
    enum class Argument
    {
        input,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct RiscConcat
{
    static constexpr const char* name = "RiscConcat";
    
    enum class Argument
    {
        values,
        axis,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"axis", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct Range
{
    static constexpr const char* name = "Range";
    
    enum class Argument
    {
        start,
        limit,
        delta,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"limit", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct AssignVariableOp
{
    static constexpr const char* name = "AssignVariableOp";
    
    enum class Argument
    {
        resource,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct Conj
{
    static constexpr const char* name = "Conj";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Cross
{
    static constexpr const char* name = "Cross";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct HistogramFixedWidth
{
    static constexpr const char* name = "HistogramFixedWidth";
    
    enum class Argument
    {
        values,
        value_range,
        nbins,
        out
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value_range", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nbins", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct Bincount
{
    static constexpr const char* name = "Bincount";
    
    enum class Argument
    {
        arr,
        size,
        weights,
        bins
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"arr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bins", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseBincount
{
    static constexpr const char* name = "SparseBincount";
    
    enum class Argument
    {
        indices,
        values,
        dense_shape,
        size,
        weights,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx,
        T,
        binary_output
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"binary_output", AttributeType::Bool}
    };
};

struct RaggedBincount
{
    static constexpr const char* name = "RaggedBincount";
    
    enum class Argument
    {
        splits,
        values,
        size,
        weights,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tidx,
        T,
        binary_output
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tidx", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"binary_output", AttributeType::Bool}
    };
};

struct QuantizedMatMul
{
    static constexpr const char* name = "QuantizedMatMul";
    
    enum class Argument
    {
        a,
        b,
        min_a,
        max_a,
        min_b,
        max_b,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Toutput,
        transpose_a,
        transpose_b,
        Tactivation
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"Tactivation", AttributeType::Type}
    };
};

struct _NcclReduceSend
{
    static constexpr const char* name = "_NcclReduceSend";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reduction,
        T,
        num_devices,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"reduction", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct LSTMBlockCell
{
    static constexpr const char* name = "LSTMBlockCell";
    
    enum class Argument
    {
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        forget_bias,
        cell_clip,
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"forget_bias", AttributeType::Float},
        AttributeDesc{"cell_clip", AttributeType::Float},
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SoftmaxCrossEntropyWithLogits
{
    static constexpr const char* name = "SoftmaxCrossEntropyWithLogits";
    
    enum class Argument
    {
        features,
        labels,
        loss,
        backprop
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"loss", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedMul
{
    static constexpr const char* name = "QuantizedMul";
    
    enum class Argument
    {
        x,
        y,
        min_x,
        max_x,
        min_y,
        max_y,
        z,
        min_z,
        max_z
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_z", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Toutput
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type}
    };
};

struct _MklAddN
{
    static constexpr const char* name = "_MklAddN";
    
    enum class Argument
    {
        inputs,
        mkl_input,
        sum,
        mkl_sum
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"sum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_sum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Dilation2DBackpropInput
{
    static constexpr const char* name = "Dilation2DBackpropInput";
    
    enum class Argument
    {
        input,
        filter,
        out_backprop,
        in_backprop
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"in_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        rates,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"rates", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct RequantizePerChannel
{
    static constexpr const char* name = "RequantizePerChannel";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        output,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"requested_output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"requested_output_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct RequantizationRangePerChannel
{
    static constexpr const char* name = "RequantizationRangePerChannel";
    
    enum class Argument
    {
        input,
        input_min,
        input_max,
        output_min,
        output_max
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_min", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        clip_value_max
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"clip_value_max", AttributeType::Float}
    };
};

struct NcclReduce
{
    static constexpr const char* name = "NcclReduce";
    
    enum class Argument
    {
        input,
        data
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrInt, "num_devices"},
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        reduction,
        T,
        num_devices
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"reduction", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_devices", AttributeType::Int}
    };
};

struct NcclBroadcast
{
    static constexpr const char* name = "NcclBroadcast";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct AvgPool
{
    static constexpr const char* name = "AvgPool";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _FusedBatchNormEx
{
    static constexpr const char* name = "_FusedBatchNormEx";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        side_input,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"side_input", ArgumentDesc::TensorCount::SequenceAttrInt, "num_side_inputs"},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        exponential_avg_factor,
        num_side_inputs,
        activation_mode,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"num_side_inputs", AttributeType::Int},
        AttributeDesc{"activation_mode", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct FusedBatchNormGradV3
{
    static constexpr const char* name = "FusedBatchNormGradV3";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_4,
        reserve_space_5
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_5", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _FusedConv2D
{
    static constexpr const char* name = "_FusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        padding,
        explicit_paddings,
        data_format,
        dilations,
        use_cudnn_on_gpu,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct FusedResizeAndPadConv2D
{
    static constexpr const char* name = "FusedResizeAndPadConv2D";
    
    enum class Argument
    {
        input,
        size,
        paddings,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        resize_align_corners,
        mode,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"resize_align_corners", AttributeType::Bool},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct _MklEinsum
{
    static constexpr const char* name = "_MklEinsum";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        equation,
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"equation", AttributeType::String},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseDenseCwiseMul
{
    static constexpr const char* name = "SparseDenseCwiseMul";
    
    enum class Argument
    {
        sp_indices,
        sp_values,
        sp_shape,
        dense,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sp_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FusedPadConv2D
{
    static constexpr const char* name = "FusedPadConv2D";
    
    enum class Argument
    {
        input,
        paddings,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        mode,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct ApplyAdaMax
{
    static constexpr const char* name = "ApplyAdaMax";
    
    enum class Argument
    {
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct DepthwiseConv2dNative
{
    static constexpr const char* name = "DepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct SparseApplyAdadelta
{
    static constexpr const char* name = "SparseApplyAdadelta";
    
    enum class Argument
    {
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum_update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct DepthwiseConv2dNativeBackpropFilter
{
    static constexpr const char* name = "DepthwiseConv2dNativeBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct Conv3DBackpropFilter
{
    static constexpr const char* name = "Conv3DBackpropFilter";
    
    enum class Argument
    {
        input,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct MaxPool3D
{
    static constexpr const char* name = "MaxPool3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPool3DGrad
{
    static constexpr const char* name = "MaxPool3DGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T,
        TInput
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"TInput", AttributeType::Type}
    };
};

struct MaxPool3DGradGrad
{
    static constexpr const char* name = "MaxPool3DGradGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatelessIf
{
    static constexpr const char* name = "StatelessIf";
    
    enum class Argument
    {
        cond,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"cond", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tcond,
        Tin,
        Tout,
        then_branch,
        else_branch,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tcond", AttributeType::Type},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"then_branch", AttributeType::Func},
        AttributeDesc{"else_branch", AttributeType::Func},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct ScatterDiv
{
    static constexpr const char* name = "ScatterDiv";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct L2Loss
{
    static constexpr const char* name = "L2Loss";
    
    enum class Argument
    {
        t,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"t", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPoolGrad
{
    static constexpr const char* name = "MaxPoolGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        explicit_paddings,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPoolGradV2
{
    static constexpr const char* name = "MaxPoolGradV2";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        ksize,
        strides,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ksize", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPoolGradGradV2
{
    static constexpr const char* name = "MaxPoolGradGradV2";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        ksize,
        strides,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ksize", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _ScopedAllocatorSplit
{
    static constexpr const char* name = "_ScopedAllocatorSplit";
    
    enum class Argument
    {
        concat,
        split,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"concat", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"split", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        sa_name,
        id,
        N,
        shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"sa_name", AttributeType::String},
        AttributeDesc{"id", AttributeType::Int},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"shapes", AttributeType::ListShape}
    };
};

struct MaxPoolWithArgmax
{
    static constexpr const char* name = "MaxPoolWithArgmax";
    
    enum class Argument
    {
        input,
        output,
        argmax
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"argmax", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        Targmax,
        padding,
        include_batch_in_index,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"Targmax", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"include_batch_in_index", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct MaxPoolGradGradWithArgmax
{
    static constexpr const char* name = "MaxPoolGradGradWithArgmax";
    
    enum class Argument
    {
        input,
        grad,
        argmax,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"argmax", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        include_batch_in_index,
        Targmax,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"include_batch_in_index", AttributeType::Bool},
        AttributeDesc{"Targmax", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Dilation2D
{
    static constexpr const char* name = "Dilation2D";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        rates,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"rates", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct RiscTranspose
{
    static constexpr const char* name = "RiscTranspose";
    
    enum class Argument
    {
        x,
        perm,
        y
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"perm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tperm
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tperm", AttributeType::Type}
    };
};

struct _MklMaxPool3D
{
    static constexpr const char* name = "_MklMaxPool3D";
    
    enum class Argument
    {
        input,
        mkl_input,
        output,
        workspace,
        mkl_output,
        mkl_workspace
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct Dilation2DBackpropFilter
{
    static constexpr const char* name = "Dilation2DBackpropFilter";
    
    enum class Argument
    {
        input,
        filter,
        out_backprop,
        filter_backprop
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        rates,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"rates", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct StatelessCase
{
    static constexpr const char* name = "StatelessCase";
    
    enum class Argument
    {
        branch_index,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"branch_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        branches,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"branches", AttributeType::ListFunc},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct Relu
{
    static constexpr const char* name = "Relu";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ReluGrad
{
    static constexpr const char* name = "ReluGrad";
    
    enum class Argument
    {
        gradients,
        features,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LeakyRelu
{
    static constexpr const char* name = "LeakyRelu";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        alpha,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct LeakyReluGrad
{
    static constexpr const char* name = "LeakyReluGrad";
    
    enum class Argument
    {
        gradients,
        features,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        alpha,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Elu
{
    static constexpr const char* name = "Elu";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ConfigureDistributedTPU
{
    static constexpr const char* name = "ConfigureDistributedTPU";
    
    enum class Argument
    {
        topology
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"topology", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        embedding_config,
        tpu_embedding_config,
        is_global_init,
        enable_whole_mesh_compilations,
        compilation_failure_closes_chips,
        tpu_cancellation_closes_chips
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"embedding_config", AttributeType::String},
        AttributeDesc{"tpu_embedding_config", AttributeType::String},
        AttributeDesc{"is_global_init", AttributeType::Bool},
        AttributeDesc{"enable_whole_mesh_compilations", AttributeType::Bool},
        AttributeDesc{"compilation_failure_closes_chips", AttributeType::Bool},
        AttributeDesc{"tpu_cancellation_closes_chips", AttributeType::Int}
    };
};

struct EluGrad
{
    static constexpr const char* name = "EluGrad";
    
    enum class Argument
    {
        gradients,
        outputs,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Selu
{
    static constexpr const char* name = "Selu";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SeluGrad
{
    static constexpr const char* name = "SeluGrad";
    
    enum class Argument
    {
        gradients,
        outputs,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Softsign
{
    static constexpr const char* name = "Softsign";
    
    enum class Argument
    {
        features,
        activations
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SoftsignGrad
{
    static constexpr const char* name = "SoftsignGrad";
    
    enum class Argument
    {
        gradients,
        features,
        backprops
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklFusedBatchNormV2
{
    static constexpr const char* name = "_MklFusedBatchNormV2";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        mkl_x,
        mkl_scale,
        mkl_offset,
        mkl_mean,
        mkl_variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        mkl_y,
        mkl_batch_mean,
        mkl_batch_variance,
        mkl_reserve_space_1,
        mkl_reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 10;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct LogSoftmax
{
    static constexpr const char* name = "LogSoftmax";
    
    enum class Argument
    {
        logits,
        logsoftmax
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"logsoftmax", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseSoftmaxCrossEntropyWithLogits
{
    static constexpr const char* name = "SparseSoftmaxCrossEntropyWithLogits";
    
    enum class Argument
    {
        features,
        labels,
        loss,
        backprop
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"loss", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprop", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tlabels
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tlabels", AttributeType::Type}
    };
};

struct XlaConv
{
    static constexpr const char* name = "XlaConv";
    
    enum class Argument
    {
        lhs,
        rhs,
        window_strides,
        padding,
        lhs_dilation,
        rhs_dilation,
        feature_group_count,
        output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"lhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lhs_dilation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs_dilation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_group_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        dimension_numbers,
        precision_config
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"precision_config", AttributeType::String}
    };
};

struct InTopKV2
{
    static constexpr const char* name = "InTopKV2";
    
    enum class Argument
    {
        predictions,
        targets,
        k,
        precision
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"predictions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"targets", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"k", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"precision", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TopK
{
    static constexpr const char* name = "TopK";
    
    enum class Argument
    {
        input,
        values,
        indices
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        k,
        sorted,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"k", AttributeType::Int},
        AttributeDesc{"sorted", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FractionalMaxPoolGrad
{
    static constexpr const char* name = "FractionalMaxPoolGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        overlapping,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"overlapping", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TPUOrdinalSelector
{
    static constexpr const char* name = "TPUOrdinalSelector";
    
    enum class Argument
    {
        device_ordinals
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"device_ordinals", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BlockLSTMV2
{
    static constexpr const char* name = "BlockLSTMV2";
    
    enum class Argument
    {
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seq_len_max", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wcf", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"wco", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"i", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"cs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"f", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"o", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ci", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"co", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        cell_clip,
        use_peephole,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"cell_clip", AttributeType::Float},
        AttributeDesc{"use_peephole", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FractionalAvgPool
{
    static constexpr const char* name = "FractionalAvgPool";
    
    enum class Argument
    {
        value,
        output,
        row_pooling_sequence,
        col_pooling_sequence
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_pooling_sequence", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_pooling_sequence", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pooling_ratio,
        pseudo_random,
        overlapping,
        deterministic,
        seed,
        seed2,
        T
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"pooling_ratio", AttributeType::ListFloat},
        AttributeDesc{"pseudo_random", AttributeType::Bool},
        AttributeDesc{"overlapping", AttributeType::Bool},
        AttributeDesc{"deterministic", AttributeType::Bool},
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct PartitionedCall
{
    static constexpr const char* name = "PartitionedCall";
    
    enum class Argument
    {
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        f,
        config,
        config_proto,
        executor_type
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"config", AttributeType::String},
        AttributeDesc{"config_proto", AttributeType::String},
        AttributeDesc{"executor_type", AttributeType::String}
    };
};

struct QuantizedAvgPool
{
    static constexpr const char* name = "QuantizedAvgPool";
    
    enum class Argument
    {
        input,
        min_input,
        max_input,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct QuantizedBiasAdd
{
    static constexpr const char* name = "QuantizedBiasAdd";
    
    enum class Argument
    {
        input,
        bias,
        min_input,
        max_input,
        min_bias,
        max_bias,
        output,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        out_type
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct QuantizedConv2D
{
    static constexpr const char* name = "QuantizedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct QuantizedRelu
{
    static constexpr const char* name = "QuantizedRelu";
    
    enum class Argument
    {
        features,
        min_features,
        max_features,
        activations,
        min_activations,
        max_activations
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct SparseTensorToCSRSparseMatrix
{
    static constexpr const char* name = "SparseTensorToCSRSparseMatrix";
    
    enum class Argument
    {
        indices,
        values,
        dense_shape,
        sparse_matrix
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_matrix", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct QuantizedRelu6
{
    static constexpr const char* name = "QuantizedRelu6";
    
    enum class Argument
    {
        features,
        min_features,
        max_features,
        activations,
        min_activations,
        max_activations
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct _MklDepthwiseConv2dNative
{
    static constexpr const char* name = "_MklDepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        mkl_input,
        mkl_filter,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklConv2D
{
    static constexpr const char* name = "_MklConv2D";
    
    enum class Argument
    {
        input,
        filter,
        mkl_input,
        mkl_filter,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklNativeConv2D
{
    static constexpr const char* name = "_MklNativeConv2D";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        is_filter_const,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklRelu6Grad
{
    static constexpr const char* name = "_MklRelu6Grad";
    
    enum class Argument
    {
        gradients,
        features,
        mkl_gradients,
        mkl_features,
        backprops,
        mkl_backprops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct __MklDummyConv2DWithBias
{
    static constexpr const char* name = "__MklDummyConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        is_filter_const,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklConv2DWithBias
{
    static constexpr const char* name = "_MklConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        mkl_input,
        mkl_filter,
        mkl_bias,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        is_filter_const,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct __MklDummyPadWithConv2D
{
    static constexpr const char* name = "__MklDummyPadWithConv2D";
    
    enum class Argument
    {
        input,
        filter,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        dilations,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct TPUCompilationResult
{
    static constexpr const char* name = "TPUCompilationResult";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklConv2DBackpropFilter
{
    static constexpr const char* name = "_MklConv2DBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        mkl_input,
        mkl_filter_size,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct BesselI0
{
    static constexpr const char* name = "BesselI0";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct __MklDummyConv2DBackpropFilterWithBias
{
    static constexpr const char* name = "__MklDummyConv2DBackpropFilterWithBias";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output,
        bias_grad
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklConv2DBackpropInput
{
    static constexpr const char* name = "_MklConv2DBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        mkl_input_sizes,
        mkl_filter,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklNativeConv2DBackpropInput
{
    static constexpr const char* name = "_MklNativeConv2DBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        explicit_paddings,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklNativeMaxPoolGrad
{
    static constexpr const char* name = "_MklNativeMaxPoolGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        workspace,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        workspace_enabled,
        padding,
        data_format,
        explicit_paddings
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"workspace_enabled", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt}
    };
};

struct _MklConv3DBackpropInputV2
{
    static constexpr const char* name = "_MklConv3DBackpropInputV2";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        mkl_input_sizes,
        mkl_filter,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        dilations,
        Tshape,
        padding,
        data_format
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tshape", AttributeType::Type},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct _MklConv3DBackpropFilterV2
{
    static constexpr const char* name = "_MklConv3DBackpropFilterV2";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        mkl_input,
        mkl_filter_size,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct RiscLog
{
    static constexpr const char* name = "RiscLog";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklRelu
{
    static constexpr const char* name = "_MklRelu";
    
    enum class Argument
    {
        features,
        mkl_features,
        activations,
        mkl_activations
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklReluGrad
{
    static constexpr const char* name = "_MklReluGrad";
    
    enum class Argument
    {
        gradients,
        features,
        mkl_gradients,
        mkl_features,
        backprops,
        mkl_backprops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklRelu6
{
    static constexpr const char* name = "_MklRelu6";
    
    enum class Argument
    {
        features,
        mkl_features,
        activations,
        mkl_activations
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklLeakyRelu
{
    static constexpr const char* name = "_MklLeakyRelu";
    
    enum class Argument
    {
        features,
        mkl_features,
        activations,
        mkl_activations
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        alpha
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"alpha", AttributeType::Float}
    };
};

struct TPUEmbeddingActivations
{
    static constexpr const char* name = "TPUEmbeddingActivations";
    
    enum class Argument
    {
        embedding_variable,
        sliced_activations,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"embedding_variable", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sliced_activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        lookup_id
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"lookup_id", AttributeType::Int}
    };
};

struct _MklElu
{
    static constexpr const char* name = "_MklElu";
    
    enum class Argument
    {
        features,
        mkl_features,
        activations,
        mkl_activations
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklSoftmax
{
    static constexpr const char* name = "_MklSoftmax";
    
    enum class Argument
    {
        logits,
        mkl_logits,
        softmax,
        mkl_softmax
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"softmax", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_softmax", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklTanh
{
    static constexpr const char* name = "_MklTanh";
    
    enum class Argument
    {
        features,
        mkl_features,
        activations,
        mkl_activations
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"activations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_activations", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklTanhGrad
{
    static constexpr const char* name = "_MklTanhGrad";
    
    enum class Argument
    {
        gradients,
        features,
        mkl_gradients,
        mkl_features,
        backprops,
        mkl_backprops
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_gradients", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_features", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"backprops", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_backprops", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklAvgPool
{
    static constexpr const char* name = "_MklAvgPool";
    
    enum class Argument
    {
        value,
        mkl_input,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklQuantizedAvgPool
{
    static constexpr const char* name = "_MklQuantizedAvgPool";
    
    enum class Argument
    {
        input,
        min_input,
        max_input,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct _MklAvgPool3D
{
    static constexpr const char* name = "_MklAvgPool3D";
    
    enum class Argument
    {
        value,
        mkl_input,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseMatrixTranspose
{
    static constexpr const char* name = "SparseMatrixTranspose";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        conjugate,
        type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"conjugate", AttributeType::Bool},
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct _MklAvgPool3DGrad
{
    static constexpr const char* name = "_MklAvgPool3DGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        mkl_orig_input,
        mkl_grad,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativePadWithFusedConv2D
{
    static constexpr const char* name = "_MklNativePadWithFusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations,
        fused_ops,
        Tpaddings,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"Tpaddings", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct Recv
{
    static constexpr const char* name = "Recv";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        tensor_type,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"tensor_type", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct _MklMaxPool3DGrad
{
    static constexpr const char* name = "_MklMaxPool3DGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        workspace,
        mkl_orig_input,
        mkl_orig_output,
        mkl_grad,
        mkl_workspace,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T,
        TInput,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"TInput", AttributeType::Type},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct _MklLRNGrad
{
    static constexpr const char* name = "_MklLRNGrad";
    
    enum class Argument
    {
        input_grads,
        input_image,
        output_image,
        workspace,
        mkl_input_grads,
        mkl_input_image,
        mkl_output_image,
        mkl_workspace,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_grads", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output_image", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        depth_radius,
        bias,
        alpha,
        beta,
        workspace_enabled,
        T
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"depth_radius", AttributeType::Int},
        AttributeDesc{"bias", AttributeType::Float},
        AttributeDesc{"alpha", AttributeType::Float},
        AttributeDesc{"beta", AttributeType::Float},
        AttributeDesc{"workspace_enabled", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklFusedBatchNorm
{
    static constexpr const char* name = "_MklFusedBatchNorm";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        mkl_x,
        mkl_scale,
        mkl_offset,
        mkl_mean,
        mkl_variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        mkl_y,
        mkl_batch_mean,
        mkl_batch_variance,
        mkl_reserve_space_1,
        mkl_reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 10;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklFusedBatchNormGrad
{
    static constexpr const char* name = "_MklFusedBatchNormGrad";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        mkl_y_backprop,
        mkl_x,
        mkl_scale,
        mkl_reserve_space_1,
        mkl_reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4,
        mkl_x_backprop,
        mkl_scale_backprop,
        mkl_offset_backprop,
        mkl_reserve_space_3,
        mkl_reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 10;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklFusedBatchNormGradV2
{
    static constexpr const char* name = "_MklFusedBatchNormGradV2";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        mkl_y_backprop,
        mkl_x,
        mkl_scale,
        mkl_reserve_space_1,
        mkl_reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4,
        mkl_x_backprop,
        mkl_scale_backprop,
        mkl_offset_backprop,
        mkl_reserve_space_3,
        mkl_reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 10;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklToTf
{
    static constexpr const char* name = "_MklToTf";
    
    enum class Argument
    {
        input,
        mkl_input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        data_format
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct _MklInputConversion
{
    static constexpr const char* name = "_MklInputConversion";
    
    enum class Argument
    {
        input_0,
        input_1,
        mkl_input_0,
        mkl_input_1,
        output_0,
        output_1,
        mkl_output_0,
        mkl_output_1
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output_0", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output_1", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        data_format
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String}
    };
};

struct ResourceScatterMax
{
    static constexpr const char* name = "ResourceScatterMax";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct QuantizedConv2DAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedConv2DWithBiasAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DWithBiasAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct RiscBroadcast
{
    static constexpr const char* name = "RiscBroadcast";
    
    enum class Argument
    {
        input,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tidx
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tidx", AttributeType::Type}
    };
};

struct QuantizedConv2DAndRelu
{
    static constexpr const char* name = "QuantizedConv2DAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedConv2DWithBiasAndRelu
{
    static constexpr const char* name = "QuantizedConv2DWithBiasAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedConv2DWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedConv2DWithBiasSumAndRelu
{
    static constexpr const char* name = "QuantizedConv2DWithBiasSumAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedConv2DWithBiasSumAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DWithBiasSumAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        Tsummand,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Tsummand", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _ReadVariablesOp
{
    static constexpr const char* name = "_ReadVariablesOp";
    
    enum class Argument
    {
        resources,
        values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resources", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        N,
        dtypes
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"dtypes", AttributeType::ListType}
    };
};

struct QuantizedConv2DWithBiasSignedSumAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        Tsummand,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Tsummand", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct QuantizedMatMulWithBias
{
    static constexpr const char* name = "QuantizedMatMulWithBias";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String}
    };
};

struct QuantizedMatMulWithBiasAndDequantize
{
    static constexpr const char* name = "QuantizedMatMulWithBiasAndDequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String}
    };
};

struct QuantizedDepthwiseConv2D
{
    static constexpr const char* name = "QuantizedDepthwiseConv2D";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        strides,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        strides,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct ResourceScatterMul
{
    static constexpr const char* name = "ResourceScatterMul";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct RiscUnary
{
    static constexpr const char* name = "RiscUnary";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        op_type,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"op_type", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct NoOp
{
    static constexpr const char* name = "NoOp";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DecodeRaw
{
    static constexpr const char* name = "DecodeRaw";
    
    enum class Argument
    {
        bytes,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        out_type,
        little_endian
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"little_endian", AttributeType::Bool}
    };
};

struct ResourceApplyAdadelta
{
    static constexpr const char* name = "ResourceApplyAdadelta";
    
    enum class Argument
    {
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum_update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct DecodePaddedRaw
{
    static constexpr const char* name = "DecodePaddedRaw";
    
    enum class Argument
    {
        input_bytes,
        fixed_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fixed_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        out_type,
        little_endian
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"little_endian", AttributeType::Bool}
    };
};

struct DecodeCompressed
{
    static constexpr const char* name = "DecodeCompressed";
    
    enum class Argument
    {
        bytes,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"bytes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        compression_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"compression_type", AttributeType::String}
    };
};

struct ParseExample
{
    static constexpr const char* name = "ParseExample";
    
    enum class Argument
    {
        serialized,
        names,
        sparse_keys,
        dense_keys,
        dense_defaults,
        sparse_indices,
        sparse_values,
        sparse_shapes,
        dense_values
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"names", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Nsparse"},
        ArgumentDesc{"dense_keys", ArgumentDesc::TensorCount::SequenceAttrInt, "Ndense"},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Nsparse"},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Nsparse"},
        ArgumentDesc{"dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"}
    };

    enum class Attribute
    {
        Nsparse,
        Ndense,
        sparse_types,
        Tdense,
        dense_shapes
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"Nsparse", AttributeType::Int},
        AttributeDesc{"Ndense", AttributeType::Int},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape}
    };
};

struct ParseSingleExample
{
    static constexpr const char* name = "ParseSingleExample";
    
    enum class Argument
    {
        serialized,
        dense_defaults,
        sparse_indices,
        sparse_values,
        sparse_shapes,
        dense_values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse"},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse"},
        ArgumentDesc{"dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tdense"}
    };

    enum class Attribute
    {
        num_sparse,
        sparse_keys,
        dense_keys,
        sparse_types,
        Tdense,
        dense_shapes
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"num_sparse", AttributeType::Int},
        AttributeDesc{"sparse_keys", AttributeType::ListString},
        AttributeDesc{"dense_keys", AttributeType::ListString},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"Tdense", AttributeType::ListType},
        AttributeDesc{"dense_shapes", AttributeType::ListShape}
    };
};

struct ParseSequenceExample
{
    static constexpr const char* name = "ParseSequenceExample";
    
    enum class Argument
    {
        serialized,
        debug_name,
        context_dense_defaults,
        context_sparse_indices,
        context_sparse_values,
        context_sparse_shapes,
        context_dense_values,
        feature_list_sparse_indices,
        feature_list_sparse_values,
        feature_list_sparse_shapes,
        feature_list_dense_values,
        feature_list_dense_lengths
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 9;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"debug_name", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"context_dense_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"context_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "context_sparse_types"},
        ArgumentDesc{"context_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Ncontext_sparse"},
        ArgumentDesc{"context_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "Tcontext_dense"},
        ArgumentDesc{"feature_list_sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_sparse_types"},
        ArgumentDesc{"feature_list_sparse_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_sparse"},
        ArgumentDesc{"feature_list_dense_values", ArgumentDesc::TensorCount::SequenceAttrList, "feature_list_dense_types"},
        ArgumentDesc{"feature_list_dense_lengths", ArgumentDesc::TensorCount::SequenceAttrInt, "Nfeature_list_dense"}
    };

    enum class Attribute
    {
        feature_list_dense_missing_assumed_empty,
        context_sparse_keys,
        context_dense_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        Ncontext_sparse,
        Ncontext_dense,
        Nfeature_list_sparse,
        Nfeature_list_dense,
        context_sparse_types,
        Tcontext_dense,
        feature_list_dense_types,
        context_dense_shapes,
        feature_list_sparse_types,
        feature_list_dense_shapes
    };

    static constexpr std::array<AttributeDesc, 15> attribute_descs
    {
        AttributeDesc{"feature_list_dense_missing_assumed_empty", AttributeType::ListString},
        AttributeDesc{"context_sparse_keys", AttributeType::ListString},
        AttributeDesc{"context_dense_keys", AttributeType::ListString},
        AttributeDesc{"feature_list_sparse_keys", AttributeType::ListString},
        AttributeDesc{"feature_list_dense_keys", AttributeType::ListString},
        AttributeDesc{"Ncontext_sparse", AttributeType::Int},
        AttributeDesc{"Ncontext_dense", AttributeType::Int},
        AttributeDesc{"Nfeature_list_sparse", AttributeType::Int},
        AttributeDesc{"Nfeature_list_dense", AttributeType::Int},
        AttributeDesc{"context_sparse_types", AttributeType::ListType},
        AttributeDesc{"Tcontext_dense", AttributeType::ListType},
        AttributeDesc{"feature_list_dense_types", AttributeType::ListType},
        AttributeDesc{"context_dense_shapes", AttributeType::ListShape},
        AttributeDesc{"feature_list_sparse_types", AttributeType::ListType},
        AttributeDesc{"feature_list_dense_shapes", AttributeType::ListShape}
    };
};

struct DecodeJSONExample
{
    static constexpr const char* name = "DecodeJSONExample";
    
    enum class Argument
    {
        json_examples,
        binary_examples
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"json_examples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"binary_examples", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct DecodeCSV
{
    static constexpr const char* name = "DecodeCSV";
    
    enum class Argument
    {
        records,
        record_defaults,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"records", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"record_defaults", ArgumentDesc::TensorCount::SequenceAttrList, "OUT_TYPE"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "OUT_TYPE"}
    };

    enum class Attribute
    {
        OUT_TYPE,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"OUT_TYPE", AttributeType::ListType},
        AttributeDesc{"field_delim", AttributeType::String},
        AttributeDesc{"use_quote_delim", AttributeType::Bool},
        AttributeDesc{"na_value", AttributeType::String},
        AttributeDesc{"select_cols", AttributeType::ListInt}
    };
};

struct StringToNumber
{
    static constexpr const char* name = "StringToNumber";
    
    enum class Argument
    {
        string_tensor,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"string_tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        out_type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct RaggedCross
{
    static constexpr const char* name = "RaggedCross";
    
    enum class Argument
    {
        ragged_values,
        ragged_row_splits,
        sparse_indices,
        sparse_values,
        sparse_shape,
        dense_inputs,
        output_values,
        output_row_splits
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ragged_values", ArgumentDesc::TensorCount::SequenceAttrList, "ragged_values_types"},
        ArgumentDesc{"ragged_row_splits", ArgumentDesc::TensorCount::SequenceAttrList, "ragged_splits_types"},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "Nsparse"},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_values_types"},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::SequenceAttrInt, "Nsparse"},
        ArgumentDesc{"dense_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dense_types"},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_row_splits", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Nsparse,
        input_order,
        hashed_output,
        num_buckets,
        hash_key,
        ragged_values_types,
        ragged_splits_types,
        sparse_values_types,
        dense_types,
        out_values_type,
        out_row_splits_type
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"Nsparse", AttributeType::Int},
        AttributeDesc{"input_order", AttributeType::String},
        AttributeDesc{"hashed_output", AttributeType::Bool},
        AttributeDesc{"num_buckets", AttributeType::Int},
        AttributeDesc{"hash_key", AttributeType::Int},
        AttributeDesc{"ragged_values_types", AttributeType::ListType},
        AttributeDesc{"ragged_splits_types", AttributeType::ListType},
        AttributeDesc{"sparse_values_types", AttributeType::ListType},
        AttributeDesc{"dense_types", AttributeType::ListType},
        AttributeDesc{"out_values_type", AttributeType::Type},
        AttributeDesc{"out_row_splits_type", AttributeType::Type}
    };
};

struct RaggedTensorToSparse
{
    static constexpr const char* name = "RaggedTensorToSparse";
    
    enum class Argument
    {
        rt_nested_splits,
        rt_dense_values,
        sparse_indices,
        sparse_values,
        sparse_dense_shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"rt_nested_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "RAGGED_RANK"},
        ArgumentDesc{"rt_dense_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_dense_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        RAGGED_RANK,
        T,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"RAGGED_RANK", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct RaggedTensorFromVariant
{
    static constexpr const char* name = "RaggedTensorFromVariant";
    
    enum class Argument
    {
        encoded_ragged,
        output_nested_splits,
        output_dense_values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"encoded_ragged", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_nested_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "output_ragged_rank"},
        ArgumentDesc{"output_dense_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        input_ragged_rank,
        output_ragged_rank,
        Tvalues,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"input_ragged_rank", AttributeType::Int},
        AttributeDesc{"output_ragged_rank", AttributeType::Int},
        AttributeDesc{"Tvalues", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct RaggedTensorToVariantGradient
{
    static constexpr const char* name = "RaggedTensorToVariantGradient";
    
    enum class Argument
    {
        encoded_ragged_grad,
        row_splits,
        dense_values_shape,
        dense_values_grad
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"encoded_ragged_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_values_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_values_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tvalues,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tvalues", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct RaggedRange
{
    static constexpr const char* name = "RaggedRange";
    
    enum class Argument
    {
        starts,
        limits,
        deltas,
        rt_nested_splits,
        rt_dense_values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"starts", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"limits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"deltas", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rt_nested_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rt_dense_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct RandomUniform
{
    static constexpr const char* name = "RandomUniform";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        dtype,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RandomUniformInt
{
    static constexpr const char* name = "RandomUniformInt";
    
    enum class Argument
    {
        shape,
        minval,
        maxval,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        Tout,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"Tout", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RandomStandardNormal
{
    static constexpr const char* name = "RandomStandardNormal";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        dtype,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatefulStandardNormal
{
    static constexpr const char* name = "StatefulStandardNormal";
    
    enum class Argument
    {
        resource,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct ParameterizedTruncatedNormal
{
    static constexpr const char* name = "ParameterizedTruncatedNormal";
    
    enum class Argument
    {
        shape,
        means,
        stdevs,
        minvals,
        maxvals,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"means", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stdevs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minvals", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxvals", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        dtype,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TruncatedNormal
{
    static constexpr const char* name = "TruncatedNormal";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        seed2,
        dtype,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"seed2", AttributeType::Int},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RandomGammaGrad
{
    static constexpr const char* name = "RandomGammaGrad";
    
    enum class Argument
    {
        alpha,
        sample,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sample", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscAdd
{
    static constexpr const char* name = "RiscAdd";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscBinaryComparison
{
    static constexpr const char* name = "RiscBinaryComparison";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        op_type,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"op_type", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscCast
{
    static constexpr const char* name = "RiscCast";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        SrcT,
        DstT
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"SrcT", AttributeType::Type},
        AttributeDesc{"DstT", AttributeType::Type}
    };
};

struct RiscConv
{
    static constexpr const char* name = "RiscConv";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct RiscCos
{
    static constexpr const char* name = "RiscCos";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeDepthwiseConv2dNative
{
    static constexpr const char* name = "_MklNativeDepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct RiscDiv
{
    static constexpr const char* name = "RiscDiv";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscDot
{
    static constexpr const char* name = "RiscDot";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        transpose_a,
        transpose_b,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscFloor
{
    static constexpr const char* name = "RiscFloor";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscImag
{
    static constexpr const char* name = "RiscImag";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tout
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tout", AttributeType::Type}
    };
};

struct RiscIsFinite
{
    static constexpr const char* name = "RiscIsFinite";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscLogicalAnd
{
    static constexpr const char* name = "RiscLogicalAnd";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RiscLogicalOr
{
    static constexpr const char* name = "RiscLogicalOr";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FFT3D
{
    static constexpr const char* name = "FFT3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct RiscMax
{
    static constexpr const char* name = "RiscMax";
    
    enum class Argument
    {
        x,
        y,
        max
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscMul
{
    static constexpr const char* name = "RiscMul";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscPad
{
    static constexpr const char* name = "RiscPad";
    
    enum class Argument
    {
        input,
        paddings,
        constant_values,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"constant_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct SendTPUEmbeddingGradients
{
    static constexpr const char* name = "SendTPUEmbeddingGradients";
    
    enum class Argument
    {
        inputs,
        learning_rates
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"learning_rates", ArgumentDesc::TensorCount::SequenceAttrInt, "NN"}
    };

    enum class Attribute
    {
        N,
        NN,
        config
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"NN", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RiscPool
{
    static constexpr const char* name = "RiscPool";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        pooling_type,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"pooling_type", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct TemporaryVariable
{
    static constexpr const char* name = "TemporaryVariable";
    
    enum class Argument
    {
        ref
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        dtype,
        var_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"var_name", AttributeType::String}
    };
};

struct RiscPow
{
    static constexpr const char* name = "RiscPow";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscRandomUniform
{
    static constexpr const char* name = "RiscRandomUniform";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        seed,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"seed", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscReshape
{
    static constexpr const char* name = "RiscReshape";
    
    enum class Argument
    {
        tensor,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct RiscShape
{
    static constexpr const char* name = "RiscShape";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct WriteRawProtoSummary
{
    static constexpr const char* name = "WriteRawProtoSummary";
    
    enum class Argument
    {
        writer,
        step,
        tensor
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RiscSub
{
    static constexpr const char* name = "RiscSub";
    
    enum class Argument
    {
        x,
        y,
        z
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"z", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscTriangularSolve
{
    static constexpr const char* name = "RiscTriangularSolve";
    
    enum class Argument
    {
        matrix,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        lower,
        adjoint,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"lower", AttributeType::Bool},
        AttributeDesc{"adjoint", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RiscWhile
{
    static constexpr const char* name = "RiscWhile";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        cond,
        body,
        output_shapes,
        parallel_iterations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"cond", AttributeType::Func},
        AttributeDesc{"body", AttributeType::Func},
        AttributeDesc{"output_shapes", AttributeType::ListShape},
        AttributeDesc{"parallel_iterations", AttributeType::Int}
    };
};

struct GRUBlockCellGrad
{
    static constexpr const char* name = "GRUBlockCellGrad";
    
    enum class Argument
    {
        x,
        h_prev,
        w_ru,
        w_c,
        b_ru,
        b_c,
        r,
        u,
        c,
        d_h,
        d_x,
        d_h_prev,
        d_c_bar,
        d_r_bar_u_bar
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_ru", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_ru", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"r", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"u", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_h", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_h_prev", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_c_bar", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"d_r_bar_u_bar", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StringNGrams
{
    static constexpr const char* name = "StringNGrams";
    
    enum class Argument
    {
        data,
        data_splits,
        ngrams,
        ngrams_splits
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"data_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ngrams", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ngrams_splits", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        separator,
        ngram_widths,
        left_pad,
        right_pad,
        pad_width,
        preserve_short_sequences,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"separator", AttributeType::String},
        AttributeDesc{"ngram_widths", AttributeType::ListInt},
        AttributeDesc{"left_pad", AttributeType::String},
        AttributeDesc{"right_pad", AttributeType::String},
        AttributeDesc{"pad_width", AttributeType::Int},
        AttributeDesc{"preserve_short_sequences", AttributeType::Bool},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct Dawsn
{
    static constexpr const char* name = "Dawsn";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct FresnelSin
{
    static constexpr const char* name = "FresnelSin";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct Spence
{
    static constexpr const char* name = "Spence";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselI1
{
    static constexpr const char* name = "BesselI1";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselI0e
{
    static constexpr const char* name = "BesselI0e";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselI1e
{
    static constexpr const char* name = "BesselI1e";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselK0
{
    static constexpr const char* name = "BesselK0";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselK0e
{
    static constexpr const char* name = "BesselK0e";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselJ0
{
    static constexpr const char* name = "BesselJ0";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchFFT3D
{
    static constexpr const char* name = "BatchFFT3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BesselJ1
{
    static constexpr const char* name = "BesselJ1";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BesselY1
{
    static constexpr const char* name = "BesselY1";
    
    enum class Argument
    {
        x,
        y
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatefulTruncatedNormal
{
    static constexpr const char* name = "StatefulTruncatedNormal";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct XlaSelfAdjointEig
{
    static constexpr const char* name = "XlaSelfAdjointEig";
    
    enum class Argument
    {
        a,
        w,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"w", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        lower,
        max_iter,
        epsilon,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"lower", AttributeType::Bool},
        AttributeDesc{"max_iter", AttributeType::Int},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatefulUniformInt
{
    static constexpr const char* name = "StatefulUniformInt";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        minval,
        maxval,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxval", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct _MklQuantizedConv2DWithBiasAndRelu
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct RngSkip
{
    static constexpr const char* name = "RngSkip";
    
    enum class Argument
    {
        resource,
        algorithm,
        delta
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RngReadAndSkip
{
    static constexpr const char* name = "RngReadAndSkip";
    
    enum class Argument
    {
        resource,
        alg,
        delta,
        value
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct NonDeterministicInts
{
    static constexpr const char* name = "NonDeterministicInts";
    
    enum class Argument
    {
        shape,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape_dtype
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape_dtype", AttributeType::Type}
    };
};

struct ApplyAddSign
{
    static constexpr const char* name = "ApplyAddSign";
    
    enum class Argument
    {
        var,
        m,
        lr,
        alpha,
        sign_decay,
        beta,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sign_decay", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct StatefulRandomBinomial
{
    static constexpr const char* name = "StatefulRandomBinomial";
    
    enum class Argument
    {
        resource,
        algorithm,
        shape,
        counts,
        probs,
        output
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"algorithm", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counts", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"probs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        S,
        T,
        dtype
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct VarHandleOp
{
    static constexpr const char* name = "VarHandleOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name,
        dtype,
        shape,
        allowed_devices
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"allowed_devices", AttributeType::ListString}
    };
};

struct ReadVariableOp
{
    static constexpr const char* name = "ReadVariableOp";
    
    enum class Argument
    {
        resource,
        value
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct DestroyResourceOp
{
    static constexpr const char* name = "DestroyResourceOp";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ignore_lookup_error
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"ignore_lookup_error", AttributeType::Bool}
    };
};

struct AssignAddVariableOp
{
    static constexpr const char* name = "AssignAddVariableOp";
    
    enum class Argument
    {
        resource,
        value
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct ResourceGather
{
    static constexpr const char* name = "ResourceGather";
    
    enum class Argument
    {
        resource,
        indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        batch_dims,
        validate_indices,
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"batch_dims", AttributeType::Int},
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct StringSplit
{
    static constexpr const char* name = "StringSplit";
    
    enum class Argument
    {
        input,
        delimiter,
        indices,
        values,
        shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"delimiter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        skip_empty
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"skip_empty", AttributeType::Bool}
    };
};

struct ResourceGatherNd
{
    static constexpr const char* name = "ResourceGatherNd";
    
    enum class Argument
    {
        resource,
        indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct ResourceScatterSub
{
    static constexpr const char* name = "ResourceScatterSub";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct ResourceScatterMin
{
    static constexpr const char* name = "ResourceScatterMin";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct ResourceScatterUpdate
{
    static constexpr const char* name = "ResourceScatterUpdate";
    
    enum class Argument
    {
        resource,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct MakeUnique
{
    static constexpr const char* name = "MakeUnique";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct MutexV2
{
    static constexpr const char* name = "MutexV2";
    
    enum class Argument
    {
        resource
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct ConsumeMutexLock
{
    static constexpr const char* name = "ConsumeMutexLock";
    
    enum class Argument
    {
        mutex_lock
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"mutex_lock", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _ScopedAllocator
{
    static constexpr const char* name = "_ScopedAllocator";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shapes,
        shape,
        T,
        sa_name,
        id,
        expected_call_count
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"sa_name", AttributeType::String},
        AttributeDesc{"id", AttributeType::Int},
        AttributeDesc{"expected_call_count", AttributeType::Int}
    };
};

struct _ScopedAllocatorConcat
{
    static constexpr const char* name = "_ScopedAllocatorConcat";
    
    enum class Argument
    {
        backing,
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"backing", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        T,
        reshape,
        sa_name,
        id,
        N
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"reshape", AttributeType::Bool},
        AttributeDesc{"sa_name", AttributeType::String},
        AttributeDesc{"id", AttributeType::Int},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct _ShutdownDistributedTPU
{
    static constexpr const char* name = "_ShutdownDistributedTPU";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct PyFunc
{
    static constexpr const char* name = "PyFunc";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        token,
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"token", AttributeType::String},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct PyFuncStateless
{
    static constexpr const char* name = "PyFuncStateless";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        token,
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"token", AttributeType::String},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct EagerPyFunc
{
    static constexpr const char* name = "EagerPyFunc";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        token,
        is_async,
        Tin,
        Tout
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"token", AttributeType::String},
        AttributeDesc{"is_async", AttributeType::Bool},
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType}
    };
};

struct SdcaOptimizer
{
    static constexpr const char* name = "SdcaOptimizer";
    
    enum class Argument
    {
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        out_example_state_data,
        out_delta_sparse_weights,
        out_delta_dense_weights
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_example_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_feature_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_feature_values", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features_with_values"},
        ArgumentDesc{"dense_features", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"},
        ArgumentDesc{"example_weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"example_labels", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"dense_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"},
        ArgumentDesc{"example_state_data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_example_state_data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_delta_sparse_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"out_delta_dense_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"}
    };

    enum class Attribute
    {
        loss_type,
        adaptative,
        num_sparse_features,
        num_sparse_features_with_values,
        num_dense_features,
        l1,
        l2,
        num_loss_partitions,
        num_inner_iterations
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"loss_type", AttributeType::String},
        AttributeDesc{"adaptative", AttributeType::Bool},
        AttributeDesc{"num_sparse_features", AttributeType::Int},
        AttributeDesc{"num_sparse_features_with_values", AttributeType::Int},
        AttributeDesc{"num_dense_features", AttributeType::Int},
        AttributeDesc{"l1", AttributeType::Float},
        AttributeDesc{"l2", AttributeType::Float},
        AttributeDesc{"num_loss_partitions", AttributeType::Int},
        AttributeDesc{"num_inner_iterations", AttributeType::Int}
    };
};

struct SdcaOptimizerV2
{
    static constexpr const char* name = "SdcaOptimizerV2";
    
    enum class Argument
    {
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        out_example_state_data,
        out_delta_sparse_weights,
        out_delta_dense_weights
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_example_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_feature_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_feature_values", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features_with_values"},
        ArgumentDesc{"dense_features", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"},
        ArgumentDesc{"example_weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"example_labels", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"sparse_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"dense_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"},
        ArgumentDesc{"example_state_data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_example_state_data", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_delta_sparse_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_sparse_features"},
        ArgumentDesc{"out_delta_dense_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_dense_features"}
    };

    enum class Attribute
    {
        loss_type,
        adaptive,
        num_sparse_features,
        num_sparse_features_with_values,
        num_dense_features,
        l1,
        l2,
        num_loss_partitions,
        num_inner_iterations
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"loss_type", AttributeType::String},
        AttributeDesc{"adaptive", AttributeType::Bool},
        AttributeDesc{"num_sparse_features", AttributeType::Int},
        AttributeDesc{"num_sparse_features_with_values", AttributeType::Int},
        AttributeDesc{"num_dense_features", AttributeType::Int},
        AttributeDesc{"l1", AttributeType::Float},
        AttributeDesc{"l2", AttributeType::Float},
        AttributeDesc{"num_loss_partitions", AttributeType::Int},
        AttributeDesc{"num_inner_iterations", AttributeType::Int}
    };
};

struct SdcaShrinkL1
{
    static constexpr const char* name = "SdcaShrinkL1";
    
    enum class Argument
    {
        weights
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::SequenceAttrInt, "num_features"}
    };

    enum class Attribute
    {
        num_features,
        l1,
        l2
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"num_features", AttributeType::Int},
        AttributeDesc{"l1", AttributeType::Float},
        AttributeDesc{"l2", AttributeType::Float}
    };
};

struct SdcaFprint
{
    static constexpr const char* name = "SdcaFprint";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _Send
{
    static constexpr const char* name = "_Send";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct _HostSend
{
    static constexpr const char* name = "_HostSend";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct _HostRecv
{
    static constexpr const char* name = "_HostRecv";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        tensor_type,
        tensor_name,
        send_device,
        send_device_incarnation,
        recv_device,
        client_terminated
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"tensor_type", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String},
        AttributeDesc{"send_device", AttributeType::String},
        AttributeDesc{"send_device_incarnation", AttributeType::Int},
        AttributeDesc{"recv_device", AttributeType::String},
        AttributeDesc{"client_terminated", AttributeType::Bool}
    };
};

struct DenseToSparseSetOperation
{
    static constexpr const char* name = "DenseToSparseSetOperation";
    
    enum class Argument
    {
        set1,
        set2_indices,
        set2_values,
        set2_shape,
        result_indices,
        result_values,
        result_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"set1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"set2_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"result_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        set_operation,
        validate_indices,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"set_operation", AttributeType::String},
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct BatchIFFT
{
    static constexpr const char* name = "BatchIFFT";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct CSRSparseMatrixToSparseTensor
{
    static constexpr const char* name = "CSRSparseMatrixToSparseTensor";
    
    enum class Argument
    {
        sparse_matrix,
        indices,
        values,
        dense_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct DenseToCSRSparseMatrix
{
    static constexpr const char* name = "DenseToCSRSparseMatrix";
    
    enum class Argument
    {
        dense_input,
        indices,
        sparse_output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dense_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct CSRSparseMatrixToDense
{
    static constexpr const char* name = "CSRSparseMatrixToDense";
    
    enum class Argument
    {
        sparse_input,
        dense_output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct CSRSparseMatrixComponents
{
    static constexpr const char* name = "CSRSparseMatrixComponents";
    
    enum class Argument
    {
        csr_sparse_matrix,
        index,
        row_ptrs,
        col_inds,
        values
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"csr_sparse_matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_ptrs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"col_inds", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct SparseMatrixNNZ
{
    static constexpr const char* name = "SparseMatrixNNZ";
    
    enum class Argument
    {
        sparse_matrix,
        nnz
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_matrix", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"nnz", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseMatrixMatMul
{
    static constexpr const char* name = "SparseMatrixMatMul";
    
    enum class Argument
    {
        a,
        b,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        transpose_a,
        transpose_b,
        adjoint_a,
        adjoint_b,
        transpose_output,
        conjugate_output
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"adjoint_a", AttributeType::Bool},
        AttributeDesc{"adjoint_b", AttributeType::Bool},
        AttributeDesc{"transpose_output", AttributeType::Bool},
        AttributeDesc{"conjugate_output", AttributeType::Bool}
    };
};

struct SparseMatrixMul
{
    static constexpr const char* name = "SparseMatrixMul";
    
    enum class Argument
    {
        a,
        b,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseMatrixAdd
{
    static constexpr const char* name = "SparseMatrixAdd";
    
    enum class Argument
    {
        a,
        b,
        alpha,
        beta,
        c
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"c", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct StatelessRandomNormalV2
{
    static constexpr const char* name = "StatelessRandomNormalV2";
    
    enum class Argument
    {
        shape,
        key,
        counter,
        alg,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct SparseMatrixZeros
{
    static constexpr const char* name = "SparseMatrixZeros";
    
    enum class Argument
    {
        dense_shape,
        sparse_matrix
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_matrix", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct SparseMatrixSoftmax
{
    static constexpr const char* name = "SparseMatrixSoftmax";
    
    enum class Argument
    {
        logits,
        softmax
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"logits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"softmax", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        type
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"type", AttributeType::Type}
    };
};

struct SparseMatrixOrderingAMD
{
    static constexpr const char* name = "SparseMatrixOrderingAMD";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseAddGrad
{
    static constexpr const char* name = "SparseAddGrad";
    
    enum class Argument
    {
        backprop_val_grad,
        a_indices,
        b_indices,
        sum_indices,
        a_val_grad,
        b_val_grad
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"backprop_val_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sum_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_val_grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_val_grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaDequantize
{
    static constexpr const char* name = "XlaDequantize";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        min_range,
        max_range,
        mode,
        transpose_output
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"min_range", AttributeType::Float},
        AttributeDesc{"max_range", AttributeType::Float},
        AttributeDesc{"mode", AttributeType::String},
        AttributeDesc{"transpose_output", AttributeType::Bool}
    };
};

struct SparseAdd
{
    static constexpr const char* name = "SparseAdd";
    
    enum class Argument
    {
        a_indices,
        a_values,
        a_shape,
        b_indices,
        b_values,
        b_shape,
        thresh,
        sum_indices,
        sum_values,
        sum_shape
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"thresh", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sum_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sum_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sum_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Treal
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Treal", AttributeType::Type}
    };
};

struct SparseTensorDenseMatMul
{
    static constexpr const char* name = "SparseTensorDenseMatMul";
    
    enum class Argument
    {
        a_indices,
        a_values,
        a_shape,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        adjoint_a,
        adjoint_b
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"adjoint_a", AttributeType::Bool},
        AttributeDesc{"adjoint_b", AttributeType::Bool}
    };
};

struct SerializeManySparse
{
    static constexpr const char* name = "SerializeManySparse";
    
    enum class Argument
    {
        sparse_indices,
        sparse_values,
        sparse_shape,
        serialized_sparse
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"serialized_sparse", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        out_type
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

struct DeserializeManySparse
{
    static constexpr const char* name = "DeserializeManySparse";
    
    enum class Argument
    {
        serialized_sparse,
        sparse_indices,
        sparse_values,
        sparse_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"serialized_sparse", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct SparseToDense
{
    static constexpr const char* name = "SparseToDense";
    
    enum class Argument
    {
        sparse_indices,
        output_shape,
        sparse_values,
        default_value,
        dense
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"default_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        validate_indices,
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"validate_indices", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct SparseConcat
{
    static constexpr const char* name = "SparseConcat";
    
    enum class Argument
    {
        indices,
        values,
        shapes,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        concat_dim,
        N,
        T
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"concat_dim", AttributeType::Int},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseCrossHashed
{
    static constexpr const char* name = "SparseCrossHashed";
    
    enum class Argument
    {
        indices,
        values,
        shapes,
        dense_inputs,
        num_buckets,
        strong_hash,
        salt,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::SequenceAttrList, "sparse_types"},
        ArgumentDesc{"shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"dense_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dense_types"},
        ArgumentDesc{"num_buckets", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"strong_hash", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"salt", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        sparse_types,
        dense_types
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"sparse_types", AttributeType::ListType},
        AttributeDesc{"dense_types", AttributeType::ListType}
    };
};

struct OutfeedEnqueueTuple
{
    static constexpr const char* name = "OutfeedEnqueueTuple";
    
    enum class Argument
    {
        inputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType}
    };
};

struct SparseSplit
{
    static constexpr const char* name = "SparseSplit";
    
    enum class Argument
    {
        split_dim,
        indices,
        values,
        shape,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"split_dim", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "num_split"},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::SequenceAttrInt, "num_split"},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::SequenceAttrInt, "num_split"}
    };

    enum class Attribute
    {
        num_split,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_split", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseSlice
{
    static constexpr const char* name = "SparseSlice";
    
    enum class Argument
    {
        indices,
        values,
        shape,
        start,
        size,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"start", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseReorder
{
    static constexpr const char* name = "SparseReorder";
    
    enum class Argument
    {
        input_indices,
        input_values,
        input_shape,
        output_indices,
        output_values
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseTensorDenseAdd
{
    static constexpr const char* name = "SparseTensorDenseAdd";
    
    enum class Argument
    {
        a_indices,
        a_values,
        a_shape,
        b,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct SparseReduceMaxSparse
{
    static constexpr const char* name = "SparseReduceMaxSparse";
    
    enum class Argument
    {
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        output_indices,
        output_values,
        output_shape
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_axes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseReduceSum
{
    static constexpr const char* name = "SparseReduceSum";
    
    enum class Argument
    {
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_axes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseDenseCwiseDiv
{
    static constexpr const char* name = "SparseDenseCwiseDiv";
    
    enum class Argument
    {
        sp_indices,
        sp_values,
        sp_shape,
        dense,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sp_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sp_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaReplicaId
{
    static constexpr const char* name = "XlaReplicaId";
    
    enum class Argument
    {
        id
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"id", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct SparseSparseMaximum
{
    static constexpr const char* name = "SparseSparseMaximum";
    
    enum class Argument
    {
        a_indices,
        a_values,
        a_shape,
        b_indices,
        b_values,
        b_shape,
        output_indices,
        output_values
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SparseSparseMinimum
{
    static constexpr const char* name = "SparseSparseMinimum";
    
    enum class Argument
    {
        a_indices,
        a_values,
        a_shape,
        b_indices,
        b_values,
        b_shape,
        output_indices,
        output_values
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"a_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct AddManySparseToTensorsMap
{
    static constexpr const char* name = "AddManySparseToTensorsMap";
    
    enum class Argument
    {
        sparse_indices,
        sparse_values,
        sparse_shape,
        sparse_handles
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_handles", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct TakeManySparseFromTensorsMap
{
    static constexpr const char* name = "TakeManySparseFromTensorsMap";
    
    enum class Argument
    {
        sparse_handles,
        sparse_indices,
        sparse_values,
        sparse_shape
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sparse_handles", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sparse_shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct SparseFillEmptyRows
{
    static constexpr const char* name = "SparseFillEmptyRows";
    
    enum class Argument
    {
        indices,
        values,
        dense_shape,
        default_value,
        output_indices,
        output_values,
        empty_row_indicator,
        reverse_index_map
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dense_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"default_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"empty_row_indicator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reverse_index_map", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct SummaryWriter
{
    static constexpr const char* name = "SummaryWriter";
    
    enum class Argument
    {
        writer
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shared_name,
        container
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"shared_name", AttributeType::String},
        AttributeDesc{"container", AttributeType::String}
    };
};

struct FlushSummaryWriter
{
    static constexpr const char* name = "FlushSummaryWriter";
    
    enum class Argument
    {
        writer
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StatelessTruncatedNormalV2
{
    static constexpr const char* name = "StatelessTruncatedNormalV2";
    
    enum class Argument
    {
        shape,
        key,
        counter,
        alg,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct WriteSummary
{
    static constexpr const char* name = "WriteSummary";
    
    enum class Argument
    {
        writer,
        step,
        tensor,
        tag,
        summary_metadata
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summary_metadata", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct ImportEvent
{
    static constexpr const char* name = "ImportEvent";
    
    enum class Argument
    {
        writer,
        event
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"event", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct WriteHistogramSummary
{
    static constexpr const char* name = "WriteHistogramSummary";
    
    enum class Argument
    {
        writer,
        step,
        tag,
        values
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct WriteImageSummary
{
    static constexpr const char* name = "WriteImageSummary";
    
    enum class Argument
    {
        writer,
        step,
        tag,
        tensor,
        bad_color
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tag", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bad_color", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_images,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"max_images", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct WriteGraphSummary
{
    static constexpr const char* name = "WriteGraphSummary";
    
    enum class Argument
    {
        writer,
        step,
        tensor
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"writer", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct FFT
{
    static constexpr const char* name = "FFT";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct IFFT
{
    static constexpr const char* name = "IFFT";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct FFT2D
{
    static constexpr const char* name = "FFT2D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct IFFT2D
{
    static constexpr const char* name = "IFFT2D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct RetrieveTPUEmbeddingProximalYogiParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingProximalYogiParameters";
    
    enum class Argument
    {
        parameters,
        v,
        m
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RFFT
{
    static constexpr const char* name = "RFFT";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct IRFFT
{
    static constexpr const char* name = "IRFFT";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct ScatterNdMin
{
    static constexpr const char* name = "ScatterNdMin";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct RFFT2D
{
    static constexpr const char* name = "RFFT2D";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct IRFFT2D
{
    static constexpr const char* name = "IRFFT2D";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct IRFFT3D
{
    static constexpr const char* name = "IRFFT3D";
    
    enum class Argument
    {
        input,
        fft_length,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"fft_length", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Treal,
        Tcomplex
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Treal", AttributeType::Type},
        AttributeDesc{"Tcomplex", AttributeType::Type}
    };
};

struct BatchFFT
{
    static constexpr const char* name = "BatchFFT";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BatchFFT2D
{
    static constexpr const char* name = "BatchFFT2D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct BatchIFFT2D
{
    static constexpr const char* name = "BatchIFFT2D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ScatterMax
{
    static constexpr const char* name = "ScatterMax";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct BatchIFFT3D
{
    static constexpr const char* name = "BatchIFFT3D";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct VariableV2
{
    static constexpr const char* name = "VariableV2";
    
    enum class Argument
    {
        ref
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        shape,
        dtype,
        container,
        shared_name
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"container", AttributeType::String},
        AttributeDesc{"shared_name", AttributeType::String}
    };
};

struct IsVariableInitialized
{
    static constexpr const char* name = "IsVariableInitialized";
    
    enum class Argument
    {
        ref,
        is_initialized
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"is_initialized", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct _MklNativeFusedBatchNormGradV2
{
    static constexpr const char* name = "_MklNativeFusedBatchNormGradV2";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct AssignSub
{
    static constexpr const char* name = "AssignSub";
    
    enum class Argument
    {
        ref,
        value,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct InfeedEnqueue
{
    static constexpr const char* name = "InfeedEnqueue";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        layout,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"layout", AttributeType::ListInt},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct ScatterAdd
{
    static constexpr const char* name = "ScatterAdd";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct _MklNativeFusedBatchNormV3
{
    static constexpr const char* name = "_MklNativeFusedBatchNormV3";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 6;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct ScatterSub
{
    static constexpr const char* name = "ScatterSub";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceScatterNdUpdate
{
    static constexpr const char* name = "ResourceScatterNdUpdate";
    
    enum class Argument
    {
        ref,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceScatterNdSub
{
    static constexpr const char* name = "ResourceScatterNdSub";
    
    enum class Argument
    {
        ref,
        indices,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ScatterNdAdd
{
    static constexpr const char* name = "ScatterNdAdd";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ScatterNdMax
{
    static constexpr const char* name = "ScatterNdMax";
    
    enum class Argument
    {
        ref,
        indices,
        updates,
        output_ref
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"ref", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output_ref", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct StatelessRandomNormal
{
    static constexpr const char* name = "StatelessRandomNormal";
    
    enum class Argument
    {
        shape,
        seed,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct StatelessTruncatedNormal
{
    static constexpr const char* name = "StatelessTruncatedNormal";
    
    enum class Argument
    {
        shape,
        seed,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct StatelessRandomUniformFullInt
{
    static constexpr const char* name = "StatelessRandomUniformFullInt";
    
    enum class Argument
    {
        shape,
        seed,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        T,
        Tseed
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct StatelessRandomBinomial
{
    static constexpr const char* name = "StatelessRandomBinomial";
    
    enum class Argument
    {
        shape,
        seed,
        counts,
        probs,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counts", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"probs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        S,
        Tseed,
        T,
        dtype
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct StatelessParameterizedTruncatedNormal
{
    static constexpr const char* name = "StatelessParameterizedTruncatedNormal";
    
    enum class Argument
    {
        shape,
        seed,
        means,
        stddevs,
        minvals,
        maxvals,
        output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"means", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"stddevs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"minvals", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"maxvals", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        S,
        Tseed,
        dtype
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"S", AttributeType::Type},
        AttributeDesc{"Tseed", AttributeType::Type},
        AttributeDesc{"dtype", AttributeType::Type}
    };
};

struct StatelessRandomUniformV2
{
    static constexpr const char* name = "StatelessRandomUniformV2";
    
    enum class Argument
    {
        shape,
        key,
        counter,
        alg,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        Tshape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"Tshape", AttributeType::Type}
    };
};

struct StatelessRandomGetKeyCounterAlg
{
    static constexpr const char* name = "StatelessRandomGetKeyCounterAlg";
    
    enum class Argument
    {
        seed,
        key,
        counter,
        alg
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"seed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"counter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tseed
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"Tseed", AttributeType::Type}
    };
};

struct StatelessRandomGetAlg
{
    static constexpr const char* name = "StatelessRandomGetAlg";
    
    enum class Argument
    {
        alg
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"alg", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct RegexReplace
{
    static constexpr const char* name = "RegexReplace";
    
    enum class Argument
    {
        input,
        pattern,
        rewrite,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pattern", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rewrite", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        replace_global
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"replace_global", AttributeType::Bool}
    };
};

struct StaticRegexReplace
{
    static constexpr const char* name = "StaticRegexReplace";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pattern,
        rewrite,
        replace_global
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"pattern", AttributeType::String},
        AttributeDesc{"rewrite", AttributeType::String},
        AttributeDesc{"replace_global", AttributeType::Bool}
    };
};

struct RecvTPUEmbeddingActivations
{
    static constexpr const char* name = "RecvTPUEmbeddingActivations";
    
    enum class Argument
    {
        outputs
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_outputs"}
    };

    enum class Attribute
    {
        num_outputs,
        config
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_outputs", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RegexFullMatch
{
    static constexpr const char* name = "RegexFullMatch";
    
    enum class Argument
    {
        input,
        pattern,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pattern", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct StaticRegexFullMatch
{
    static constexpr const char* name = "StaticRegexFullMatch";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pattern
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"pattern", AttributeType::String}
    };
};

struct StringToHashBucketFast
{
    static constexpr const char* name = "StringToHashBucketFast";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_buckets
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"num_buckets", AttributeType::Int}
    };
};

struct LoadTPUEmbeddingStochasticGradientDescentParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingStochasticGradientDescentParameters";
    
    enum class Argument
    {
        parameters
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct ResourceApplyRMSProp
{
    static constexpr const char* name = "ResourceApplyRMSProp";
    
    enum class Argument
    {
        var,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct _TensorToHashBucketFast
{
    static constexpr const char* name = "_TensorToHashBucketFast";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_buckets
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_buckets", AttributeType::Int}
    };
};

struct StringToHashBucketStrong
{
    static constexpr const char* name = "StringToHashBucketStrong";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        num_buckets,
        key
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_buckets", AttributeType::Int},
        AttributeDesc{"key", AttributeType::ListInt}
    };
};

struct ReduceJoin
{
    static constexpr const char* name = "ReduceJoin";
    
    enum class Argument
    {
        inputs,
        reduction_indices,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reduction_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        keep_dims,
        separator
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"keep_dims", AttributeType::Bool},
        AttributeDesc{"separator", AttributeType::String}
    };
};

struct UnsortedSegmentJoin
{
    static constexpr const char* name = "UnsortedSegmentJoin";
    
    enum class Argument
    {
        inputs,
        segment_ids,
        num_segments,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"segment_ids", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"num_segments", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        separator,
        Tindices,
        Tnumsegments
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"separator", AttributeType::String},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"Tnumsegments", AttributeType::Type}
    };
};

struct AsString
{
    static constexpr const char* name = "AsString";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        precision,
        scientific,
        shortest,
        width,
        fill
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"precision", AttributeType::Int},
        AttributeDesc{"scientific", AttributeType::Bool},
        AttributeDesc{"shortest", AttributeType::Bool},
        AttributeDesc{"width", AttributeType::Int},
        AttributeDesc{"fill", AttributeType::String}
    };
};

struct StringJoin
{
    static constexpr const char* name = "StringJoin";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        separator
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"separator", AttributeType::String}
    };
};

struct StringSplitV2
{
    static constexpr const char* name = "StringSplitV2";
    
    enum class Argument
    {
        input,
        sep,
        indices,
        values,
        shape
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sep", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"shape", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        maxsplit
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"maxsplit", AttributeType::Int}
    };
};

struct StringLower
{
    static constexpr const char* name = "StringLower";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        encoding
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"encoding", AttributeType::String}
    };
};

struct StringLength
{
    static constexpr const char* name = "StringLength";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        unit
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"unit", AttributeType::String}
    };
};

struct EncodeBase64
{
    static constexpr const char* name = "EncodeBase64";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        pad
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"pad", AttributeType::Bool}
    };
};

struct _TPUCompileMlir
{
    static constexpr const char* name = "_TPUCompileMlir";
    
    enum class Argument
    {
        dynamic_shapes,
        compilation_status,
        program
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dynamic_shapes", ArgumentDesc::TensorCount::SequenceAttrInt, "NumDynamicShapes"},
        ArgumentDesc{"compilation_status", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"program", ArgumentDesc::TensorCount::SequenceAttrInt, "num_computations"}
    };

    enum class Attribute
    {
        num_computations,
        mlir_module,
        metadata,
        NumDynamicShapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"num_computations", AttributeType::Int},
        AttributeDesc{"mlir_module", AttributeType::String},
        AttributeDesc{"metadata", AttributeType::String},
        AttributeDesc{"NumDynamicShapes", AttributeType::Int}
    };
};

struct DecodeBase64
{
    static constexpr const char* name = "DecodeBase64";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct _MklNativeFusedConv2D
{
    static constexpr const char* name = "_MklNativeFusedConv2D";
    
    enum class Argument
    {
        input,
        filter,
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations,
        use_cudnn_on_gpu,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 12> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct Substr
{
    static constexpr const char* name = "Substr";
    
    enum class Argument
    {
        input,
        pos,
        len,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"pos", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"len", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        unit
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"unit", AttributeType::String}
    };
};

struct UnicodeEncode
{
    static constexpr const char* name = "UnicodeEncode";
    
    enum class Argument
    {
        input_values,
        input_splits,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_values", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        errors,
        output_encoding,
        replacement_char,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"errors", AttributeType::String},
        AttributeDesc{"output_encoding", AttributeType::String},
        AttributeDesc{"replacement_char", AttributeType::Int},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct UnicodeTranscode
{
    static constexpr const char* name = "UnicodeTranscode";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        input_encoding,
        output_encoding,
        errors,
        replacement_char,
        replace_control_characters
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"input_encoding", AttributeType::String},
        AttributeDesc{"output_encoding", AttributeType::String},
        AttributeDesc{"errors", AttributeType::String},
        AttributeDesc{"replacement_char", AttributeType::Int},
        AttributeDesc{"replace_control_characters", AttributeType::Bool}
    };
};

struct UnicodeDecode
{
    static constexpr const char* name = "UnicodeDecode";
    
    enum class Argument
    {
        input,
        row_splits,
        char_values
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"row_splits", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"char_values", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        input_encoding,
        errors,
        replacement_char,
        replace_control_characters,
        Tsplits
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"input_encoding", AttributeType::String},
        AttributeDesc{"errors", AttributeType::String},
        AttributeDesc{"replacement_char", AttributeType::Int},
        AttributeDesc{"replace_control_characters", AttributeType::Bool},
        AttributeDesc{"Tsplits", AttributeType::Type}
    };
};

struct SparseApplyProximalGradientDescent
{
    static constexpr const char* name = "SparseApplyProximalGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        l1,
        l2,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceSparseApplyProximalGradientDescent
{
    static constexpr const char* name = "ResourceSparseApplyProximalGradientDescent";
    
    enum class Argument
    {
        var,
        alpha,
        l1,
        l2,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"alpha", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ApplyAdadelta
{
    static constexpr const char* name = "ApplyAdadelta";
    
    enum class Argument
    {
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum_update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceSparseApplyAdadelta
{
    static constexpr const char* name = "ResourceSparseApplyAdadelta";
    
    enum class Argument
    {
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum_update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ApplyAdagrad
{
    static constexpr const char* name = "ApplyAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct ResourceApplyAdagrad
{
    static constexpr const char* name = "ResourceApplyAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct _InitializeHostForDistributedTPU
{
    static constexpr const char* name = "_InitializeHostForDistributedTPU";
    
    enum class Argument
    {
        input,
        tpu_ids
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"tpu_ids", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        enable_whole_mesh_compilations
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"enable_whole_mesh_compilations", AttributeType::Bool}
    };
};

struct ApplyMomentum
{
    static constexpr const char* name = "ApplyMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        momentum,
        out
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct ApplyAdagradV2
{
    static constexpr const char* name = "ApplyAdagradV2";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        epsilon,
        grad,
        out
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct ResourceSparseApplyAdagradV2
{
    static constexpr const char* name = "ResourceSparseApplyAdagradV2";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        epsilon,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        update_slots
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"update_slots", AttributeType::Bool}
    };
};

struct ResourceApplyProximalAdagrad
{
    static constexpr const char* name = "ResourceApplyProximalAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        l1,
        l2,
        grad
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceSparseApplyProximalAdagrad
{
    static constexpr const char* name = "ResourceSparseApplyProximalAdagrad";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        l1,
        l2,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct TopKWithUnique
{
    static constexpr const char* name = "TopKWithUnique";
    
    enum class Argument
    {
        input,
        topk,
        topk_indices
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"topk", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"topk_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        k
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"k", AttributeType::Int}
    };
};

struct SparseApplyCenteredRMSProp
{
    static constexpr const char* name = "SparseApplyCenteredRMSProp";
    
    enum class Argument
    {
        var,
        mg,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        indices,
        out
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct SparseApplyAdagradDA
{
    static constexpr const char* name = "SparseApplyAdagradDA";
    
    enum class Argument
    {
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"gradient_squared_accumulator", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"global_step", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct SparseApplyFtrl
{
    static constexpr const char* name = "SparseApplyFtrl";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        lr_power,
        out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct ResourceApplyFtrl
{
    static constexpr const char* name = "ResourceApplyFtrl";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        lr_power
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct ResourceSparseApplyFtrl
{
    static constexpr const char* name = "ResourceSparseApplyFtrl";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        lr_power
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct ResourceApplyFtrlV2
{
    static constexpr const char* name = "ResourceApplyFtrlV2";
    
    enum class Argument
    {
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"linear", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"l2_shrinkage", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr_power", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        multiply_linear_by_lr
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"multiply_linear_by_lr", AttributeType::Bool}
    };
};

struct SparseApplyMomentum
{
    static constexpr const char* name = "SparseApplyMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        indices,
        momentum,
        out
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct ResourceApplyMomentum
{
    static constexpr const char* name = "ResourceApplyMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        momentum
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct ResourceSparseApplyMomentum
{
    static constexpr const char* name = "ResourceSparseApplyMomentum";
    
    enum class Argument
    {
        var,
        accum,
        lr,
        grad,
        indices,
        momentum
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking,
        use_nesterov
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool},
        AttributeDesc{"use_nesterov", AttributeType::Bool}
    };
};

struct ResourceApplyCenteredRMSProp
{
    static constexpr const char* name = "ResourceApplyCenteredRMSProp";
    
    enum class Argument
    {
        var,
        mg,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceSparseApplyCenteredRMSProp
{
    static constexpr const char* name = "ResourceSparseApplyCenteredRMSProp";
    
    enum class Argument
    {
        var,
        mg,
        ms,
        mom,
        lr,
        rho,
        momentum,
        epsilon,
        grad,
        indices
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rho", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momentum", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"epsilon", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct ResourceApplyPowerSign
{
    static constexpr const char* name = "ResourceApplyPowerSign";
    
    enum class Argument
    {
        var,
        m,
        lr,
        logbase,
        sign_decay,
        beta,
        grad
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"var", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"m", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lr", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"logbase", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"sign_decay", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"beta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        use_locking
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"use_locking", AttributeType::Bool}
    };
};

struct Skipgram
{
    static constexpr const char* name = "Skipgram";
    
    enum class Argument
    {
        vocab_word,
        vocab_freq,
        words_per_epoch,
        current_epoch,
        total_words_processed,
        examples,
        labels
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 7;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"vocab_word", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"vocab_freq", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"words_per_epoch", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"current_epoch", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"total_words_processed", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"examples", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"labels", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        filename,
        batch_size,
        window_size,
        min_count,
        subsample
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"filename", AttributeType::String},
        AttributeDesc{"batch_size", AttributeType::Int},
        AttributeDesc{"window_size", AttributeType::Int},
        AttributeDesc{"min_count", AttributeType::Int},
        AttributeDesc{"subsample", AttributeType::Float}
    };
};

struct _WaitForDistributedTPU
{
    static constexpr const char* name = "_WaitForDistributedTPU";
    
    enum class Argument
    {
        inputs,
        topology
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"topology", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        startup_timeout_sec,
        N
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"startup_timeout_sec", AttributeType::Int},
        AttributeDesc{"N", AttributeType::Int}
    };
};

struct _SetGlobalTPUArray
{
    static constexpr const char* name = "_SetGlobalTPUArray";
    
    enum class Argument
    {
        topology
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"topology", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct ShutdownDistributedTPU
{
    static constexpr const char* name = "ShutdownDistributedTPU";
    
    enum class Argument
    {

    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {

    };

    enum class Attribute
    {

    };

    static constexpr std::array<AttributeDesc, 0> attribute_descs
    {

    };
};

struct AllToAll
{
    static constexpr const char* name = "AllToAll";
    
    enum class Argument
    {
        input,
        group_assignment,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"group_assignment", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        concat_dimension,
        split_dimension,
        split_count
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"concat_dimension", AttributeType::Int},
        AttributeDesc{"split_dimension", AttributeType::Int},
        AttributeDesc{"split_count", AttributeType::Int}
    };
};

struct CollectivePermute
{
    static constexpr const char* name = "CollectivePermute";
    
    enum class Argument
    {
        input,
        source_target_pairs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"source_target_pairs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct EnqueueTPUEmbeddingIntegerBatch
{
    static constexpr const char* name = "EnqueueTPUEmbeddingIntegerBatch";
    
    enum class Argument
    {
        batch,
        mode_override
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"batch", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mode_override", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct EnqueueTPUEmbeddingSparseBatch
{
    static constexpr const char* name = "EnqueueTPUEmbeddingSparseBatch";
    
    enum class Argument
    {
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sample_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"embedding_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"aggregation_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mode_override", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        T3,
        N,
        device_ordinal,
        combiners
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"T3", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"device_ordinal", AttributeType::Int},
        AttributeDesc{"combiners", AttributeType::ListString}
    };
};

struct EnqueueTPUEmbeddingRaggedTensorBatch
{
    static constexpr const char* name = "EnqueueTPUEmbeddingRaggedTensorBatch";
    
    enum class Argument
    {
        sample_splits,
        embedding_indices,
        aggregation_weights,
        mode_override
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"sample_splits", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"embedding_indices", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"aggregation_weights", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"mode_override", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        T3,
        N,
        device_ordinal,
        combiners,
        table_ids,
        max_sequence_lengths,
        num_features
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"T3", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"device_ordinal", AttributeType::Int},
        AttributeDesc{"combiners", AttributeType::ListString},
        AttributeDesc{"table_ids", AttributeType::ListInt},
        AttributeDesc{"max_sequence_lengths", AttributeType::ListInt},
        AttributeDesc{"num_features", AttributeType::ListInt}
    };
};

struct XlaEinsum
{
    static constexpr const char* name = "XlaEinsum";
    
    enum class Argument
    {
        a,
        b,
        product
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        equation,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"equation", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct RetrieveTPUEmbeddingAdagradParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingAdagradParameters";
    
    enum class Argument
    {
        parameters,
        accumulators
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingAdagradMomentumParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingAdagradMomentumParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        momenta
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingStochasticGradientDescentParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingStochasticGradientDescentParameters";
    
    enum class Argument
    {
        parameters
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct LoadTPUEmbeddingADAMParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingADAMParameters";
    
    enum class Argument
    {
        parameters,
        momenta,
        velocities
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"velocities", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct _MklQuantizedMatMulWithBias
{
    static constexpr const char* name = "_MklQuantizedMatMulWithBias";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode,
        is_weight_const
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String},
        AttributeDesc{"is_weight_const", AttributeType::Bool}
    };
};

struct RetrieveTPUEmbeddingADAMParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingADAMParameters";
    
    enum class Argument
    {
        parameters,
        momenta,
        velocities
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"velocities", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingMomentumParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingMomentumParameters";
    
    enum class Argument
    {
        parameters,
        momenta
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"momenta", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct _MklNativeConv2DWithBias
{
    static constexpr const char* name = "_MklNativeConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        is_filter_const,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct RetrieveTPUEmbeddingRMSPropParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingRMSPropParameters";
    
    enum class Argument
    {
        parameters,
        ms,
        mom
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingCenteredRMSPropParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingCenteredRMSPropParameters";
    
    enum class Argument
    {
        parameters,
        ms,
        mom,
        mg
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"ms", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mom", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mg", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct LoadTPUEmbeddingMDLAdagradLightParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingMDLAdagradLightParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        weights,
        benefits
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"benefits", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingMDLAdagradLightParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingMDLAdagradLightParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        weights,
        benefits
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"weights", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"benefits", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct LoadTPUEmbeddingAdadeltaParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingAdadeltaParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        updates
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingAdadeltaParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingAdadeltaParameters";
    
    enum class Argument
    {
        parameters,
        accumulators,
        updates
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct RetrieveTPUEmbeddingProximalAdagradParameters
{
    static constexpr const char* name = "RetrieveTPUEmbeddingProximalAdagradParameters";
    
    enum class Argument
    {
        parameters,
        accumulators
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"accumulators", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct LoadTPUEmbeddingFrequencyEstimatorParameters
{
    static constexpr const char* name = "LoadTPUEmbeddingFrequencyEstimatorParameters";
    
    enum class Argument
    {
        parameters,
        last_hit_step
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"parameters", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"last_hit_step", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        table_id,
        table_name,
        num_shards,
        shard_id,
        config
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"table_id", AttributeType::Int},
        AttributeDesc{"table_name", AttributeType::String},
        AttributeDesc{"num_shards", AttributeType::Int},
        AttributeDesc{"shard_id", AttributeType::Int},
        AttributeDesc{"config", AttributeType::String}
    };
};

struct _XlaRecvAtHost
{
    static constexpr const char* name = "_XlaRecvAtHost";
    
    enum class Argument
    {
        dynamic_key,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dynamic_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "Toutputs"}
    };

    enum class Attribute
    {
        Toutputs,
        key,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Toutputs", AttributeType::ListType},
        AttributeDesc{"key", AttributeType::String},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct _XlaRecvAtHostV2
{
    static constexpr const char* name = "_XlaRecvAtHostV2";
    
    enum class Argument
    {
        dynamic_key,
        device_ordinal,
        outputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"dynamic_key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"device_ordinal", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "Toutputs"}
    };

    enum class Attribute
    {
        Toutputs,
        key
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Toutputs", AttributeType::ListType},
        AttributeDesc{"key", AttributeType::String}
    };
};

struct XlaConcatND
{
    static constexpr const char* name = "XlaConcatND";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        N,
        num_concats,
        paddings
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_concats", AttributeType::ListInt},
        AttributeDesc{"paddings", AttributeType::ListInt}
    };
};

struct ReadVariableXlaSplitND
{
    static constexpr const char* name = "ReadVariableXlaSplitND";
    
    enum class Argument
    {
        resource,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"resource", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"}
    };

    enum class Attribute
    {
        T,
        N,
        num_splits,
        paddings
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"num_splits", AttributeType::ListInt},
        AttributeDesc{"paddings", AttributeType::ListInt}
    };
};

struct InfeedDequeue
{
    static constexpr const char* name = "InfeedDequeue";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct InfeedEnqueueTuple
{
    static constexpr const char* name = "InfeedEnqueueTuple";
    
    enum class Argument
    {
        inputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "dtypes"}
    };

    enum class Attribute
    {
        dtypes,
        shapes,
        layouts,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"dtypes", AttributeType::ListType},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"layouts", AttributeType::ListInt},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct Prelinearize
{
    static constexpr const char* name = "Prelinearize";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        layout
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"layout", AttributeType::ListInt}
    };
};

struct XlaDot
{
    static constexpr const char* name = "XlaDot";
    
    enum class Argument
    {
        lhs,
        rhs,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"lhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        dimension_numbers,
        precision_config
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"precision_config", AttributeType::String}
    };
};

struct OutfeedDequeue
{
    static constexpr const char* name = "OutfeedDequeue";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape,
        device_ordinal
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape},
        AttributeDesc{"device_ordinal", AttributeType::Int}
    };
};

struct TPUReplicatedInput
{
    static constexpr const char* name = "TPUReplicatedInput";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        is_mirrored_variable,
        index,
        is_packed
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"is_mirrored_variable", AttributeType::Bool},
        AttributeDesc{"index", AttributeType::Int},
        AttributeDesc{"is_packed", AttributeType::Bool}
    };
};

struct TPUReplicatedOutput
{
    static constexpr const char* name = "TPUReplicatedOutput";
    
    enum class Argument
    {
        input,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrInt, "num_replicas"}
    };

    enum class Attribute
    {
        num_replicas,
        T
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"num_replicas", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _TPUReplicate
{
    static constexpr const char* name = "_TPUReplicate";
    
    enum class Argument
    {
        inputs,
        broadcast_inputs,
        variables,
        guaranteed_constants,
        outputs
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"broadcast_inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tbroadcast_inputs"},
        ArgumentDesc{"variables", ArgumentDesc::TensorCount::SequenceAttrInt, "NumVariables"},
        ArgumentDesc{"guaranteed_constants", ArgumentDesc::TensorCount::SequenceAttrList, "Tguaranteed_constants"},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "output_types"}
    };

    enum class Attribute
    {
        computation,
        num_replicas,
        num_cores_per_replica,
        topology,
        use_tpu,
        device_assignment,
        host_compute_core,
        Tinputs,
        Tbroadcast_inputs,
        NumVariables,
        Tguaranteed_constants,
        output_types,
        padding_map,
        step_marker_location,
        allow_soft_placement,
        num_distributed_variables,
        use_spmd_for_xla_partitioning
    };

    static constexpr std::array<AttributeDesc, 17> attribute_descs
    {
        AttributeDesc{"computation", AttributeType::Func},
        AttributeDesc{"num_replicas", AttributeType::Int},
        AttributeDesc{"num_cores_per_replica", AttributeType::Int},
        AttributeDesc{"topology", AttributeType::String},
        AttributeDesc{"use_tpu", AttributeType::Bool},
        AttributeDesc{"device_assignment", AttributeType::ListInt},
        AttributeDesc{"host_compute_core", AttributeType::ListString},
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"Tbroadcast_inputs", AttributeType::ListType},
        AttributeDesc{"NumVariables", AttributeType::Int},
        AttributeDesc{"Tguaranteed_constants", AttributeType::ListType},
        AttributeDesc{"output_types", AttributeType::ListType},
        AttributeDesc{"padding_map", AttributeType::ListString},
        AttributeDesc{"step_marker_location", AttributeType::String},
        AttributeDesc{"allow_soft_placement", AttributeType::Bool},
        AttributeDesc{"num_distributed_variables", AttributeType::Int},
        AttributeDesc{"use_spmd_for_xla_partitioning", AttributeType::Bool}
    };
};

struct _MklNativeConv3DBackpropFilterV2
{
    static constexpr const char* name = "_MklNativeConv3DBackpropFilterV2";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        dilations
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklFusedDepthwiseConv2dNative
{
    static constexpr const char* name = "_MklFusedDepthwiseConv2dNative";
    
    enum class Argument
    {
        input,
        filter,
        args,
        mkl_input,
        mkl_filter,
        mkl_args,
        output,
        filter_output,
        mkl_output,
        mkl_filter_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 4;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        num_args,
        strides,
        is_filter_const,
        padding,
        data_format,
        dilations,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct _MklNativeFusedMatMul
{
    static constexpr const char* name = "_MklNativeFusedMatMul";
    
    enum class Argument
    {
        a,
        b,
        args,
        product
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrInt, "num_args"},
        ArgumentDesc{"product", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        is_filter_const,
        transpose_a,
        transpose_b,
        T,
        num_args,
        fused_ops,
        epsilon,
        leakyrelu_alpha
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"num_args", AttributeType::Int},
        AttributeDesc{"fused_ops", AttributeType::ListString},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"leakyrelu_alpha", AttributeType::Float}
    };
};

struct _MklNativePadWithConv2D
{
    static constexpr const char* name = "_MklNativePadWithConv2D";
    
    enum class Argument
    {
        input,
        filter,
        paddings,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"paddings", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        use_cudnn_on_gpu,
        padding,
        data_format,
        is_filter_const,
        dilations,
        Tpaddings
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"use_cudnn_on_gpu", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"Tpaddings", AttributeType::Type}
    };
};

struct _MklNativeAvgPoolGrad
{
    static constexpr const char* name = "_MklNativeAvgPoolGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeAvgPool3D
{
    static constexpr const char* name = "_MklNativeAvgPool3D";
    
    enum class Argument
    {
        value,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeAvgPool3DGrad
{
    static constexpr const char* name = "_MklNativeAvgPool3DGrad";
    
    enum class Argument
    {
        orig_input_shape,
        grad,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input_shape", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct _MklNativeMaxPool
{
    static constexpr const char* name = "_MklNativeMaxPool";
    
    enum class Argument
    {
        input,
        output,
        workspace
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding,
        data_format,
        explicit_paddings,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct _MklNativeMaxPool3D
{
    static constexpr const char* name = "_MklNativeMaxPool3D";
    
    enum class Argument
    {
        input,
        output,
        workspace
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct _MklNativeMaxPool3DGrad
{
    static constexpr const char* name = "_MklNativeMaxPool3DGrad";
    
    enum class Argument
    {
        orig_input,
        orig_output,
        grad,
        workspace,
        output
    };

    static constexpr uint32_t input_arg_count = 4;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"orig_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"orig_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"grad", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"workspace", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        ksize,
        strides,
        padding,
        data_format,
        T,
        TInput,
        workspace_enabled
    };

    static constexpr std::array<AttributeDesc, 7> attribute_descs
    {
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"TInput", AttributeType::Type},
        AttributeDesc{"workspace_enabled", AttributeType::Bool}
    };
};

struct _MklQuantizedMaxPool
{
    static constexpr const char* name = "_MklQuantizedMaxPool";
    
    enum class Argument
    {
        input,
        min_input,
        max_input,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        ksize,
        strides,
        padding
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"ksize", AttributeType::ListInt},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String}
    };
};

struct _MklNativeFusedBatchNormGrad
{
    static constexpr const char* name = "_MklNativeFusedBatchNormGrad";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_3,
        reserve_space_4
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklQuantizedConv2DWithBias
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklQuantizedConv2DAndRelu
{
    static constexpr const char* name = "_MklQuantizedConv2DAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklQuantizedConv2DWithBiasSumAndRelu
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasSumAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 8;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklQuantizedConv2DWithBiasSignedSumAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedConv2DWithBiasSignedSumAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_summand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        Tsummand,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 12> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Tsummand", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklDepthwiseConv2dNativeBackpropInput
{
    static constexpr const char* name = "_MklDepthwiseConv2dNativeBackpropInput";
    
    enum class Argument
    {
        input_sizes,
        filter,
        out_backprop,
        mkl_input,
        mkl_filter,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklFusedBatchNormEx
{
    static constexpr const char* name = "_MklFusedBatchNormEx";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        side_input,
        mkl_x,
        mkl_scale,
        mkl_offset,
        mkl_mean,
        mkl_variance,
        mkl_side_input,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        mkl_y,
        mkl_batch_mean,
        mkl_batch_variance,
        mkl_reserve_space_1,
        mkl_reserve_space_2,
        mkl_reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 12;
    static constexpr uint32_t output_arg_count = 12;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"side_input", ArgumentDesc::TensorCount::SequenceAttrInt, "num_side_inputs"},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_side_input", ArgumentDesc::TensorCount::SequenceAttrInt, "num_side_inputs"},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        exponential_avg_factor,
        data_format,
        num_side_inputs,
        activation_mode,
        is_training
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"num_side_inputs", AttributeType::Int},
        AttributeDesc{"activation_mode", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklDepthwiseConv2dNativeBackpropFilter
{
    static constexpr const char* name = "_MklDepthwiseConv2dNativeBackpropFilter";
    
    enum class Argument
    {
        input,
        filter_sizes,
        out_backprop,
        mkl_input,
        mkl_filter,
        mkl_out_backprop,
        output,
        mkl_output
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_out_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        strides,
        padding,
        data_format,
        explicit_paddings,
        dilations
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"explicit_paddings", AttributeType::ListInt},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklQuantizedMatMulWithBiasAndRequantize
{
    static constexpr const char* name = "_MklQuantizedMatMulWithBiasAndRequantize";
    
    enum class Argument
    {
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        out,
        min_out,
        max_out
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_b", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_out", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_out", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T1,
        T2,
        Tbias,
        Toutput,
        transpose_a,
        transpose_b,
        input_quant_mode,
        is_weight_const
    };

    static constexpr std::array<AttributeDesc, 8> attribute_descs
    {
        AttributeDesc{"T1", AttributeType::Type},
        AttributeDesc{"T2", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"Toutput", AttributeType::Type},
        AttributeDesc{"transpose_a", AttributeType::Bool},
        AttributeDesc{"transpose_b", AttributeType::Bool},
        AttributeDesc{"input_quant_mode", AttributeType::String},
        AttributeDesc{"is_weight_const", AttributeType::Bool}
    };
};

struct _MklQuantizedDepthwiseConv2DWithBias
{
    static constexpr const char* name = "_MklQuantizedDepthwiseConv2DWithBias";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations
    };

    static constexpr std::array<AttributeDesc, 9> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt}
    };
};

struct _MklQuantizedDepthwiseConv2DWithBiasAndRelu
{
    static constexpr const char* name = "_MklQuantizedDepthwiseConv2DWithBiasAndRelu";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklQuantizedDepthwiseConv2DWithBiasAndReluAndRequantize
{
    static constexpr const char* name = "_MklQuantizedDepthwiseConv2DWithBiasAndReluAndRequantize";
    
    enum class Argument
    {
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        output,
        min_output,
        max_output
    };

    static constexpr uint32_t input_arg_count = 9;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"bias", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_filter", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_freezed_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"min_output", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"max_output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        Tfilter,
        Tbias,
        out_type,
        data_format,
        strides,
        is_filter_const,
        is_bias_const,
        padding,
        dilations,
        padding_list
    };

    static constexpr std::array<AttributeDesc, 11> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"Tfilter", AttributeType::Type},
        AttributeDesc{"Tbias", AttributeType::Type},
        AttributeDesc{"out_type", AttributeType::Type},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"strides", AttributeType::ListInt},
        AttributeDesc{"is_filter_const", AttributeType::Bool},
        AttributeDesc{"is_bias_const", AttributeType::Bool},
        AttributeDesc{"padding", AttributeType::String},
        AttributeDesc{"dilations", AttributeType::ListInt},
        AttributeDesc{"padding_list", AttributeType::ListInt}
    };
};

struct _MklFusedBatchNormV3
{
    static constexpr const char* name = "_MklFusedBatchNormV3";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        mkl_x,
        mkl_scale,
        mkl_offset,
        mkl_mean,
        mkl_variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        mkl_y,
        mkl_batch_mean,
        mkl_batch_variance,
        mkl_reserve_space_1,
        mkl_reserve_space_2,
        mkl_reserve_space_3
    };

    static constexpr uint32_t input_arg_count = 10;
    static constexpr uint32_t output_arg_count = 12;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mkl_reserve_space_3", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklNativeFusedBatchNorm
{
    static constexpr const char* name = "_MklNativeFusedBatchNorm";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklNativeFusedBatchNormV2
{
    static constexpr const char* name = "_MklNativeFusedBatchNormV2";
    
    enum class Argument
    {
        x,
        scale,
        offset,
        mean,
        variance,
        y,
        batch_mean,
        batch_variance,
        reserve_space_1,
        reserve_space_2
    };

    static constexpr uint32_t input_arg_count = 5;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"y", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_mean", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"batch_variance", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        exponential_avg_factor,
        is_training
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"exponential_avg_factor", AttributeType::Float},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct _MklNativeFusedBatchNormGradV3
{
    static constexpr const char* name = "_MklNativeFusedBatchNormGradV3";
    
    enum class Argument
    {
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        x_backprop,
        scale_backprop,
        offset_backprop,
        reserve_space_4,
        reserve_space_5
    };

    static constexpr uint32_t input_arg_count = 6;
    static constexpr uint32_t output_arg_count = 5;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"y_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_1", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_2", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_3", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"x_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scale_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"offset_backprop", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_4", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"reserve_space_5", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        U,
        epsilon,
        data_format,
        is_training
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"U", AttributeType::Type},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"data_format", AttributeType::String},
        AttributeDesc{"is_training", AttributeType::Bool}
    };
};

struct XlaHostCompute
{
    static constexpr const char* name = "XlaHostCompute";
    
    enum class Argument
    {
        inputs,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "Toutputs"}
    };

    enum class Attribute
    {
        Tinputs,
        Toutputs,
        ancestors,
        shapes,
        shape_inference_graph,
        key,
        send_key,
        recv_key,
        cost_estimate_ns,
        tpu_core
    };

    static constexpr std::array<AttributeDesc, 10> attribute_descs
    {
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"Toutputs", AttributeType::ListType},
        AttributeDesc{"ancestors", AttributeType::ListString},
        AttributeDesc{"shapes", AttributeType::ListShape},
        AttributeDesc{"shape_inference_graph", AttributeType::Func},
        AttributeDesc{"key", AttributeType::String},
        AttributeDesc{"send_key", AttributeType::String},
        AttributeDesc{"recv_key", AttributeType::String},
        AttributeDesc{"cost_estimate_ns", AttributeType::Int},
        AttributeDesc{"tpu_core", AttributeType::Int}
    };
};

struct XlaSendToHost
{
    static constexpr const char* name = "XlaSendToHost";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        Tinput,
        key
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Tinput", AttributeType::Type},
        AttributeDesc{"key", AttributeType::String}
    };
};

struct TopKUnique
{
    static constexpr const char* name = "TopKUnique";
    
    enum class Argument
    {
        input,
        topk,
        topk_indices
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 2;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"topk", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"topk_indices", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        k
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"k", AttributeType::Int}
    };
};

struct TPUExecute
{
    static constexpr const char* name = "TPUExecute";
    
    enum class Argument
    {
        args,
        key,
        results
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Targs"},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"results", ArgumentDesc::TensorCount::SequenceAttrList, "Tresults"}
    };

    enum class Attribute
    {
        Targs,
        Tresults
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"Targs", AttributeType::ListType},
        AttributeDesc{"Tresults", AttributeType::ListType}
    };
};

struct TPUExecuteAndUpdateVariables
{
    static constexpr const char* name = "TPUExecuteAndUpdateVariables";
    
    enum class Argument
    {
        args,
        key,
        results
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Targs"},
        ArgumentDesc{"key", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"results", ArgumentDesc::TensorCount::SequenceAttrList, "Tresults"}
    };

    enum class Attribute
    {
        Targs,
        Tresults,
        device_var_reads_indices,
        device_var_updates_indices
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Targs", AttributeType::ListType},
        AttributeDesc{"Tresults", AttributeType::ListType},
        AttributeDesc{"device_var_reads_indices", AttributeType::ListInt},
        AttributeDesc{"device_var_updates_indices", AttributeType::ListInt}
    };
};

struct TPUPartitionedInput
{
    static constexpr const char* name = "TPUPartitionedInput";
    
    enum class Argument
    {
        inputs,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrInt, "N"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        N,
        T,
        partition_dim
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"N", AttributeType::Int},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"partition_dim", AttributeType::Int}
    };
};

struct MlirPassthroughOp
{
    static constexpr const char* name = "MlirPassthroughOp";
    
    enum class Argument
    {
        inputs,
        outputs
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "Tinputs"},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "Toutputs"}
    };

    enum class Attribute
    {
        mlir_module,
        Tinputs,
        Toutputs
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"mlir_module", AttributeType::String},
        AttributeDesc{"Tinputs", AttributeType::ListType},
        AttributeDesc{"Toutputs", AttributeType::ListType}
    };
};

struct XlaSvd
{
    static constexpr const char* name = "XlaSvd";
    
    enum class Argument
    {
        a,
        s,
        u,
        v
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 3;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"a", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"s", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"u", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"v", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        max_iter,
        epsilon,
        precision_config,
        T
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"max_iter", AttributeType::Int},
        AttributeDesc{"epsilon", AttributeType::Float},
        AttributeDesc{"precision_config", AttributeType::String},
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaConvV2
{
    static constexpr const char* name = "XlaConvV2";
    
    enum class Argument
    {
        lhs,
        rhs,
        window_strides,
        padding,
        lhs_dilation,
        rhs_dilation,
        feature_group_count,
        output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"lhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"lhs_dilation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"rhs_dilation", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"feature_group_count", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        LhsT,
        RhsT,
        Tindices,
        dimension_numbers,
        precision_config,
        preferred_element_type
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"LhsT", AttributeType::Type},
        AttributeDesc{"RhsT", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"precision_config", AttributeType::String},
        AttributeDesc{"preferred_element_type", AttributeType::Type}
    };
};

struct XlaSetDynamicDimensionSize
{
    static constexpr const char* name = "XlaSetDynamicDimensionSize";
    
    enum class Argument
    {
        input,
        dim_index,
        size,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dim_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"size", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaRemoveDynamicDimensionSize
{
    static constexpr const char* name = "XlaRemoveDynamicDimensionSize";
    
    enum class Argument
    {
        input,
        dim_index,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"dim_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaDynamicUpdateSlice
{
    static constexpr const char* name = "XlaDynamicUpdateSlice";
    
    enum class Argument
    {
        input,
        update,
        indices,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"update", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct XlaReduceWindow
{
    static constexpr const char* name = "XlaReduceWindow";
    
    enum class Argument
    {
        input,
        init_value,
        window_dimensions,
        window_strides,
        base_dilations,
        window_dilations,
        padding,
        output
    };

    static constexpr uint32_t input_arg_count = 7;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"init_value", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_dimensions", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_strides", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"base_dilations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"window_dilations", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"padding", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        Tindices,
        computation
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type},
        AttributeDesc{"computation", AttributeType::Func}
    };
};

struct XlaSend
{
    static constexpr const char* name = "XlaSend";
    
    enum class Argument
    {
        tensor
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"tensor", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        tensor_name
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"tensor_name", AttributeType::String}
    };
};

struct XlaSort
{
    static constexpr const char* name = "XlaSort";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type}
    };
};

struct XlaVariadicSort
{
    static constexpr const char* name = "XlaVariadicSort";
    
    enum class Argument
    {
        inputs,
        dimension,
        outputs
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"inputs", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"dimension", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"outputs", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        comparator,
        is_stable
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"comparator", AttributeType::Func},
        AttributeDesc{"is_stable", AttributeType::Bool}
    };
};

struct XlaGather
{
    static constexpr const char* name = "XlaGather";
    
    enum class Argument
    {
        operand,
        start_indices,
        slice_sizes,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"operand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"start_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"slice_sizes", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dimension_numbers,
        indices_are_sorted,
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"indices_are_sorted", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct XlaScatter
{
    static constexpr const char* name = "XlaScatter";
    
    enum class Argument
    {
        operand,
        scatter_indices,
        updates,
        output
    };

    static constexpr uint32_t input_arg_count = 3;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"operand", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"scatter_indices", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"updates", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        update_computation,
        dimension_numbers,
        indices_are_sorted,
        T,
        Tindices
    };

    static constexpr std::array<AttributeDesc, 5> attribute_descs
    {
        AttributeDesc{"update_computation", AttributeType::Func},
        AttributeDesc{"dimension_numbers", AttributeType::String},
        AttributeDesc{"indices_are_sorted", AttributeType::Bool},
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"Tindices", AttributeType::Type}
    };
};

struct _Arg
{
    static constexpr const char* name = "_Arg";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"index", AttributeType::Int}
    };
};

struct _DeviceArg
{
    static constexpr const char* name = "_DeviceArg";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"index", AttributeType::Int}
    };
};

struct _DeviceRetval
{
    static constexpr const char* name = "_DeviceRetval";
    
    enum class Argument
    {
        input
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 0;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        T,
        index
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"T", AttributeType::Type},
        AttributeDesc{"index", AttributeType::Int}
    };
};

struct SymbolicGradient
{
    static constexpr const char* name = "SymbolicGradient";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        f
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func}
    };
};

struct Case
{
    static constexpr const char* name = "Case";
    
    enum class Argument
    {
        branch_index,
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 2;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"branch_index", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        branches,
        output_shapes
    };

    static constexpr std::array<AttributeDesc, 4> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"branches", AttributeType::ListFunc},
        AttributeDesc{"output_shapes", AttributeType::ListShape}
    };
};

struct _While
{
    static constexpr const char* name = "_While";
    
    enum class Argument
    {
        input,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"input", ArgumentDesc::TensorCount::SequenceAttrList, "T"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "T"}
    };

    enum class Attribute
    {
        T,
        cond,
        body
    };

    static constexpr std::array<AttributeDesc, 3> attribute_descs
    {
        AttributeDesc{"T", AttributeType::ListType},
        AttributeDesc{"cond", AttributeType::Func},
        AttributeDesc{"body", AttributeType::Func}
    };
};

struct StatefulPartitionedCall
{
    static constexpr const char* name = "StatefulPartitionedCall";
    
    enum class Argument
    {
        args,
        output
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"args", ArgumentDesc::TensorCount::SequenceAttrList, "Tin"},
        ArgumentDesc{"output", ArgumentDesc::TensorCount::SequenceAttrList, "Tout"}
    };

    enum class Attribute
    {
        Tin,
        Tout,
        f,
        config,
        config_proto,
        executor_type
    };

    static constexpr std::array<AttributeDesc, 6> attribute_descs
    {
        AttributeDesc{"Tin", AttributeType::ListType},
        AttributeDesc{"Tout", AttributeType::ListType},
        AttributeDesc{"f", AttributeType::Func},
        AttributeDesc{"config", AttributeType::String},
        AttributeDesc{"config_proto", AttributeType::String},
        AttributeDesc{"executor_type", AttributeType::String}
    };
};

struct FakeParam
{
    static constexpr const char* name = "FakeParam";
    
    enum class Argument
    {
        output
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"output", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        dtype,
        shape
    };

    static constexpr std::array<AttributeDesc, 2> attribute_descs
    {
        AttributeDesc{"dtype", AttributeType::Type},
        AttributeDesc{"shape", AttributeType::Shape}
    };
};

struct DeviceIndex
{
    static constexpr const char* name = "DeviceIndex";
    
    enum class Argument
    {
        index
    };

    static constexpr uint32_t input_arg_count = 0;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"index", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        device_names
    };

    static constexpr std::array<AttributeDesc, 1> attribute_descs
    {
        AttributeDesc{"device_names", AttributeType::ListString}
    };
};

struct AudioMicrofrontend
{
    static constexpr const char* name = "AudioMicrofrontend";
    
    enum class Argument
    {
        audio,
        filterbanks
    };

    static constexpr uint32_t input_arg_count = 1;
    static constexpr uint32_t output_arg_count = 1;
    static constexpr std::array<ArgumentDesc, input_arg_count + output_arg_count> argument_descs
    {
        ArgumentDesc{"audio", ArgumentDesc::TensorCount::Single},
        ArgumentDesc{"filterbanks", ArgumentDesc::TensorCount::Single}
    };

    enum class Attribute
    {
        sample_rate,
        window_size,
        window_step,
        num_channels,
        upper_band_limit,
        lower_band_limit,
        smoothing_bits,
        even_smoothing,
        odd_smoothing,
        min_signal_remaining,
        enable_pcan,
        pcan_strength,
        pcan_offset,
        gain_bits,
        enable_log,
        scale_shift,
        left_context,
        right_context,
        frame_stride,
        zero_padding,
        out_scale,
        out_type
    };

    static constexpr std::array<AttributeDesc, 22> attribute_descs
    {
        AttributeDesc{"sample_rate", AttributeType::Int},
        AttributeDesc{"window_size", AttributeType::Int},
        AttributeDesc{"window_step", AttributeType::Int},
        AttributeDesc{"num_channels", AttributeType::Int},
        AttributeDesc{"upper_band_limit", AttributeType::Float},
        AttributeDesc{"lower_band_limit", AttributeType::Float},
        AttributeDesc{"smoothing_bits", AttributeType::Int},
        AttributeDesc{"even_smoothing", AttributeType::Float},
        AttributeDesc{"odd_smoothing", AttributeType::Float},
        AttributeDesc{"min_signal_remaining", AttributeType::Float},
        AttributeDesc{"enable_pcan", AttributeType::Bool},
        AttributeDesc{"pcan_strength", AttributeType::Float},
        AttributeDesc{"pcan_offset", AttributeType::Float},
        AttributeDesc{"gain_bits", AttributeType::Int},
        AttributeDesc{"enable_log", AttributeType::Bool},
        AttributeDesc{"scale_shift", AttributeType::Int},
        AttributeDesc{"left_context", AttributeType::Int},
        AttributeDesc{"right_context", AttributeType::Int},
        AttributeDesc{"frame_stride", AttributeType::Int},
        AttributeDesc{"zero_padding", AttributeType::Bool},
        AttributeDesc{"out_scale", AttributeType::Int},
        AttributeDesc{"out_type", AttributeType::Type}
    };
};

} // namespace tfdml::ops
